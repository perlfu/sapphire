Index: java/lang/reflect/Constructor.java
===================================================================
RCS file: java/lang/reflect/Constructor.java
diff -N java/lang/reflect/Constructor.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ java/lang/reflect/Constructor.java	2 Mar 2008 02:03:57 -0000
@@ -0,0 +1,426 @@
+/* java.lang.reflect.Constructor - reflection of Java constructors
+   Copyright (C) 1998, 2001, 2004, 2005 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package java.lang.reflect;
+
+import gnu.java.lang.ClassHelper;
+import gnu.java.lang.CPStringBuilder;
+
+import gnu.java.lang.reflect.MethodSignatureParser;
+
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
+
+/**
+ * The Constructor class represents a constructor of a class. It also allows
+ * dynamic creation of an object, via reflection. Invocation on Constructor
+ * objects knows how to do widening conversions, but throws
+ * {@link IllegalArgumentException} if a narrowing conversion would be
+ * necessary. You can query for information on this Constructor regardless
+ * of location, but construction access may be limited by Java language
+ * access controls. If you can't do it in the compiler, you can't normally
+ * do it here either.<p>
+ *
+ * <B>Note:</B> This class returns and accepts types as Classes, even
+ * primitive types; there are Class types defined that represent each
+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,
+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
+ * byte.class</code>, etc.  These are not to be confused with the
+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
+ * real classes.<p>
+ *
+ * Also note that this is not a serializable class.  It is entirely feasible
+ * to make it serializable using the Externalizable interface, but this is
+ * on Sun, not me.
+ *
+ * @author John Keiser
+ * @author Eric Blake <ebb9@email.byu.edu>
+ * @see Member
+ * @see Class
+ * @see java.lang.Class#getConstructor(Class[])
+ * @see java.lang.Class#getDeclaredConstructor(Class[])
+ * @see java.lang.Class#getConstructors()
+ * @see java.lang.Class#getDeclaredConstructors()
+ * @since 1.1
+ * @status updated to 1.4
+ */
+public final class Constructor<T>
+  extends AccessibleObject
+  implements GenericDeclaration, Member
+{
+  Class<T> clazz;
+  int slot;
+  
+  static final int CONSTRUCTOR_MODIFIERS
+    = Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC;
+
+  private MethodSignatureParser p;
+
+  /**
+   * This class is uninstantiable outside this package.
+   */
+  Constructor(Class<T> declaringClass,int slot)
+  {
+    this.clazz = declaringClass;
+    this.slot = slot;
+  }
+
+  private Constructor()
+  {
+  }
+
+  /**
+   * Gets the class that declared this constructor.
+   * @return the class that declared this member
+   */
+  public Class<T> getDeclaringClass()
+  {
+    return clazz;
+  }
+
+  /**
+   * Gets the name of this constructor (the non-qualified name of the class
+   * it was declared in).
+   * @return the name of this constructor
+   */
+  public String getName()
+  {
+    return getDeclaringClass().getName();
+  }
+
+  /**
+   * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>
+   * class to interpret the values. A constructor can only have a subset of the
+   * following modifiers: public, private, protected.
+   *
+   * @return an integer representing the modifiers to this Member
+   * @see Modifier
+   */
+  public int getModifiers()
+  {
+    return VMConstructor.getModifiersInternal(this) & CONSTRUCTOR_MODIFIERS;
+  }
+
+  /**
+   * Return true if this constructor is synthetic, false otherwise.
+   * A synthetic member is one which is created by the compiler,
+   * and which does not appear in the user's source code.
+   * @since 1.5
+   */
+  public boolean isSynthetic()
+  {
+    return (VMConstructor.getModifiersInternal(this) & Modifier.SYNTHETIC) != 0;
+  }
+
+  /**
+   * Return true if this is a varargs constructor, that is if
+   * the constructor takes a variable number of arguments.
+   * @since 1.5
+   */
+  public boolean isVarArgs()
+  {
+    return (VMConstructor.getModifiersInternal(this) & Modifier.VARARGS) != 0;
+  }
+
+  /**
+   * Get the parameter list for this constructor, in declaration order. If the
+   * constructor takes no parameters, returns a 0-length array (not null).
+   *
+   * @return a list of the types of the constructor's parameters
+   */
+  @SuppressWarnings("unchecked")
+  public Class<?>[] getParameterTypes()
+  {
+    return (Class<?>[]) VMConstructor.getParameterTypes(this);
+  }
+
+  /**
+   * Get the exception types this constructor says it throws, in no particular
+   * order. If the constructor has no throws clause, returns a 0-length array
+   * (not null).
+   *
+   * @return a list of the types in the constructor's throws clause
+   */
+  @SuppressWarnings("unchecked")
+  public Class<?>[] getExceptionTypes()
+  {
+    return (Class<?>[]) VMConstructor.getExceptionTypes(this);
+  }
+
+  /**
+   * Compare two objects to see if they are semantically equivalent.
+   * Two Constructors are semantically equivalent if they have the same
+   * declaring class and the same parameter list.  This ignores different
+   * exception clauses, but since you can't create a Method except through the
+   * VM, this is just the == relation.
+   *
+   * @param o the object to compare to
+   * @return <code>true</code> if they are equal; <code>false</code> if not.
+   */
+  public boolean equals(Object o)
+  {
+    if (!(o instanceof Constructor))
+      return false;
+    Constructor that = (Constructor)o; 
+    if (this.getDeclaringClass() != that.getDeclaringClass())
+      return false;
+    if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))
+      return false;
+    return true;
+  }
+
+  /**
+   * Get the hash code for the Constructor. The Constructor hash code is the
+   * hash code of the declaring class's name.
+   *
+   * @return the hash code for the object
+   */
+  public int hashCode()
+  {
+    return getDeclaringClass().getName().hashCode();
+  }
+
+  /**
+   * Get a String representation of the Constructor. A Constructor's String
+   * representation is "&lt;modifier&gt; &lt;classname&gt;(&lt;paramtypes&gt;)
+   * throws &lt;exceptions&gt;", where everything after ')' is omitted if
+   * there are no exceptions.<br> Example:
+   * <code>public java.io.FileInputStream(java.lang.Runnable)
+   * throws java.io.FileNotFoundException</code>
+   *
+   * @return the String representation of the Constructor
+   */
+  public String toString()
+  {
+    // 128 is a reasonable buffer initial size for constructor
+    CPStringBuilder sb = new CPStringBuilder(128);
+    Modifier.toString(getModifiers(), sb).append(' ');
+    sb.append(getDeclaringClass().getName()).append('(');
+    Class[] c = getParameterTypes();
+    if (c.length > 0)
+      {
+        sb.append(ClassHelper.getUserName(c[0]));
+        for (int i = 1; i < c.length; i++)
+          sb.append(',').append(ClassHelper.getUserName(c[i]));
+      }
+    sb.append(')');
+    c = getExceptionTypes();
+    if (c.length > 0)
+      {
+        sb.append(" throws ").append(c[0].getName());
+        for (int i = 1; i < c.length; i++)
+          sb.append(',').append(c[i].getName());
+      }
+    return sb.toString();
+  }
+
+  static <X extends GenericDeclaration>
+  void addTypeParameters(CPStringBuilder sb, TypeVariable<X>[] typeArgs)
+  {
+    if (typeArgs.length == 0)
+      return;
+    sb.append('<');
+    for (int i = 0; i < typeArgs.length; ++i)
+      {
+        if (i > 0)
+          sb.append(',');
+        sb.append(typeArgs[i]);
+      }
+    sb.append("> ");
+  }
+
+  public String toGenericString()
+  {
+    CPStringBuilder sb = new CPStringBuilder(128);
+    Modifier.toString(getModifiers(), sb).append(' ');
+    addTypeParameters(sb, getTypeParameters());
+    sb.append(getDeclaringClass().getName()).append('(');
+    Type[] types = getGenericParameterTypes();
+    if (types.length > 0)
+      {
+        sb.append(types[0]);
+        for (int i = 1; i < types.length; ++i)
+          sb.append(',').append(types[i]);
+      }
+    sb.append(')');
+    types = getGenericExceptionTypes();
+    if (types.length > 0)
+      {
+        sb.append(" throws ").append(types[0]);
+        for (int i = 1; i < types.length; i++)
+          sb.append(',').append(types[i]);
+      }
+    return sb.toString();
+  }
+
+  /**
+   * Create a new instance by invoking the constructor. Arguments are
+   * automatically unwrapped and widened, if needed.<p>
+   *
+   * If this class is abstract, you will get an
+   * <code>InstantiationException</code>. If the constructor takes 0
+   * arguments, you may use null or a 0-length array for <code>args</code>.<p>
+   *
+   * If this Constructor enforces access control, your runtime context is
+   * evaluated, and you may have an <code>IllegalAccessException</code> if
+   * you could not create this object in similar compiled code. If the class
+   * is uninitialized, you trigger class initialization, which may end in a
+   * <code>ExceptionInInitializerError</code>.<p>
+   *
+   * Then, the constructor is invoked. If it completes normally, the return
+   * value will be the new object. If it completes abruptly, the exception is
+   * wrapped in an <code>InvocationTargetException</code>.
+   *
+   * @param args the arguments to the constructor
+   * @return the newly created object
+   * @throws IllegalAccessException if the constructor could not normally be
+   *         called by the Java code (i.e. it is not public)
+   * @throws IllegalArgumentException if the number of arguments is incorrect;
+   *         or if the arguments types are wrong even with a widening
+   *         conversion
+   * @throws InstantiationException if the class is abstract
+   * @throws InvocationTargetException if the constructor throws an exception
+   * @throws ExceptionInInitializerError if construction triggered class
+   *         initialization, which then failed
+   */
+  @SuppressWarnings("unchecked")
+  public T newInstance(Object... args)
+    throws InstantiationException, IllegalAccessException,
+           InvocationTargetException
+  {
+    return (T) VMConstructor.constructNative(args, clazz, slot);
+  }
+
+  /**
+   * Returns an array of <code>TypeVariable</code> objects that represents
+   * the type variables declared by this constructor, in declaration order.
+   * An array of size zero is returned if this constructor has no type
+   * variables.
+   *
+   * @return the type variables associated with this constructor.
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public TypeVariable<Constructor<T>>[] getTypeParameters()
+  {
+    if (p == null)
+      {
+	String sig = VMConstructor.getSignature(this);
+	if (sig == null)
+	  return new TypeVariable[0];
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getTypeParameters();
+  }
+
+  /**
+   * Returns an array of <code>Type</code> objects that represents
+   * the exception types declared by this constructor, in declaration order.
+   * An array of size zero is returned if this constructor declares no
+   * exceptions.
+   *
+   * @return the exception types declared by this constructor. 
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public Type[] getGenericExceptionTypes()
+  {
+    if (p == null)
+      {
+	String sig = VMConstructor.getSignature(this);
+	if (sig == null)
+	  return getExceptionTypes();
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getGenericExceptionTypes();
+  }
+
+  /**
+   * Returns an array of <code>Type</code> objects that represents
+   * the parameter list for this constructor, in declaration order.
+   * An array of size zero is returned if this constructor takes no
+   * parameters.
+   *
+   * @return a list of the types of the constructor's parameters
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public Type[] getGenericParameterTypes()
+  {
+    if (p == null)
+      {
+	String sig = VMConstructor.getSignature(this);
+	if (sig == null)
+	  return getParameterTypes();
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getGenericParameterTypes();
+  }
+
+  /**
+   * <p>
+   * Return an array of arrays representing the annotations on each
+   * of the constructor's parameters.  The outer array is aligned against
+   * the parameters of the constructors and is thus equal in length to
+   * the number of parameters (thus having a length zero if there are none).
+   * Each array element in the outer array contains an inner array which
+   * holds the annotations.  This array has a length of zero if the parameter
+   * has no annotations.
+   * </p>
+   * <p>
+   * The returned annotations are serialized.  Changing the annotations has
+   * no affect on the return value of future calls to this method.
+   * </p>
+   * 
+   * @return an array of arrays which represents the annotations used on the
+   *         parameters of this constructor.  The order of the array elements
+   *         matches the declaration order of the parameters.
+   * @since 1.5
+   */
+  public Annotation[][] getParameterAnnotations()
+  {
+    return VMConstructor.getParameterAnnotations(this);
+  }
+
+}
Index: java/lang/reflect/Field.java
===================================================================
RCS file: java/lang/reflect/Field.java
diff -N java/lang/reflect/Field.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ java/lang/reflect/Field.java	2 Mar 2008 02:03:57 -0000
@@ -0,0 +1,713 @@
+/* java.lang.reflect.Field - reflection of Java fields
+   Copyright (C) 1998, 2001, 2005, 2008 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package java.lang.reflect;
+
+import gnu.java.lang.ClassHelper;
+import gnu.java.lang.CPStringBuilder;
+
+import gnu.java.lang.reflect.FieldSignatureParser;
+
+/**
+ * The Field class represents a member variable of a class. It also allows
+ * dynamic access to a member, via reflection. This works for both
+ * static and instance fields. Operations on Field objects know how to
+ * do widening conversions, but throw {@link IllegalArgumentException} if
+ * a narrowing conversion would be necessary. You can query for information
+ * on this Field regardless of location, but get and set access may be limited
+ * by Java language access controls. If you can't do it in the compiler, you
+ * can't normally do it here either.<p>
+ *
+ * <B>Note:</B> This class returns and accepts types as Classes, even
+ * primitive types; there are Class types defined that represent each
+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,
+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
+ * byte.class</code>, etc.  These are not to be confused with the
+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
+ * real classes.<p>
+ *
+ * Also note that this is not a serializable class.  It is entirely feasible
+ * to make it serializable using the Externalizable interface, but this is
+ * on Sun, not me.
+ *
+ * @author John Keiser
+ * @author Eric Blake <ebb9@email.byu.edu>
+ * @see Member
+ * @see Class
+ * @see Class#getField(String)
+ * @see Class#getDeclaredField(String)
+ * @see Class#getFields()
+ * @see Class#getDeclaredFields()
+ * @since 1.1
+ * @status updated to 1.4
+ */
+public final class Field
+extends AccessibleObject implements Member
+{
+  Class declaringClass;
+  String name;
+  int slot;
+
+  static final int FIELD_MODIFIERS
+    = Modifier.FINAL | Modifier.PRIVATE | Modifier.PROTECTED
+      | Modifier.PUBLIC | Modifier.STATIC | Modifier.TRANSIENT
+      | Modifier.VOLATILE;
+
+  private FieldSignatureParser p;
+
+  /**
+   * This class is uninstantiable outside the package.
+   */
+  Field(Class declaringClass, String name, int slot)
+  {
+    this.declaringClass = declaringClass;
+    this.name = name;
+    this.slot = slot;
+  }
+
+  /**
+   * Gets the class that declared this field, or the class where this field
+   * is a non-inherited member.
+   * @return the class that declared this member
+   */
+  public Class<?> getDeclaringClass()
+  {
+    return declaringClass;
+  }
+
+  /**
+   * Gets the name of this field.
+   * @return the name of this field
+   */
+  public String getName()
+  {
+    return name;
+  }
+
+  /**
+   * Gets the modifiers this field uses.  Use the <code>Modifier</code>
+   * class to interpret the values.  A field can only have a subset of the
+   * following modifiers: public, private, protected, static, final,
+   * transient, and volatile.
+   *
+   * @return an integer representing the modifiers to this Member
+   * @see Modifier
+   */
+  public int getModifiers()
+  {
+    return VMField.getModifiersInternal(this) & FIELD_MODIFIERS;
+  }
+
+  /**
+   * Return true if this field is synthetic, false otherwise.
+   * @since 1.5
+   */
+  public boolean isSynthetic()
+  {
+    return (VMField.getModifiersInternal(this) & Modifier.SYNTHETIC) != 0;
+  }
+
+  /**
+   * Return true if this field represents an enum constant,
+   * false otherwise.
+   * @since 1.5
+   */
+  public boolean isEnumConstant()
+  {
+    return (VMField.getModifiersInternal(this) & Modifier.ENUM) != 0;
+  }
+
+  /**
+   * Gets the type of this field.
+   * @return the type of this field
+   */
+  public Class<?> getType()
+  {
+    return VMField.getType(this);
+  }
+
+  /**
+   * Compare two objects to see if they are semantically equivalent.
+   * Two Fields are semantically equivalent if they have the same declaring
+   * class, name, and type. Since you can't creat a Field except through
+   * the VM, this is just the == relation.
+   *
+   * @param o the object to compare to
+   * @return <code>true</code> if they are equal; <code>false</code> if not
+   */
+  public boolean equals(Object o)
+  {
+    if (!(o instanceof Field))
+      return false;
+    Field that = (Field)o; 
+    if (this.getDeclaringClass() != that.getDeclaringClass())
+      return false;
+    if (!this.getName().equals(that.getName()))
+      return false;
+    if (this.getType() != that.getType())
+      return false;
+    return true;
+  }
+
+  /**
+   * Get the hash code for the Field. The Field hash code is the hash code
+   * of its name XOR'd with the hash code of its class name.
+   *
+   * @return the hash code for the object.
+   */
+  public int hashCode()
+  {
+    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
+  }
+
+  /**
+   * Get a String representation of the Field. A Field's String
+   * representation is "&lt;modifiers&gt; &lt;type&gt;
+   * &lt;class&gt;.&lt;fieldname&gt;".<br> Example:
+   * <code>public transient boolean gnu.parse.Parser.parseComplete</code>
+   *
+   * @return the String representation of the Field
+   */
+  public String toString()
+  {
+    // 64 is a reasonable buffer initial size for field
+    CPStringBuilder sb = new CPStringBuilder(64);
+    Modifier.toString(getModifiers(), sb).append(' ');
+    sb.append(ClassHelper.getUserName(getType())).append(' ');
+    sb.append(getDeclaringClass().getName()).append('.');
+    sb.append(getName());
+    return sb.toString();
+  }
+
+  public String toGenericString()
+  {
+    CPStringBuilder sb = new CPStringBuilder(64);
+    Modifier.toString(getModifiers(), sb).append(' ');
+    sb.append(getGenericType()).append(' ');
+    sb.append(getDeclaringClass().getName()).append('.');
+    sb.append(getName());
+    return sb.toString();
+  }
+
+  /**
+   * Get the value of this Field.  If it is primitive, it will be wrapped
+   * in the appropriate wrapper type (boolean = java.lang.Boolean).<p>
+   *
+   * If the field is static, <code>o</code> will be ignored. Otherwise, if
+   * <code>o</code> is null, you get a <code>NullPointerException</code>,
+   * and if it is incompatible with the declaring class of the field, you
+   * get an <code>IllegalArgumentException</code>.<p>
+   *
+   * Next, if this Field enforces access control, your runtime context is
+   * evaluated, and you may have an <code>IllegalAccessException</code> if
+   * you could not access this field in similar compiled code. If the field
+   * is static, and its class is uninitialized, you trigger class
+   * initialization, which may end in a
+   * <code>ExceptionInInitializerError</code>.<p>
+   *
+   * Finally, the field is accessed, and primitives are wrapped (but not
+   * necessarily in new objects). This method accesses the field of the
+   * declaring class, even if the instance passed in belongs to a subclass
+   * which declares another field to hide this one.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if <code>o</code> is not an instance of
+   *         the class or interface declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #getBoolean(Object)
+   * @see #getByte(Object)
+   * @see #getChar(Object)
+   * @see #getShort(Object)
+   * @see #getInt(Object)
+   * @see #getLong(Object)
+   * @see #getFloat(Object)
+   * @see #getDouble(Object)
+   */
+  public Object get(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.get(this, o);
+  }
+
+  /**
+   * Get the value of this boolean Field. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a boolean field of
+   *         <code>o</code>, or if <code>o</code> is not an instance of the
+   *         declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public boolean getBoolean(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getBoolean(this, o);
+  }
+
+  /**
+   * Get the value of this byte Field. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte field of
+   *         <code>o</code>, or if <code>o</code> is not an instance of the
+   *         declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public byte getByte(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getByte(this, o);
+  }
+
+  /**
+   * Get the value of this Field as a char. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a char field of
+   *         <code>o</code>, or if <code>o</code> is not an instance
+   *         of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public char getChar(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getChar(this, o);
+  }
+
+  /**
+   * Get the value of this Field as a short. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte or short
+   *         field of <code>o</code>, or if <code>o</code> is not an instance
+   *         of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public short getShort(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getShort(this, o);
+  }
+
+  /**
+   * Get the value of this Field as an int. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, or
+   *         int field of <code>o</code>, or if <code>o</code> is not an
+   *         instance of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public int getInt(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getInt(this, o);
+  }
+
+  /**
+   * Get the value of this Field as a long. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, int,
+   *         or long field of <code>o</code>, or if <code>o</code> is not an
+   *         instance of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public long getLong(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getLong(this, o);
+  }
+
+  /**
+   * Get the value of this Field as a float. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, int,
+   *         long, or float field of <code>o</code>, or if <code>o</code> is
+   *         not an instance of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public float getFloat(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getFloat(this, o);
+  }
+
+  /**
+   * Get the value of this Field as a double. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, int,
+   *         long, float, or double field of <code>o</code>, or if
+   *         <code>o</code> is not an instance of the declaring class of this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  public double getDouble(Object o)
+    throws IllegalAccessException
+  {
+    return VMField.getDouble(this, o);
+  }
+
+  /**
+   * Set the value of this Field.  If it is a primitive field, the value
+   * will be unwrapped from the passed object (boolean = java.lang.Boolean).<p>
+   *
+   * If the field is static, <code>o</code> will be ignored. Otherwise, if
+   * <code>o</code> is null, you get a <code>NullPointerException</code>,
+   * and if it is incompatible with the declaring class of the field, you
+   * get an <code>IllegalArgumentException</code>.<p>
+   *
+   * Next, if this Field enforces access control, your runtime context is
+   * evaluated, and you may have an <code>IllegalAccessException</code> if
+   * you could not access this field in similar compiled code. This also
+   * occurs whether or not there is access control if the field is final.
+   * If the field is primitive, and unwrapping your argument fails, you will
+   * get an <code>IllegalArgumentException</code>; likewise, this error
+   * happens if <code>value</code> cannot be cast to the correct object type.
+   * If the field is static, and its class is uninitialized, you trigger class
+   * initialization, which may end in a
+   * <code>ExceptionInInitializerError</code>.<p>
+   *
+   * Finally, the field is set with the widened value. This method accesses
+   * the field of the declaring class, even if the instance passed in belongs
+   * to a subclass which declares another field to hide this one.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if <code>value</code> cannot be
+   *         converted by a widening conversion to the underlying type of
+   *         the Field, or if <code>o</code> is not an instance of the class
+   *         declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #setBoolean(Object, boolean)
+   * @see #setByte(Object, byte)
+   * @see #setChar(Object, char)
+   * @see #setShort(Object, short)
+   * @see #setInt(Object, int)
+   * @see #setLong(Object, long)
+   * @see #setFloat(Object, float)
+   * @see #setDouble(Object, double)
+   */
+  public void set(Object o, Object value)
+    throws IllegalAccessException
+  {
+    VMField.set(this, o, value);
+  }
+
+  /**
+   * Set this boolean Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a boolean field, or if
+   *         <code>o</code> is not an instance of the class declaring this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setBoolean(Object o, boolean value)
+    throws IllegalAccessException
+  {
+    VMField.setBoolean(this, o, value);
+  }
+
+  /**
+   * Set this byte Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, int, long,
+   *         float, or double field, or if <code>o</code> is not an instance
+   *         of the class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setByte(Object o, byte value)
+    throws IllegalAccessException
+  {
+    VMField.setByte(this, o, value);
+  }
+
+  /**
+   * Set this char Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a char, int, long,
+   *         float, or double field, or if <code>o</code> is not an instance
+   *         of the class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setChar(Object o, char value)
+    throws IllegalAccessException
+  {
+    VMField.setChar(this, o, value);
+  }
+
+  /**
+   * Set this short Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a short, int, long,
+   *         float, or double field, or if <code>o</code> is not an instance
+   *         of the class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setShort(Object o, short value)
+    throws IllegalAccessException
+  {
+    VMField.setShort(this, o, value);
+  }
+
+  /**
+   * Set this int Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not an int, long, float, or
+   *         double field, or if <code>o</code> is not an instance of the
+   *         class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setInt(Object o, int value)
+    throws IllegalAccessException
+  {
+    VMField.setInt(this, o, value);
+  }
+
+  /**
+   * Set this long Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a long, float, or double
+   *         field, or if <code>o</code> is not an instance of the class
+   *         declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setLong(Object o, long value)
+    throws IllegalAccessException
+  {
+    VMField.setLong(this, o, value);
+  }
+
+  /**
+   * Set this float Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a float or long field, or
+   *         if <code>o</code> is not an instance of the class declaring this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setFloat(Object o, float value)
+    throws IllegalAccessException
+  {
+    VMField.setFloat(this, o, value);
+  }
+
+  /**
+   * Set this double Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a double field, or if
+   *         <code>o</code> is not an instance of the class declaring this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  public void setDouble(Object o, double value)
+    throws IllegalAccessException
+  {
+    VMField.setDouble(this, o, value);
+  }
+
+  /**
+   * Return the generic type of the field. If the field type is not a generic
+   * type, the method returns the same as <code>getType()</code>.
+   *
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public Type getGenericType()
+  {
+    if (p == null)
+      {
+	String signature = VMField.getSignature(this);
+	if (signature == null)
+	  return getType();
+	p = new FieldSignatureParser(getDeclaringClass(),
+				     signature);
+      }
+    return p.getFieldType();
+  }
+
+}
Index: java/lang/reflect/Method.java
===================================================================
RCS file: java/lang/reflect/Method.java
diff -N java/lang/reflect/Method.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ java/lang/reflect/Method.java	2 Mar 2008 02:03:57 -0000
@@ -0,0 +1,502 @@
+/* java.lang.reflect.Method - reflection of Java methods
+   Copyright (C) 1998, 2001, 2002, 2005, 2007, 2008 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package java.lang.reflect;
+
+import gnu.java.lang.ClassHelper;
+import gnu.java.lang.CPStringBuilder;
+
+import gnu.java.lang.reflect.MethodSignatureParser;
+
+import java.lang.annotation.Annotation;
+import java.util.Arrays;
+
+/**
+ * The Method class represents a member method of a class. It also allows
+ * dynamic invocation, via reflection. This works for both static and
+ * instance methods. Invocation on Method objects knows how to do
+ * widening conversions, but throws {@link IllegalArgumentException} if
+ * a narrowing conversion would be necessary. You can query for information
+ * on this Method regardless of location, but invocation access may be limited
+ * by Java language access controls. If you can't do it in the compiler, you
+ * can't normally do it here either.<p>
+ *
+ * <B>Note:</B> This class returns and accepts types as Classes, even
+ * primitive types; there are Class types defined that represent each
+ * different primitive type.  They are <code>java.lang.Boolean.TYPE,
+ * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
+ * byte.class</code>, etc.  These are not to be confused with the
+ * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
+ * real classes.<p>
+ *
+ * Also note that this is not a serializable class.  It is entirely feasible
+ * to make it serializable using the Externalizable interface, but this is
+ * on Sun, not me.
+ *
+ * @author John Keiser
+ * @author Eric Blake <ebb9@email.byu.edu>
+ * @see Member
+ * @see Class
+ * @see java.lang.Class#getMethod(String,Class[])
+ * @see java.lang.Class#getDeclaredMethod(String,Class[])
+ * @see java.lang.Class#getMethods()
+ * @see java.lang.Class#getDeclaredMethods()
+ * @since 1.1
+ * @status updated to 1.4
+ */
+public final class Method
+extends AccessibleObject implements Member, GenericDeclaration
+{
+  Class declaringClass;
+  String name;
+  int slot;
+
+  static final int METHOD_MODIFIERS
+    = Modifier.ABSTRACT | Modifier.FINAL | Modifier.NATIVE
+      | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC
+      | Modifier.STATIC | Modifier.STRICT | Modifier.SYNCHRONIZED;
+
+  private MethodSignatureParser p;
+
+  /**
+   * This class is uninstantiable outside this package.
+   */
+  Method(Class declaringClass, String name, int slot)
+  {
+    this.declaringClass = declaringClass;
+    this.name = name;
+    this.slot = slot;
+  }
+
+  /**
+   * Gets the class that declared this method, or the class where this method
+   * is a non-inherited member.
+   * @return the class that declared this member
+   */
+  public Class<?> getDeclaringClass()
+  {
+    return declaringClass;
+  }
+
+  /**
+   * Gets the name of this method.
+   * @return the name of this method
+   */
+  public String getName()
+  {
+    return name;
+  }
+
+  /**
+   * Gets the modifiers this method uses.  Use the <code>Modifier</code>
+   * class to interpret the values.  A method can only have a subset of the
+   * following modifiers: public, private, protected, abstract, static,
+   * final, synchronized, native, and strictfp.
+   *
+   * @return an integer representing the modifiers to this Member
+   * @see Modifier
+   */
+  public int getModifiers()
+  {
+    return VMMethod.getModifiersInternal(this) & METHOD_MODIFIERS;
+  }
+
+  /**
+   * Return true if this method is a bridge method.  A bridge method
+   * is generated by the compiler in some situations involving
+   * generics and inheritance.
+   * @since 1.5
+   */
+  public boolean isBridge()
+  {
+    return (VMMethod.getModifiersInternal(this) & Modifier.BRIDGE) != 0;
+  }
+
+  /**
+   * Return true if this method is synthetic, false otherwise.
+   * @since 1.5
+   */
+  public boolean isSynthetic()
+  {
+    return (VMMethod.getModifiersInternal(this) & Modifier.SYNTHETIC) != 0;
+  }
+
+  /**
+   * Return true if this is a varargs method, that is if
+   * the method takes a variable number of arguments.
+   * @since 1.5
+   */
+  public boolean isVarArgs()
+  {
+    return (VMMethod.getModifiersInternal(this) & Modifier.VARARGS) != 0;
+  }
+
+  /**
+   * Gets the return type of this method.
+   * @return the type of this method
+   */
+  @SuppressWarnings("unchecked")
+  public Class<?> getReturnType()
+  {
+    return (Class<?>) VMMethod.getReturnType(this);
+  }
+
+  /**
+   * Get the parameter list for this method, in declaration order. If the
+   * method takes no parameters, returns a 0-length array (not null).
+   *
+   * @return a list of the types of the method's parameters
+   */
+  @SuppressWarnings("unchecked")
+  public Class<?>[] getParameterTypes()
+  {
+    return (Class<?>[]) VMMethod.getParameterTypes(this);
+  }
+
+  /**
+   * Get the exception types this method says it throws, in no particular
+   * order. If the method has no throws clause, returns a 0-length array
+   * (not null).
+   *
+   * @return a list of the types in the method's throws clause
+   */
+  @SuppressWarnings("unchecked")
+  public Class<?>[] getExceptionTypes()
+  {
+    return (Class<?>[]) VMMethod.getExceptionTypes(this);
+  }
+
+  /**
+   * Compare two objects to see if they are semantically equivalent.
+   * Two Methods are semantically equivalent if they have the same declaring
+   * class, name, parameter list, and return type.
+   *
+   * @param o the object to compare to
+   * @return <code>true</code> if they are equal; <code>false</code> if not
+   */
+  public boolean equals(Object o)
+  {
+      // Implementation note:
+      // The following is a correct but possibly slow implementation.
+      //
+      // This class has a private field 'slot' that could be used by
+      // the VM implementation to "link" a particular method to a Class.
+      // In that case equals could be simply implemented as:
+      //
+      // if (o instanceof Method)
+      // {
+      //    Method m = (Method)o;
+      //    return m.declaringClass == this.declaringClass
+      //           && m.slot == this.slot;
+      // }
+      // return false;
+      //
+      // If a VM uses the Method class as their native/internal representation
+      // then just using the following would be optimal:
+      //
+      // return this == o;
+      //
+    if (!(o instanceof Method))
+      return false;
+    Method that = (Method)o;
+    if (this.getDeclaringClass() != that.getDeclaringClass())
+      return false;
+    if (!this.getName().equals(that.getName()))
+      return false;
+    if (this.getReturnType() != that.getReturnType())
+      return false;
+    if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))
+      return false;
+    return true;
+  }
+
+  /**
+   * Get the hash code for the Method. The Method hash code is the hash code
+   * of its name XOR'd with the hash code of its class name.
+   *
+   * @return the hash code for the object
+   */
+  public int hashCode()
+  {
+    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
+  }
+
+  /**
+   * Get a String representation of the Method. A Method's String
+   * representation is "&lt;modifiers&gt; &lt;returntype&gt;
+   * &lt;methodname&gt;(&lt;paramtypes&gt;) throws &lt;exceptions&gt;", where
+   * everything after ')' is omitted if there are no exceptions.<br> Example:
+   * <code>public static int run(java.lang.Runnable,int)</code>
+   *
+   * @return the String representation of the Method
+   */
+  public String toString()
+  {
+    // 128 is a reasonable buffer initial size for constructor
+    CPStringBuilder sb = new CPStringBuilder(128);
+    Modifier.toString(getModifiers(), sb).append(' ');
+    sb.append(ClassHelper.getUserName(getReturnType())).append(' ');
+    sb.append(getDeclaringClass().getName()).append('.');
+    sb.append(getName()).append('(');
+    Class[] c = getParameterTypes();
+    if (c.length > 0)
+      {
+        sb.append(ClassHelper.getUserName(c[0]));
+        for (int i = 1; i < c.length; i++)
+          sb.append(',').append(ClassHelper.getUserName(c[i]));
+      }
+    sb.append(')');
+    c = getExceptionTypes();
+    if (c.length > 0)
+      {
+        sb.append(" throws ").append(c[0].getName());
+        for (int i = 1; i < c.length; i++)
+          sb.append(',').append(c[i].getName());
+      }
+    return sb.toString();
+  }
+
+  public String toGenericString()
+  {
+    // 128 is a reasonable buffer initial size for constructor
+    CPStringBuilder sb = new CPStringBuilder(128);
+    Modifier.toString(getModifiers(), sb).append(' ');
+    Constructor.addTypeParameters(sb, getTypeParameters());
+    sb.append(getGenericReturnType()).append(' ');
+    sb.append(getDeclaringClass().getName()).append('.');
+    sb.append(getName()).append('(');
+    Type[] types = getGenericParameterTypes();
+    if (types.length > 0)
+      {
+        sb.append(types[0]);
+        for (int i = 1; i < types.length; i++)
+          sb.append(',').append(types[i]);
+      }
+    sb.append(')');
+    types = getGenericExceptionTypes();
+    if (types.length > 0)
+      {
+        sb.append(" throws ").append(types[0]);
+        for (int i = 1; i < types.length; i++)
+          sb.append(',').append(types[i]);
+      }
+    return sb.toString();
+  }
+
+  /**
+   * Invoke the method. Arguments are automatically unwrapped and widened,
+   * and the result is automatically wrapped, if needed.<p>
+   *
+   * If the method is static, <code>o</code> will be ignored. Otherwise,
+   * the method uses dynamic lookup as described in JLS 15.12.4.4. You cannot
+   * mimic the behavior of nonvirtual lookup (as in super.foo()). This means
+   * you will get a <code>NullPointerException</code> if <code>o</code> is
+   * null, and an <code>IllegalArgumentException</code> if it is incompatible
+   * with the declaring class of the method. If the method takes 0 arguments,
+   * you may use null or a 0-length array for <code>args</code>.<p>
+   *
+   * Next, if this Method enforces access control, your runtime context is
+   * evaluated, and you may have an <code>IllegalAccessException</code> if
+   * you could not acces this method in similar compiled code. If the method
+   * is static, and its class is uninitialized, you trigger class
+   * initialization, which may end in a
+   * <code>ExceptionInInitializerError</code>.<p>
+   *
+   * Finally, the method is invoked. If it completes normally, the return value
+   * will be null for a void method, a wrapped object for a primitive return
+   * method, or the actual return of an Object method. If it completes
+   * abruptly, the exception is wrapped in an
+   * <code>InvocationTargetException</code>.
+   *
+   * @param o the object to invoke the method on
+   * @param args the arguments to the method
+   * @return the return value of the method, wrapped in the appropriate
+   *         wrapper if it is primitive
+   * @throws IllegalAccessException if the method could not normally be called
+   *         by the Java code (i.e. it is not public)
+   * @throws IllegalArgumentException if the number of arguments is incorrect;
+   *         if the arguments types are wrong even with a widening conversion;
+   *         or if <code>o</code> is not an instance of the class or interface
+   *         declaring this method
+   * @throws InvocationTargetException if the method throws an exception
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static method triggered
+   *         class initialization, which then failed
+   */
+  public Object invoke(Object o, Object... args)
+    throws IllegalAccessException, InvocationTargetException
+  {
+    return VMMethod.invokeNative(o, args, declaringClass, slot);
+  }
+
+  /**
+   * Returns an array of <code>TypeVariable</code> objects that represents
+   * the type variables declared by this constructor, in declaration order.
+   * An array of size zero is returned if this class has no type
+   * variables.
+   *
+   * @return the type variables associated with this class. 
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public TypeVariable<Method>[] getTypeParameters()
+  {
+    if (p == null)
+      {
+	String sig = VMMethod.getSignature(this);
+	if (sig == null)
+	  return (TypeVariable<Method>[]) new TypeVariable[0];
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getTypeParameters();
+  }
+
+  /**
+   * Returns an array of <code>Type</code> objects that represents
+   * the exception types declared by this method, in declaration order.
+   * An array of size zero is returned if this method declares no
+   * exceptions.
+   *
+   * @return the exception types declared by this method. 
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public Type[] getGenericExceptionTypes()
+  {
+    if (p == null)
+      {
+	String sig = VMMethod.getSignature(this);
+	if (sig == null)
+	  return getExceptionTypes();
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getGenericExceptionTypes();
+  }
+
+  /**
+   * Returns an array of <code>Type</code> objects that represents
+   * the parameter list for this method, in declaration order.
+   * An array of size zero is returned if this method takes no
+   * parameters.
+   *
+   * @return a list of the types of the method's parameters
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public Type[] getGenericParameterTypes()
+  {
+    if (p == null)
+      {
+	String sig = VMMethod.getSignature(this);
+	if (sig == null)
+	  return getParameterTypes();
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getGenericParameterTypes();
+  }
+
+  /**
+   * Returns the return type of this method.
+   *
+   * @return the return type of this method
+   * @throws GenericSignatureFormatError if the generic signature does
+   *         not conform to the format specified in the Virtual Machine
+   *         specification, version 3.
+   * @since 1.5
+   */
+  public Type getGenericReturnType()
+  {
+    if (p == null)
+      {
+	String sig = VMMethod.getSignature(this);
+	if (sig == null)
+	  return getReturnType();
+	p = new MethodSignatureParser(this, sig);
+      }
+    return p.getGenericReturnType();
+  }
+
+  /**
+   * If this method is an annotation method, returns the default
+   * value for the method.  If there is no default value, or if the
+   * method is not a member of an annotation type, returns null.
+   * Primitive types are wrapped.
+   *
+   * @throws TypeNotPresentException if the method returns a Class,
+   * and the class cannot be found
+   *
+   * @since 1.5
+   */
+  public Object getDefaultValue()
+  {
+    return VMMethod.getDefaultValue(this);
+  }
+
+  /**
+   * <p>
+   * Return an array of arrays representing the annotations on each
+   * of the method's parameters.  The outer array is aligned against
+   * the parameters of the method and is thus equal in length to
+   * the number of parameters (thus having a length zero if there are none).
+   * Each array element in the outer array contains an inner array which
+   * holds the annotations.  This array has a length of zero if the parameter
+   * has no annotations.
+   * </p>
+   * <p>
+   * The returned annotations are serialized.  Changing the annotations has
+   * no affect on the return value of future calls to this method.
+   * </p>
+   * 
+   * @return an array of arrays which represents the annotations used on the
+   *         parameters of this method.  The order of the array elements
+   *         matches the declaration order of the parameters.
+   * @since 1.5
+   */
+  public Annotation[][] getParameterAnnotations()
+  {
+    return VMMethod.getParameterAnnotations(this);
+  }
+
+}
Index: vm/reference/java/lang/reflect/Constructor.java
===================================================================
RCS file: vm/reference/java/lang/reflect/Constructor.java
diff -N vm/reference/java/lang/reflect/Constructor.java
--- vm/reference/java/lang/reflect/Constructor.java	1 Mar 2008 10:13:32 -0000	1.24
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,421 +0,0 @@
-/* java.lang.reflect.Constructor - reflection of Java constructors
-   Copyright (C) 1998, 2001, 2004, 2005 Free Software Foundation, Inc.
-
-This file is part of GNU Classpath.
-
-GNU Classpath is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
- 
-GNU Classpath is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU Classpath; see the file COPYING.  If not, write to the
-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
-
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
-
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version. */
-
-
-package java.lang.reflect;
-
-import gnu.java.lang.ClassHelper;
-import gnu.java.lang.CPStringBuilder;
-
-import gnu.java.lang.reflect.MethodSignatureParser;
-
-import java.lang.annotation.Annotation;
-import java.util.Arrays;
-
-/**
- * The Constructor class represents a constructor of a class. It also allows
- * dynamic creation of an object, via reflection. Invocation on Constructor
- * objects knows how to do widening conversions, but throws
- * {@link IllegalArgumentException} if a narrowing conversion would be
- * necessary. You can query for information on this Constructor regardless
- * of location, but construction access may be limited by Java language
- * access controls. If you can't do it in the compiler, you can't normally
- * do it here either.<p>
- *
- * <B>Note:</B> This class returns and accepts types as Classes, even
- * primitive types; there are Class types defined that represent each
- * different primitive type.  They are <code>java.lang.Boolean.TYPE,
- * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
- * byte.class</code>, etc.  These are not to be confused with the
- * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
- * real classes.<p>
- *
- * Also note that this is not a serializable class.  It is entirely feasible
- * to make it serializable using the Externalizable interface, but this is
- * on Sun, not me.
- *
- * @author John Keiser
- * @author Eric Blake <ebb9@email.byu.edu>
- * @see Member
- * @see Class
- * @see java.lang.Class#getConstructor(Class[])
- * @see java.lang.Class#getDeclaredConstructor(Class[])
- * @see java.lang.Class#getConstructors()
- * @see java.lang.Class#getDeclaredConstructors()
- * @since 1.1
- * @status updated to 1.4
- */
-public final class Constructor<T>
-  extends AccessibleObject
-  implements GenericDeclaration, Member
-{
-  private Class<T> clazz;
-  private int slot;
-  
-  private static final int CONSTRUCTOR_MODIFIERS
-    = Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC;
-
-  /**
-   * This class is uninstantiable except from native code.
-   */
-  private Constructor(Class declaringClass,int slot)
-  {
-    this.clazz = declaringClass;
-    this.slot = slot;
-  }
-
-  private Constructor()
-  {
-  }
-
-  /**
-   * Gets the class that declared this constructor.
-   * @return the class that declared this member
-   */
-  public Class<T> getDeclaringClass()
-  {
-    return clazz;
-  }
-
-  /**
-   * Gets the name of this constructor (the non-qualified name of the class
-   * it was declared in).
-   * @return the name of this constructor
-   */
-  public String getName()
-  {
-    return getDeclaringClass().getName();
-  }
-
-  /**
-   * Return the raw modifiers for this constructor.  In particular
-   * this will include the synthetic and varargs bits.
-   * @return the constructor's modifiers
-   */
-  private native int getModifiersInternal();
-
-  /**
-   * Gets the modifiers this constructor uses.  Use the <code>Modifier</code>
-   * class to interpret the values. A constructor can only have a subset of the
-   * following modifiers: public, private, protected.
-   *
-   * @return an integer representing the modifiers to this Member
-   * @see Modifier
-   */
-  public int getModifiers()
-  {
-    return getModifiersInternal() & CONSTRUCTOR_MODIFIERS;
-  }
-
-  /**
-   * Return true if this constructor is synthetic, false otherwise.
-   * A synthetic member is one which is created by the compiler,
-   * and which does not appear in the user's source code.
-   * @since 1.5
-   */
-  public boolean isSynthetic()
-  {
-    return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;
-  }
-
-  /**
-   * Return true if this is a varargs constructor, that is if
-   * the constructor takes a variable number of arguments.
-   * @since 1.5
-   */
-  public boolean isVarArgs()
-  {
-    return (getModifiersInternal() & Modifier.VARARGS) != 0;
-  }
-
-  /**
-   * Get the parameter list for this constructor, in declaration order. If the
-   * constructor takes no parameters, returns a 0-length array (not null).
-   *
-   * @return a list of the types of the constructor's parameters
-   */
-  public native Class<?>[] getParameterTypes();
-
-  /**
-   * Get the exception types this constructor says it throws, in no particular
-   * order. If the constructor has no throws clause, returns a 0-length array
-   * (not null).
-   *
-   * @return a list of the types in the constructor's throws clause
-   */
-  public native Class<?>[] getExceptionTypes();
-
-  /**
-   * Compare two objects to see if they are semantically equivalent.
-   * Two Constructors are semantically equivalent if they have the same
-   * declaring class and the same parameter list.  This ignores different
-   * exception clauses, but since you can't create a Method except through the
-   * VM, this is just the == relation.
-   *
-   * @param o the object to compare to
-   * @return <code>true</code> if they are equal; <code>false</code> if not.
-   */
-  public boolean equals(Object o)
-  {
-    if (!(o instanceof Constructor))
-      return false;
-    Constructor that = (Constructor)o; 
-    if (this.getDeclaringClass() != that.getDeclaringClass())
-      return false;
-    if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))
-      return false;
-    return true;
-  }
-
-  /**
-   * Get the hash code for the Constructor. The Constructor hash code is the
-   * hash code of the declaring class's name.
-   *
-   * @return the hash code for the object
-   */
-  public int hashCode()
-  {
-    return getDeclaringClass().getName().hashCode();
-  }
-
-  /**
-   * Get a String representation of the Constructor. A Constructor's String
-   * representation is "&lt;modifier&gt; &lt;classname&gt;(&lt;paramtypes&gt;)
-   * throws &lt;exceptions&gt;", where everything after ')' is omitted if
-   * there are no exceptions.<br> Example:
-   * <code>public java.io.FileInputStream(java.lang.Runnable)
-   * throws java.io.FileNotFoundException</code>
-   *
-   * @return the String representation of the Constructor
-   */
-  public String toString()
-  {
-    // 128 is a reasonable buffer initial size for constructor
-    CPStringBuilder sb = new CPStringBuilder(128);
-    Modifier.toString(getModifiers(), sb).append(' ');
-    sb.append(getDeclaringClass().getName()).append('(');
-    Class[] c = getParameterTypes();
-    if (c.length > 0)
-      {
-        sb.append(ClassHelper.getUserName(c[0]));
-        for (int i = 1; i < c.length; i++)
-          sb.append(',').append(ClassHelper.getUserName(c[i]));
-      }
-    sb.append(')');
-    c = getExceptionTypes();
-    if (c.length > 0)
-      {
-        sb.append(" throws ").append(c[0].getName());
-        for (int i = 1; i < c.length; i++)
-          sb.append(',').append(c[i].getName());
-      }
-    return sb.toString();
-  }
-
-  static <X extends GenericDeclaration>
-  void addTypeParameters(CPStringBuilder sb, TypeVariable<X>[] typeArgs)
-  {
-    if (typeArgs.length == 0)
-      return;
-    sb.append('<');
-    for (int i = 0; i < typeArgs.length; ++i)
-      {
-        if (i > 0)
-          sb.append(',');
-        sb.append(typeArgs[i]);
-      }
-    sb.append("> ");
-  }
-
-  public String toGenericString()
-  {
-    CPStringBuilder sb = new CPStringBuilder(128);
-    Modifier.toString(getModifiers(), sb).append(' ');
-    addTypeParameters(sb, getTypeParameters());
-    sb.append(getDeclaringClass().getName()).append('(');
-    Type[] types = getGenericParameterTypes();
-    if (types.length > 0)
-      {
-        sb.append(types[0]);
-        for (int i = 1; i < types.length; ++i)
-          sb.append(',').append(types[i]);
-      }
-    sb.append(')');
-    types = getGenericExceptionTypes();
-    if (types.length > 0)
-      {
-        sb.append(" throws ").append(types[0]);
-        for (int i = 1; i < types.length; i++)
-          sb.append(',').append(types[i]);
-      }
-    return sb.toString();
-  }
-
-  /**
-   * Create a new instance by invoking the constructor. Arguments are
-   * automatically unwrapped and widened, if needed.<p>
-   *
-   * If this class is abstract, you will get an
-   * <code>InstantiationException</code>. If the constructor takes 0
-   * arguments, you may use null or a 0-length array for <code>args</code>.<p>
-   *
-   * If this Constructor enforces access control, your runtime context is
-   * evaluated, and you may have an <code>IllegalAccessException</code> if
-   * you could not create this object in similar compiled code. If the class
-   * is uninitialized, you trigger class initialization, which may end in a
-   * <code>ExceptionInInitializerError</code>.<p>
-   *
-   * Then, the constructor is invoked. If it completes normally, the return
-   * value will be the new object. If it completes abruptly, the exception is
-   * wrapped in an <code>InvocationTargetException</code>.
-   *
-   * @param args the arguments to the constructor
-   * @return the newly created object
-   * @throws IllegalAccessException if the constructor could not normally be
-   *         called by the Java code (i.e. it is not public)
-   * @throws IllegalArgumentException if the number of arguments is incorrect;
-   *         or if the arguments types are wrong even with a widening
-   *         conversion
-   * @throws InstantiationException if the class is abstract
-   * @throws InvocationTargetException if the constructor throws an exception
-   * @throws ExceptionInInitializerError if construction triggered class
-   *         initialization, which then failed
-   */
-  public T newInstance(Object... args)
-    throws InstantiationException, IllegalAccessException,
-           InvocationTargetException
-  {
-    return constructNative(args, clazz, slot);
-  }
-
-  private native T constructNative(Object[] args, Class declaringClass,
-				   int slot)
-    throws InstantiationException, IllegalAccessException,
-           InvocationTargetException;
-
-  /**
-   * Returns an array of <code>TypeVariable</code> objects that represents
-   * the type variables declared by this constructor, in declaration order.
-   * An array of size zero is returned if this constructor has no type
-   * variables.
-   *
-   * @return the type variables associated with this constructor.
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public TypeVariable<Constructor<T>>[] getTypeParameters()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return new TypeVariable[0];
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getTypeParameters();
-  }
-
-  /**
-   * Return the String in the Signature attribute for this constructor. If there
-   * is no Signature attribute, return null.
-   */
-  private native String getSignature();
-
-  /**
-   * Returns an array of <code>Type</code> objects that represents
-   * the exception types declared by this constructor, in declaration order.
-   * An array of size zero is returned if this constructor declares no
-   * exceptions.
-   *
-   * @return the exception types declared by this constructor. 
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public Type[] getGenericExceptionTypes()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return getExceptionTypes();
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getGenericExceptionTypes();
-  }
-
-  /**
-   * Returns an array of <code>Type</code> objects that represents
-   * the parameter list for this constructor, in declaration order.
-   * An array of size zero is returned if this constructor takes no
-   * parameters.
-   *
-   * @return a list of the types of the constructor's parameters
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public Type[] getGenericParameterTypes()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return getParameterTypes();
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getGenericParameterTypes();
-  }
-
-  /**
-   * <p>
-   * Return an array of arrays representing the annotations on each
-   * of the constructor's parameters.  The outer array is aligned against
-   * the parameters of the constructors and is thus equal in length to
-   * the number of parameters (thus having a length zero if there are none).
-   * Each array element in the outer array contains an inner array which
-   * holds the annotations.  This array has a length of zero if the parameter
-   * has no annotations.
-   * </p>
-   * <p>
-   * The returned annotations are serialized.  Changing the annotations has
-   * no affect on the return value of future calls to this method.
-   * </p>
-   * 
-   * @return an array of arrays which represents the annotations used on the
-   *         parameters of this constructor.  The order of the array elements
-   *         matches the declaration order of the parameters.
-   * @since 1.5
-   */
-  public native Annotation[][] getParameterAnnotations();
-
-}
Index: vm/reference/java/lang/reflect/Field.java
===================================================================
RCS file: vm/reference/java/lang/reflect/Field.java
diff -N vm/reference/java/lang/reflect/Field.java
--- vm/reference/java/lang/reflect/Field.java	1 Mar 2008 10:13:33 -0000	1.17
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,662 +0,0 @@
-/* java.lang.reflect.Field - reflection of Java fields
-   Copyright (C) 1998, 2001, 2005, 2008 Free Software Foundation, Inc.
-
-This file is part of GNU Classpath.
-
-GNU Classpath is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
- 
-GNU Classpath is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU Classpath; see the file COPYING.  If not, write to the
-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
-
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
-
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version. */
-
-
-package java.lang.reflect;
-
-import gnu.java.lang.ClassHelper;
-import gnu.java.lang.CPStringBuilder;
-
-import gnu.java.lang.reflect.FieldSignatureParser;
-
-/**
- * The Field class represents a member variable of a class. It also allows
- * dynamic access to a member, via reflection. This works for both
- * static and instance fields. Operations on Field objects know how to
- * do widening conversions, but throw {@link IllegalArgumentException} if
- * a narrowing conversion would be necessary. You can query for information
- * on this Field regardless of location, but get and set access may be limited
- * by Java language access controls. If you can't do it in the compiler, you
- * can't normally do it here either.<p>
- *
- * <B>Note:</B> This class returns and accepts types as Classes, even
- * primitive types; there are Class types defined that represent each
- * different primitive type.  They are <code>java.lang.Boolean.TYPE,
- * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
- * byte.class</code>, etc.  These are not to be confused with the
- * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
- * real classes.<p>
- *
- * Also note that this is not a serializable class.  It is entirely feasible
- * to make it serializable using the Externalizable interface, but this is
- * on Sun, not me.
- *
- * @author John Keiser
- * @author Eric Blake <ebb9@email.byu.edu>
- * @see Member
- * @see Class
- * @see Class#getField(String)
- * @see Class#getDeclaredField(String)
- * @see Class#getFields()
- * @see Class#getDeclaredFields()
- * @since 1.1
- * @status updated to 1.4
- */
-public final class Field
-extends AccessibleObject implements Member
-{
-  private Class declaringClass;
-  private String name;
-  private int slot;
-
-  private static final int FIELD_MODIFIERS
-    = Modifier.FINAL | Modifier.PRIVATE | Modifier.PROTECTED
-      | Modifier.PUBLIC | Modifier.STATIC | Modifier.TRANSIENT
-      | Modifier.VOLATILE;
-
-  /**
-   * This class is uninstantiable except natively.
-   */
-  private Field(Class declaringClass, String name, int slot)
-  {
-    this.declaringClass = declaringClass;
-    this.name = name;
-    this.slot = slot;
-  }
-
-  /**
-   * Gets the class that declared this field, or the class where this field
-   * is a non-inherited member.
-   * @return the class that declared this member
-   */
-  public Class<?> getDeclaringClass()
-  {
-    return declaringClass;
-  }
-
-  /**
-   * Gets the name of this field.
-   * @return the name of this field
-   */
-  public String getName()
-  {
-    return name;
-  }
-
-  /**
-   * Return the raw modifiers for this field.
-   * @return the field's modifiers
-   */
-  private native int getModifiersInternal();
-
-  /**
-   * Gets the modifiers this field uses.  Use the <code>Modifier</code>
-   * class to interpret the values.  A field can only have a subset of the
-   * following modifiers: public, private, protected, static, final,
-   * transient, and volatile.
-   *
-   * @return an integer representing the modifiers to this Member
-   * @see Modifier
-   */
-  public int getModifiers()
-  {
-    return getModifiersInternal() & FIELD_MODIFIERS;
-  }
-
-  /**
-   * Return true if this field is synthetic, false otherwise.
-   * @since 1.5
-   */
-  public boolean isSynthetic()
-  {
-    return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;
-  }
-
-  /**
-   * Return true if this field represents an enum constant,
-   * false otherwise.
-   * @since 1.5
-   */
-  public boolean isEnumConstant()
-  {
-    return (getModifiersInternal() & Modifier.ENUM) != 0;
-  }
-
-  /**
-   * Gets the type of this field.
-   * @return the type of this field
-   */
-  public native Class<?> getType();
-
-  /**
-   * Compare two objects to see if they are semantically equivalent.
-   * Two Fields are semantically equivalent if they have the same declaring
-   * class, name, and type. Since you can't creat a Field except through
-   * the VM, this is just the == relation.
-   *
-   * @param o the object to compare to
-   * @return <code>true</code> if they are equal; <code>false</code> if not
-   */
-  public boolean equals(Object o)
-  {
-    if (!(o instanceof Field))
-      return false;
-    Field that = (Field)o; 
-    if (this.getDeclaringClass() != that.getDeclaringClass())
-      return false;
-    if (!this.getName().equals(that.getName()))
-      return false;
-    if (this.getType() != that.getType())
-      return false;
-    return true;
-  }
-
-  /**
-   * Get the hash code for the Field. The Field hash code is the hash code
-   * of its name XOR'd with the hash code of its class name.
-   *
-   * @return the hash code for the object.
-   */
-  public int hashCode()
-  {
-    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
-  }
-
-  /**
-   * Get a String representation of the Field. A Field's String
-   * representation is "&lt;modifiers&gt; &lt;type&gt;
-   * &lt;class&gt;.&lt;fieldname&gt;".<br> Example:
-   * <code>public transient boolean gnu.parse.Parser.parseComplete</code>
-   *
-   * @return the String representation of the Field
-   */
-  public String toString()
-  {
-    // 64 is a reasonable buffer initial size for field
-    CPStringBuilder sb = new CPStringBuilder(64);
-    Modifier.toString(getModifiers(), sb).append(' ');
-    sb.append(ClassHelper.getUserName(getType())).append(' ');
-    sb.append(getDeclaringClass().getName()).append('.');
-    sb.append(getName());
-    return sb.toString();
-  }
-
-  public String toGenericString()
-  {
-    CPStringBuilder sb = new CPStringBuilder(64);
-    Modifier.toString(getModifiers(), sb).append(' ');
-    sb.append(getGenericType()).append(' ');
-    sb.append(getDeclaringClass().getName()).append('.');
-    sb.append(getName());
-    return sb.toString();
-  }
-
-  /**
-   * Get the value of this Field.  If it is primitive, it will be wrapped
-   * in the appropriate wrapper type (boolean = java.lang.Boolean).<p>
-   *
-   * If the field is static, <code>o</code> will be ignored. Otherwise, if
-   * <code>o</code> is null, you get a <code>NullPointerException</code>,
-   * and if it is incompatible with the declaring class of the field, you
-   * get an <code>IllegalArgumentException</code>.<p>
-   *
-   * Next, if this Field enforces access control, your runtime context is
-   * evaluated, and you may have an <code>IllegalAccessException</code> if
-   * you could not access this field in similar compiled code. If the field
-   * is static, and its class is uninitialized, you trigger class
-   * initialization, which may end in a
-   * <code>ExceptionInInitializerError</code>.<p>
-   *
-   * Finally, the field is accessed, and primitives are wrapped (but not
-   * necessarily in new objects). This method accesses the field of the
-   * declaring class, even if the instance passed in belongs to a subclass
-   * which declares another field to hide this one.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if <code>o</code> is not an instance of
-   *         the class or interface declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #getBoolean(Object)
-   * @see #getByte(Object)
-   * @see #getChar(Object)
-   * @see #getShort(Object)
-   * @see #getInt(Object)
-   * @see #getLong(Object)
-   * @see #getFloat(Object)
-   * @see #getDouble(Object)
-   */
-  public native Object get(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this boolean Field. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a boolean field of
-   *         <code>o</code>, or if <code>o</code> is not an instance of the
-   *         declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native boolean getBoolean(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this byte Field. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte field of
-   *         <code>o</code>, or if <code>o</code> is not an instance of the
-   *         declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native byte getByte(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this Field as a char. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a char field of
-   *         <code>o</code>, or if <code>o</code> is not an instance
-   *         of the declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native char getChar(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this Field as a short. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte or short
-   *         field of <code>o</code>, or if <code>o</code> is not an instance
-   *         of the declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native short getShort(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this Field as an int. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte, short, char, or
-   *         int field of <code>o</code>, or if <code>o</code> is not an
-   *         instance of the declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native int getInt(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this Field as a long. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte, short, char, int,
-   *         or long field of <code>o</code>, or if <code>o</code> is not an
-   *         instance of the declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native long getLong(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this Field as a float. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte, short, char, int,
-   *         long, or float field of <code>o</code>, or if <code>o</code> is
-   *         not an instance of the declaring class of this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native float getFloat(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Get the value of this Field as a double. If the field is static,
-   * <code>o</code> will be ignored.
-   *
-   * @param o the object to get the value of this Field from
-   * @return the value of the Field
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte, short, char, int,
-   *         long, float, or double field of <code>o</code>, or if
-   *         <code>o</code> is not an instance of the declaring class of this
-   *         field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #get(Object)
-   */
-  public native double getDouble(Object o)
-    throws IllegalAccessException;
-
-  /**
-   * Set the value of this Field.  If it is a primitive field, the value
-   * will be unwrapped from the passed object (boolean = java.lang.Boolean).<p>
-   *
-   * If the field is static, <code>o</code> will be ignored. Otherwise, if
-   * <code>o</code> is null, you get a <code>NullPointerException</code>,
-   * and if it is incompatible with the declaring class of the field, you
-   * get an <code>IllegalArgumentException</code>.<p>
-   *
-   * Next, if this Field enforces access control, your runtime context is
-   * evaluated, and you may have an <code>IllegalAccessException</code> if
-   * you could not access this field in similar compiled code. This also
-   * occurs whether or not there is access control if the field is final.
-   * If the field is primitive, and unwrapping your argument fails, you will
-   * get an <code>IllegalArgumentException</code>; likewise, this error
-   * happens if <code>value</code> cannot be cast to the correct object type.
-   * If the field is static, and its class is uninitialized, you trigger class
-   * initialization, which may end in a
-   * <code>ExceptionInInitializerError</code>.<p>
-   *
-   * Finally, the field is set with the widened value. This method accesses
-   * the field of the declaring class, even if the instance passed in belongs
-   * to a subclass which declares another field to hide this one.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if <code>value</code> cannot be
-   *         converted by a widening conversion to the underlying type of
-   *         the Field, or if <code>o</code> is not an instance of the class
-   *         declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #setBoolean(Object, boolean)
-   * @see #setByte(Object, byte)
-   * @see #setChar(Object, char)
-   * @see #setShort(Object, short)
-   * @see #setInt(Object, int)
-   * @see #setLong(Object, long)
-   * @see #setFloat(Object, float)
-   * @see #setDouble(Object, double)
-   */
-  public native void set(Object o, Object value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this boolean Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a boolean field, or if
-   *         <code>o</code> is not an instance of the class declaring this
-   *         field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setBoolean(Object o, boolean value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this byte Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a byte, short, int, long,
-   *         float, or double field, or if <code>o</code> is not an instance
-   *         of the class declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setByte(Object o, byte value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this char Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a char, int, long,
-   *         float, or double field, or if <code>o</code> is not an instance
-   *         of the class declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setChar(Object o, char value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this short Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a short, int, long,
-   *         float, or double field, or if <code>o</code> is not an instance
-   *         of the class declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setShort(Object o, short value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this int Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not an int, long, float, or
-   *         double field, or if <code>o</code> is not an instance of the
-   *         class declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setInt(Object o, int value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this long Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a long, float, or double
-   *         field, or if <code>o</code> is not an instance of the class
-   *         declaring this field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setLong(Object o, long value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this float Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a float or long field, or
-   *         if <code>o</code> is not an instance of the class declaring this
-   *         field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setFloat(Object o, float value)
-    throws IllegalAccessException;
-
-  /**
-   * Set this double Field. If the field is static, <code>o</code> will be
-   * ignored.
-   *
-   * @param o the object to set this Field on
-   * @param value the value to set this Field to
-   * @throws IllegalAccessException if you could not normally access this field
-   *         (i.e. it is not public)
-   * @throws IllegalArgumentException if this is not a double field, or if
-   *         <code>o</code> is not an instance of the class declaring this
-   *         field
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static field triggered
-   *         class initialization, which then failed
-   * @see #set(Object, Object)
-   */
-  public native void setDouble(Object o, double value)
-    throws IllegalAccessException;
-
-  /**
-   * Return the generic type of the field. If the field type is not a generic
-   * type, the method returns the same as <code>getType()</code>.
-   *
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public Type getGenericType()
-  {
-    String signature = getSignature();
-    if (signature == null)
-      return getType();
-    FieldSignatureParser p = new FieldSignatureParser(getDeclaringClass(),
-                                                      signature);
-    return p.getFieldType();
-  }
-
-  /**
-   * Return the String in the Signature attribute for this field. If there
-   * is no Signature attribute, return null.
-   */
-  private native String getSignature();
-}
Index: vm/reference/java/lang/reflect/Method.java
===================================================================
RCS file: vm/reference/java/lang/reflect/Method.java
diff -N vm/reference/java/lang/reflect/Method.java
--- vm/reference/java/lang/reflect/Method.java	1 Mar 2008 10:13:33 -0000	1.25
+++ /dev/null	1 Jan 1970 00:00:00 -0000
@@ -1,490 +0,0 @@
-/* java.lang.reflect.Method - reflection of Java methods
-   Copyright (C) 1998, 2001, 2002, 2005, 2007, 2008 Free Software Foundation, Inc.
-
-This file is part of GNU Classpath.
-
-GNU Classpath is free software; you can redistribute it and/or modify
-it under the terms of the GNU General Public License as published by
-the Free Software Foundation; either version 2, or (at your option)
-any later version.
- 
-GNU Classpath is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with GNU Classpath; see the file COPYING.  If not, write to the
-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301 USA.
-
-Linking this library statically or dynamically with other modules is
-making a combined work based on this library.  Thus, the terms and
-conditions of the GNU General Public License cover the whole
-combination.
-
-As a special exception, the copyright holders of this library give you
-permission to link this library with independent modules to produce an
-executable, regardless of the license terms of these independent
-modules, and to copy and distribute the resulting executable under
-terms of your choice, provided that you also meet, for each linked
-independent module, the terms and conditions of the license of that
-module.  An independent module is a module which is not derived from
-or based on this library.  If you modify this library, you may extend
-this exception to your version of the library, but you are not
-obligated to do so.  If you do not wish to do so, delete this
-exception statement from your version. */
-
-
-package java.lang.reflect;
-
-import gnu.java.lang.ClassHelper;
-import gnu.java.lang.CPStringBuilder;
-
-import gnu.java.lang.reflect.MethodSignatureParser;
-
-import java.lang.annotation.Annotation;
-import java.util.Arrays;
-
-/**
- * The Method class represents a member method of a class. It also allows
- * dynamic invocation, via reflection. This works for both static and
- * instance methods. Invocation on Method objects knows how to do
- * widening conversions, but throws {@link IllegalArgumentException} if
- * a narrowing conversion would be necessary. You can query for information
- * on this Method regardless of location, but invocation access may be limited
- * by Java language access controls. If you can't do it in the compiler, you
- * can't normally do it here either.<p>
- *
- * <B>Note:</B> This class returns and accepts types as Classes, even
- * primitive types; there are Class types defined that represent each
- * different primitive type.  They are <code>java.lang.Boolean.TYPE,
- * java.lang.Byte.TYPE,</code>, also available as <code>boolean.class,
- * byte.class</code>, etc.  These are not to be confused with the
- * classes <code>java.lang.Boolean, java.lang.Byte</code>, etc., which are
- * real classes.<p>
- *
- * Also note that this is not a serializable class.  It is entirely feasible
- * to make it serializable using the Externalizable interface, but this is
- * on Sun, not me.
- *
- * @author John Keiser
- * @author Eric Blake <ebb9@email.byu.edu>
- * @see Member
- * @see Class
- * @see java.lang.Class#getMethod(String,Class[])
- * @see java.lang.Class#getDeclaredMethod(String,Class[])
- * @see java.lang.Class#getMethods()
- * @see java.lang.Class#getDeclaredMethods()
- * @since 1.1
- * @status updated to 1.4
- */
-public final class Method
-extends AccessibleObject implements Member, GenericDeclaration
-{
-  Class declaringClass;
-  String name;
-  int slot;
-
-  private static final int METHOD_MODIFIERS
-    = Modifier.ABSTRACT | Modifier.FINAL | Modifier.NATIVE
-      | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.PUBLIC
-      | Modifier.STATIC | Modifier.STRICT | Modifier.SYNCHRONIZED;
-
-  /**
-   * This class is uninstantiable.
-   */
-  private Method(Class declaringClass, String name, int slot)
-  {
-    this.declaringClass = declaringClass;
-    this.name = name;
-    this.slot = slot;
-  }
-
-  /**
-   * Gets the class that declared this method, or the class where this method
-   * is a non-inherited member.
-   * @return the class that declared this member
-   */
-  public Class<?> getDeclaringClass()
-  {
-    return declaringClass;
-  }
-
-  /**
-   * Gets the name of this method.
-   * @return the name of this method
-   */
-  public String getName()
-  {
-    return name;
-  }
-
-  /**
-   * Return the raw modifiers for this method.
-   * @return the method's modifiers
-   */
-  private native int getModifiersInternal();
-
-  /**
-   * Gets the modifiers this method uses.  Use the <code>Modifier</code>
-   * class to interpret the values.  A method can only have a subset of the
-   * following modifiers: public, private, protected, abstract, static,
-   * final, synchronized, native, and strictfp.
-   *
-   * @return an integer representing the modifiers to this Member
-   * @see Modifier
-   */
-  public int getModifiers()
-  {
-    return getModifiersInternal() & METHOD_MODIFIERS;
-  }
-
-  /**
-   * Return true if this method is a bridge method.  A bridge method
-   * is generated by the compiler in some situations involving
-   * generics and inheritance.
-   * @since 1.5
-   */
-  public boolean isBridge()
-  {
-    return (getModifiersInternal() & Modifier.BRIDGE) != 0;
-  }
-
-  /**
-   * Return true if this method is synthetic, false otherwise.
-   * @since 1.5
-   */
-  public boolean isSynthetic()
-  {
-    return (getModifiersInternal() & Modifier.SYNTHETIC) != 0;
-  }
-
-  /**
-   * Return true if this is a varargs method, that is if
-   * the method takes a variable number of arguments.
-   * @since 1.5
-   */
-  public boolean isVarArgs()
-  {
-    return (getModifiersInternal() & Modifier.VARARGS) != 0;
-  }
-
-  /**
-   * Gets the return type of this method.
-   * @return the type of this method
-   */
-  public native Class<?> getReturnType();
-
-  /**
-   * Get the parameter list for this method, in declaration order. If the
-   * method takes no parameters, returns a 0-length array (not null).
-   *
-   * @return a list of the types of the method's parameters
-   */
-  public native Class<?>[] getParameterTypes();
-
-  /**
-   * Get the exception types this method says it throws, in no particular
-   * order. If the method has no throws clause, returns a 0-length array
-   * (not null).
-   *
-   * @return a list of the types in the method's throws clause
-   */
-  public native Class<?>[] getExceptionTypes();
-
-  /**
-   * Compare two objects to see if they are semantically equivalent.
-   * Two Methods are semantically equivalent if they have the same declaring
-   * class, name, parameter list, and return type.
-   *
-   * @param o the object to compare to
-   * @return <code>true</code> if they are equal; <code>false</code> if not
-   */
-  public boolean equals(Object o)
-  {
-      // Implementation note:
-      // The following is a correct but possibly slow implementation.
-      //
-      // This class has a private field 'slot' that could be used by
-      // the VM implementation to "link" a particular method to a Class.
-      // In that case equals could be simply implemented as:
-      //
-      // if (o instanceof Method)
-      // {
-      //    Method m = (Method)o;
-      //    return m.declaringClass == this.declaringClass
-      //           && m.slot == this.slot;
-      // }
-      // return false;
-      //
-      // If a VM uses the Method class as their native/internal representation
-      // then just using the following would be optimal:
-      //
-      // return this == o;
-      //
-    if (!(o instanceof Method))
-      return false;
-    Method that = (Method)o;
-    if (this.getDeclaringClass() != that.getDeclaringClass())
-      return false;
-    if (!this.getName().equals(that.getName()))
-      return false;
-    if (this.getReturnType() != that.getReturnType())
-      return false;
-    if (!Arrays.equals(this.getParameterTypes(), that.getParameterTypes()))
-      return false;
-    return true;
-  }
-
-  /**
-   * Get the hash code for the Method. The Method hash code is the hash code
-   * of its name XOR'd with the hash code of its class name.
-   *
-   * @return the hash code for the object
-   */
-  public int hashCode()
-  {
-    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
-  }
-
-  /**
-   * Get a String representation of the Method. A Method's String
-   * representation is "&lt;modifiers&gt; &lt;returntype&gt;
-   * &lt;methodname&gt;(&lt;paramtypes&gt;) throws &lt;exceptions&gt;", where
-   * everything after ')' is omitted if there are no exceptions.<br> Example:
-   * <code>public static int run(java.lang.Runnable,int)</code>
-   *
-   * @return the String representation of the Method
-   */
-  public String toString()
-  {
-    // 128 is a reasonable buffer initial size for constructor
-    CPStringBuilder sb = new CPStringBuilder(128);
-    Modifier.toString(getModifiers(), sb).append(' ');
-    sb.append(ClassHelper.getUserName(getReturnType())).append(' ');
-    sb.append(getDeclaringClass().getName()).append('.');
-    sb.append(getName()).append('(');
-    Class[] c = getParameterTypes();
-    if (c.length > 0)
-      {
-        sb.append(ClassHelper.getUserName(c[0]));
-        for (int i = 1; i < c.length; i++)
-          sb.append(',').append(ClassHelper.getUserName(c[i]));
-      }
-    sb.append(')');
-    c = getExceptionTypes();
-    if (c.length > 0)
-      {
-        sb.append(" throws ").append(c[0].getName());
-        for (int i = 1; i < c.length; i++)
-          sb.append(',').append(c[i].getName());
-      }
-    return sb.toString();
-  }
-
-  public String toGenericString()
-  {
-    // 128 is a reasonable buffer initial size for constructor
-    CPStringBuilder sb = new CPStringBuilder(128);
-    Modifier.toString(getModifiers(), sb).append(' ');
-    Constructor.addTypeParameters(sb, getTypeParameters());
-    sb.append(getGenericReturnType()).append(' ');
-    sb.append(getDeclaringClass().getName()).append('.');
-    sb.append(getName()).append('(');
-    Type[] types = getGenericParameterTypes();
-    if (types.length > 0)
-      {
-        sb.append(types[0]);
-        for (int i = 1; i < types.length; i++)
-          sb.append(',').append(types[i]);
-      }
-    sb.append(')');
-    types = getGenericExceptionTypes();
-    if (types.length > 0)
-      {
-        sb.append(" throws ").append(types[0]);
-        for (int i = 1; i < types.length; i++)
-          sb.append(',').append(types[i]);
-      }
-    return sb.toString();
-  }
-
-  /**
-   * Invoke the method. Arguments are automatically unwrapped and widened,
-   * and the result is automatically wrapped, if needed.<p>
-   *
-   * If the method is static, <code>o</code> will be ignored. Otherwise,
-   * the method uses dynamic lookup as described in JLS 15.12.4.4. You cannot
-   * mimic the behavior of nonvirtual lookup (as in super.foo()). This means
-   * you will get a <code>NullPointerException</code> if <code>o</code> is
-   * null, and an <code>IllegalArgumentException</code> if it is incompatible
-   * with the declaring class of the method. If the method takes 0 arguments,
-   * you may use null or a 0-length array for <code>args</code>.<p>
-   *
-   * Next, if this Method enforces access control, your runtime context is
-   * evaluated, and you may have an <code>IllegalAccessException</code> if
-   * you could not acces this method in similar compiled code. If the method
-   * is static, and its class is uninitialized, you trigger class
-   * initialization, which may end in a
-   * <code>ExceptionInInitializerError</code>.<p>
-   *
-   * Finally, the method is invoked. If it completes normally, the return value
-   * will be null for a void method, a wrapped object for a primitive return
-   * method, or the actual return of an Object method. If it completes
-   * abruptly, the exception is wrapped in an
-   * <code>InvocationTargetException</code>.
-   *
-   * @param o the object to invoke the method on
-   * @param args the arguments to the method
-   * @return the return value of the method, wrapped in the appropriate
-   *         wrapper if it is primitive
-   * @throws IllegalAccessException if the method could not normally be called
-   *         by the Java code (i.e. it is not public)
-   * @throws IllegalArgumentException if the number of arguments is incorrect;
-   *         if the arguments types are wrong even with a widening conversion;
-   *         or if <code>o</code> is not an instance of the class or interface
-   *         declaring this method
-   * @throws InvocationTargetException if the method throws an exception
-   * @throws NullPointerException if <code>o</code> is null and this field
-   *         requires an instance
-   * @throws ExceptionInInitializerError if accessing a static method triggered
-   *         class initialization, which then failed
-   */
-  public Object invoke(Object o, Object... args)
-    throws IllegalAccessException, InvocationTargetException
-  {
-    return invokeNative(o, args, declaringClass, slot);
-  }
-
-  /*
-   * NATIVE HELPERS
-   */
-
-  private native Object invokeNative(Object o, Object[] args,
-                                     Class declaringClass, int slot)
-    throws IllegalAccessException, InvocationTargetException;
-
-  /**
-   * Returns an array of <code>TypeVariable</code> objects that represents
-   * the type variables declared by this constructor, in declaration order.
-   * An array of size zero is returned if this class has no type
-   * variables.
-   *
-   * @return the type variables associated with this class. 
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public TypeVariable<Method>[] getTypeParameters()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return new TypeVariable[0];
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getTypeParameters();
-  }
-
-  /**
-   * Return the String in the Signature attribute for this method. If there
-   * is no Signature attribute, return null.
-   */
-  private native String getSignature();
-
-  /**
-   * Returns an array of <code>Type</code> objects that represents
-   * the exception types declared by this method, in declaration order.
-   * An array of size zero is returned if this method declares no
-   * exceptions.
-   *
-   * @return the exception types declared by this method. 
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public Type[] getGenericExceptionTypes()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return getExceptionTypes();
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getGenericExceptionTypes();
-  }
-
-  /**
-   * Returns an array of <code>Type</code> objects that represents
-   * the parameter list for this method, in declaration order.
-   * An array of size zero is returned if this method takes no
-   * parameters.
-   *
-   * @return a list of the types of the method's parameters
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public Type[] getGenericParameterTypes()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return getParameterTypes();
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getGenericParameterTypes();
-  }
-
-  /**
-   * Returns the return type of this method.
-   *
-   * @return the return type of this method
-   * @throws GenericSignatureFormatError if the generic signature does
-   *         not conform to the format specified in the Virtual Machine
-   *         specification, version 3.
-   * @since 1.5
-   */
-  public Type getGenericReturnType()
-  {
-    String sig = getSignature();
-    if (sig == null)
-      return getReturnType();
-    MethodSignatureParser p = new MethodSignatureParser(this, sig);
-    return p.getGenericReturnType();
-  }
-
-  /**
-   * If this method is an annotation method, returns the default
-   * value for the method.  If there is no default value, or if the
-   * method is not a member of an annotation type, returns null.
-   * Primitive types are wrapped.
-   *
-   * @throws TypeNotPresentException if the method returns a Class,
-   * and the class cannot be found
-   *
-   * @since 1.5
-   */
-  public native Object getDefaultValue();
-
-  /**
-   * <p>
-   * Return an array of arrays representing the annotations on each
-   * of the method's parameters.  The outer array is aligned against
-   * the parameters of the method and is thus equal in length to
-   * the number of parameters (thus having a length zero if there are none).
-   * Each array element in the outer array contains an inner array which
-   * holds the annotations.  This array has a length of zero if the parameter
-   * has no annotations.
-   * </p>
-   * <p>
-   * The returned annotations are serialized.  Changing the annotations has
-   * no affect on the return value of future calls to this method.
-   * </p>
-   * 
-   * @return an array of arrays which represents the annotations used on the
-   *         parameters of this method.  The order of the array elements
-   *         matches the declaration order of the parameters.
-   * @since 1.5
-   */
-  public native Annotation[][] getParameterAnnotations();
-
-}
Index: vm/reference/java/lang/reflect/VMConstructor.java
===================================================================
RCS file: vm/reference/java/lang/reflect/VMConstructor.java
diff -N vm/reference/java/lang/reflect/VMConstructor.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vm/reference/java/lang/reflect/VMConstructor.java	2 Mar 2008 02:03:58 -0000
@@ -0,0 +1,107 @@
+/* java.lang.reflect.VMConstructor - VM interface for reflection of Java constructors
+   Copyright (C) 1998, 2001, 2004, 2005 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package java.lang.reflect;
+
+import java.lang.annotation.Annotation;
+
+final class VMConstructor
+{
+  /**
+   * Return the raw modifiers for this constructor.  In particular
+   * this will include the synthetic and varargs bits.
+   * @param c the constructor concerned.
+   * @return the constructor's modifiers
+   */
+  static native int getModifiersInternal(Constructor c);
+
+  /**
+   * Get the parameter list for this constructor, in declaration order. If the
+   * constructor takes no parameters, returns a 0-length array (not null).
+   *
+   * @param c the constructor concerned.
+   * @return a list of the types of the constructor's parameters
+   */
+  static native Class[] getParameterTypes(Constructor c);
+
+  /**
+   * Get the exception types this constructor says it throws, in no particular
+   * order. If the constructor has no throws clause, returns a 0-length array
+   * (not null).
+   *
+   * @param c the constructor concerned.
+   * @return a list of the types in the constructor's throws clause
+   */
+  static native Class[] getExceptionTypes(Constructor c);
+
+  static native Object constructNative(Object[] args, Class declaringClass,
+				       int slot)
+    throws InstantiationException, IllegalAccessException,
+    InvocationTargetException;
+
+  /**
+   * Return the String in the Signature attribute for this constructor. If there
+   * is no Signature attribute, return null.
+   * @param c the constructor concerned.
+   */
+  static native String getSignature(Constructor c);
+  
+  /**
+   * <p>
+   * Return an array of arrays representing the annotations on each
+   * of the constructor's parameters.  The outer array is aligned against
+   * the parameters of the constructors and is thus equal in length to
+   * the number of parameters (thus having a length zero if there are none).
+   * Each array element in the outer array contains an inner array which
+   * holds the annotations.  This array has a length of zero if the parameter
+   * has no annotations.
+   * </p>
+   * <p>
+   * The returned annotations are serialized.  Changing the annotations has
+   * no affect on the return value of future calls to this method.
+   * </p>
+   * 
+   * @param c the constructor concerned.
+   * @return an array of arrays which represents the annotations used on the
+   *         parameters of this constructor.  The order of the array elements
+   *         matches the declaration order of the parameters.
+   * @since 1.5
+   */
+  static native Annotation[][] getParameterAnnotations(Constructor c);
+
+}
Index: vm/reference/java/lang/reflect/VMField.java
===================================================================
RCS file: vm/reference/java/lang/reflect/VMField.java
diff -N vm/reference/java/lang/reflect/VMField.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vm/reference/java/lang/reflect/VMField.java	2 Mar 2008 02:03:58 -0000
@@ -0,0 +1,495 @@
+/* java.lang.reflect.Field - VM interface for reflection of Java fields
+   Copyright (C) 1998, 2001, 2005, 2008 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package java.lang.reflect;
+
+final class VMField
+{
+
+  /**
+   * Return the raw modifiers for this field.
+   * @param f the field concerned.
+   * @return the field's modifiers
+   */
+  static native int getModifiersInternal(Field f);
+
+  /**
+   * Gets the type of this field.
+   * @param f the field concerned.
+   * @return the type of this field
+   */
+  static native Class getType(Field f);
+
+  /**
+   * Get the value of this Field.  If it is primitive, it will be wrapped
+   * in the appropriate wrapper type (boolean = java.lang.Boolean).<p>
+   *
+   * If the field is static, <code>o</code> will be ignored. Otherwise, if
+   * <code>o</code> is null, you get a <code>NullPointerException</code>,
+   * and if it is incompatible with the declaring class of the field, you
+   * get an <code>IllegalArgumentException</code>.<p>
+   *
+   * Next, if this Field enforces access control, your runtime context is
+   * evaluated, and you may have an <code>IllegalAccessException</code> if
+   * you could not access this field in similar compiled code. If the field
+   * is static, and its class is uninitialized, you trigger class
+   * initialization, which may end in a
+   * <code>ExceptionInInitializerError</code>.<p>
+   *
+   * Finally, the field is accessed, and primitives are wrapped (but not
+   * necessarily in new objects). This method accesses the field of the
+   * declaring class, even if the instance passed in belongs to a subclass
+   * which declares another field to hide this one.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if <code>o</code> is not an instance of
+   *         the class or interface declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #getBoolean(Object)
+   * @see #getByte(Object)
+   * @see #getChar(Object)
+   * @see #getShort(Object)
+   * @see #getInt(Object)
+   * @see #getLong(Object)
+   * @see #getFloat(Object)
+   * @see #getDouble(Object)
+   */
+  static native Object get(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this boolean Field. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a boolean field of
+   *         <code>o</code>, or if <code>o</code> is not an instance of the
+   *         declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native boolean getBoolean(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this byte Field. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte field of
+   *         <code>o</code>, or if <code>o</code> is not an instance of the
+   *         declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native byte getByte(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this Field as a char. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a char field of
+   *         <code>o</code>, or if <code>o</code> is not an instance
+   *         of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native char getChar(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this Field as a short. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte or short
+   *         field of <code>o</code>, or if <code>o</code> is not an instance
+   *         of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native short getShort(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this Field as an int. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, or
+   *         int field of <code>o</code>, or if <code>o</code> is not an
+   *         instance of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native int getInt(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this Field as a long. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, int,
+   *         or long field of <code>o</code>, or if <code>o</code> is not an
+   *         instance of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native long getLong(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this Field as a float. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, int,
+   *         long, or float field of <code>o</code>, or if <code>o</code> is
+   *         not an instance of the declaring class of this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native float getFloat(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Get the value of this Field as a double. If the field is static,
+   * <code>o</code> will be ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to get the value of this Field from
+   * @return the value of the Field
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, char, int,
+   *         long, float, or double field of <code>o</code>, or if
+   *         <code>o</code> is not an instance of the declaring class of this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #get(Object)
+   */
+  static native double getDouble(Field f, Object o)
+    throws IllegalAccessException;
+
+  /**
+   * Set the value of this Field.  If it is a primitive field, the value
+   * will be unwrapped from the passed object (boolean = java.lang.Boolean).<p>
+   *
+   * If the field is static, <code>o</code> will be ignored. Otherwise, if
+   * <code>o</code> is null, you get a <code>NullPointerException</code>,
+   * and if it is incompatible with the declaring class of the field, you
+   * get an <code>IllegalArgumentException</code>.<p>
+   *
+   * Next, if this Field enforces access control, your runtime context is
+   * evaluated, and you may have an <code>IllegalAccessException</code> if
+   * you could not access this field in similar compiled code. This also
+   * occurs whether or not there is access control if the field is final.
+   * If the field is primitive, and unwrapping your argument fails, you will
+   * get an <code>IllegalArgumentException</code>; likewise, this error
+   * happens if <code>value</code> cannot be cast to the correct object type.
+   * If the field is static, and its class is uninitialized, you trigger class
+   * initialization, which may end in a
+   * <code>ExceptionInInitializerError</code>.<p>
+   *
+   * Finally, the field is set with the widened value. This method accesses
+   * the field of the declaring class, even if the instance passed in belongs
+   * to a subclass which declares another field to hide this one.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if <code>value</code> cannot be
+   *         converted by a widening conversion to the underlying type of
+   *         the Field, or if <code>o</code> is not an instance of the class
+   *         declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #setBoolean(Object, boolean)
+   * @see #setByte(Object, byte)
+   * @see #setChar(Object, char)
+   * @see #setShort(Object, short)
+   * @see #setInt(Object, int)
+   * @see #setLong(Object, long)
+   * @see #setFloat(Object, float)
+   * @see #setDouble(Object, double)
+   */
+  static native void set(Field f, Object o, Object value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this boolean Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a boolean field, or if
+   *         <code>o</code> is not an instance of the class declaring this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setBoolean(Field f, Object o, boolean value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this byte Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a byte, short, int, long,
+   *         float, or double field, or if <code>o</code> is not an instance
+   *         of the class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setByte(Field f, Object o, byte value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this char Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a char, int, long,
+   *         float, or double field, or if <code>o</code> is not an instance
+   *         of the class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setChar(Field f, Object o, char value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this short Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a short, int, long,
+   *         float, or double field, or if <code>o</code> is not an instance
+   *         of the class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setShort(Field f, Object o, short value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this int Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not an int, long, float, or
+   *         double field, or if <code>o</code> is not an instance of the
+   *         class declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setInt(Field f, Object o, int value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this long Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a long, float, or double
+   *         field, or if <code>o</code> is not an instance of the class
+   *         declaring this field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setLong(Field f, Object o, long value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this float Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a float or long field, or
+   *         if <code>o</code> is not an instance of the class declaring this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setFloat(Field f, Object o, float value)
+    throws IllegalAccessException;
+
+  /**
+   * Set this double Field. If the field is static, <code>o</code> will be
+   * ignored.
+   *
+   * @param f the field concerned.
+   * @param o the object to set this Field on
+   * @param value the value to set this Field to
+   * @throws IllegalAccessException if you could not normally access this field
+   *         (i.e. it is not public)
+   * @throws IllegalArgumentException if this is not a double field, or if
+   *         <code>o</code> is not an instance of the class declaring this
+   *         field
+   * @throws NullPointerException if <code>o</code> is null and this field
+   *         requires an instance
+   * @throws ExceptionInInitializerError if accessing a static field triggered
+   *         class initialization, which then failed
+   * @see #set(Object, Object)
+   */
+  static native void setDouble(Field f, Object o, double value)
+    throws IllegalAccessException;
+
+  /**
+   * Return the String in the Signature attribute for this field. If there
+   * is no Signature attribute, return null.
+   *
+   * @param f the field concerned.
+   */
+  static native String getSignature(Field f);
+
+}
Index: vm/reference/java/lang/reflect/VMMethod.java
===================================================================
RCS file: vm/reference/java/lang/reflect/VMMethod.java
diff -N vm/reference/java/lang/reflect/VMMethod.java
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ vm/reference/java/lang/reflect/VMMethod.java	2 Mar 2008 02:03:58 -0000
@@ -0,0 +1,127 @@
+/* java.lang.reflect.VMMethod - VM interface for reflection of Java methods
+   Copyright (C) 1998, 2001, 2002, 2005, 2007, 2008 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+ 
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package java.lang.reflect;
+
+import java.lang.annotation.Annotation;
+
+final class VMMethod
+{
+  /**
+   * Return the raw modifiers for this method.
+   * @param m the method concerned.
+   * @return the method's modifiers
+   */
+  static native int getModifiersInternal(Method m);
+
+  /**
+   * Gets the return type of this method.
+   * @param m the method concerned.
+   * @return the type of this method
+   */
+  static native Class getReturnType(Method m);
+
+  /**
+   * Get the parameter list for this method, in declaration order. If the
+   * method takes no parameters, returns a 0-length array (not null).
+   *
+   * @param m the method concerned.
+   * @return a list of the types of the method's parameters
+   */
+  static native Class[] getParameterTypes(Method m);
+
+  /**
+   * Get the exception types this method says it throws, in no particular
+   * order. If the method has no throws clause, returns a 0-length array
+   * (not null).
+   *
+   * @param m the method concerned.
+   * @return a list of the types in the method's throws clause
+   */
+  static native Class[] getExceptionTypes(Method m);
+
+  static native Object invokeNative(Object o, Object[] args,
+				    Class declaringClass, int slot)
+    throws IllegalAccessException, InvocationTargetException;
+
+  /**
+   * Return the String in the Signature attribute for this method. If there
+   * is no Signature attribute, return null.
+   * @param m the method concerned.
+   */
+  static native String getSignature(Method m);
+
+  /**
+   * If this method is an annotation method, returns the default
+   * value for the method.  If there is no default value, or if the
+   * method is not a member of an annotation type, returns null.
+   * Primitive types are wrapped.
+   *
+   * @param m the method concerned.
+   * @throws TypeNotPresentException if the method returns a Class,
+   * and the class cannot be found
+   *
+   * @since 1.5
+   */
+  static native Object getDefaultValue(Method m);
+
+  /**
+   * <p>
+   * Return an array of arrays representing the annotations on each
+   * of the method's parameters.  The outer array is aligned against
+   * the parameters of the method and is thus equal in length to
+   * the number of parameters (thus having a length zero if there are none).
+   * Each array element in the outer array contains an inner array which
+   * holds the annotations.  This array has a length of zero if the parameter
+   * has no annotations.
+   * </p>
+   * <p>
+   * The returned annotations are serialized.  Changing the annotations has
+   * no affect on the return value of future calls to this method.
+   * </p>
+   * 
+   * @param m the method concerned.
+   * @return an array of arrays which represents the annotations used on the
+   *         parameters of this method.  The order of the array elements
+   *         matches the declaration order of the parameters.
+   * @since 1.5
+   */
+  static native Annotation[][] getParameterAnnotations(Method m);
+
+}
+
