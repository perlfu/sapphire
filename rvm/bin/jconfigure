#! /bin/bash
#
# (C) Copyright IBM Corp. 2001, 2003
#
#$Id$
#
# Generate control files necessary to build a particular "configuration"
# of the Research Virtual Machine.
#
# See the usage message below for much more information than we could
# possibly put in here.
#
# This script is organized into seven sections:
#    0 - Setup
#    1 - Documentation
#    2 - Definitions of constants
#    3 - Process RVM_TARGET_CONFIG
#    4 - ARGUMENT PARSING
#    5 - Definitions of functions
#    6 - Mainline Code that does the work
#
# @author Derek Lieber
# @date   19 Jan 2000
# @author Steven Augart (Bash version)
# @date 17 May 2003

#----------------------#
# SECTION 0 - Setup    #
#----------------------#

# What is our name?
# Bash internal shorthand that works like the "basename" command.
ME="${0##*/}"

# Where are we?
# Bash internal shorthand that works like the "dirname" command.
mydir="${0%/*}"			# temporary; directory we were run from

if [[ $mydir && $mydir != $ME ]]; then
    # Where to find auxiliary programs:
    bin_dir="${mydir}"
else
    bin_dir="${RVM_ROOT:?$ME: You must set the RVM_ROOT variable before you run this program.}/rvm/bin"
fi

# Stop immediately if any programs we call return errors.
#
trap 'echo >&2 "$ME: some command we just ran (probably with a final argument of \"$_\") exited with status $?.  I give up; aborting execution."' ERR
trap 'echo >&2 "$ME: We just exited due to an error."' EXIT
set -e;

## Complain
function croak_nousage () {
    # Display the error message.  If it's a multi-line error message, indent
    # the second and subsequent lines by a few spaces.
    echo "${ME}: $*" | sed -e '2,$s/^/     /' >&2
    trap '' EXIT
    exit 1
}

sanity_env="${bin_dir}/sanity-envars.bash"
[[ -f $sanity_env ]] || croak_nonusage "Internal error: Cannot find the file sanity-envars.bash ($sanity_env); something is badly broken."
[[ -r $sanity_env ]] || croak_nonusage "Internal error: Cannot read the file sanity-envars.bash ($sanity_env); something is badly broken.  You might check the file permissions or user id you used to extract Jikes RVM."
. "${sanity_env}";		# Defines checkenv()

## Place where source files reside.
checkenv RVM_ROOT

## Place where RVM bootimage, booter, and runtime support files will be placed.
checkenv RVM_BUILD
## What configuration will host the build process?
checkenv RVM_HOST_CONFIG
## What configuration will run the system?
checkenv RVM_TARGET_CONFIG

#---------------------------#
# SECTION 1 - DOCUMENTATION #
#---------------------------#

function help_message () {

  # If PAGER is not set, set it to "more".
   ${PAGER=more} <<- EOF
	Usage: ${ME} [-quiet] [-D <variable>=<value>]... <configuration-name>
	Usage: ${ME} -help

	This script generates control files necessary to build a particular
	"configuration" of the Research Virtual Machine.
	
	Normally it is invoked as:
	
	   $ME <configuration-name>
	
	Where <configuration-name> indicates the configuration to be
	created and an environment variable, \$RVM_BUILD, specifies a
	directory where files comprising the configuration are to be
	placed.
	
	You can invoke this script as "${ME} < /dev/null" in order to
	suppress interactive questions.

	This script creates the \$RVM_BUILD directory and populates it with
	a skeleton directory structure along with some scripts and control
	files.

	After running this script, you can build an RVM executable by typing:
	
	    cd \$RVM_BUILD
	    ./jbuild
	
	Your \$RVM_ROOT tree will be template-expanded, macro-processed,
	compiled, and linked into a bootimage.  The processed sources,
	class files, bootimage, and booter will be placed into the
	\$RVM_BUILD directory.
	
	To execute the resulting bootimage (from any directory), type:
	
	   rvm <vm-flags> classname <application-args>
	
	Later, if you make changes to your \$RVM_ROOT tree, type "jbuild"
	again.  Modified source files will be discovered, copied to the
	build directory, recompiled, and the bootimage will be rebuilt.
	
	Special Cases
	=============
	
	To avoid unnecessarily rebuilding the bootimage (when, for example,
	you've only modified classes that are dynamically loaded and which
	are not part of the bootimage) type "jbuild -nolink".
	
	To avoid building the booter (when, for example, running on the AIX
	side of an AIX/Linux cross-compilation) type "jbuild -nobooter".
	
	To build only the booter (when, for example, running on Linux side
	of a cross-port to Linux) type "jbuild -booter".
	
	To force recompilation of all classes (when, for example, you've
	modified a global constant or have added/removed fields/methods
	from a class) type "jbuild -recompile".
	
	To monitor the build process in more detail type "jbuild -trace".
	
	To restore the build directory to its original "unbuilt" state type
	"jbuild -clean".
	
	EOF
}
   
#--------------------------------------#
# SECTION 2 - DEFINITIONS OF CONSTANTS #
#--------------------------------------#


# The places to put scripts and control files. 

# (The *_STR variants of these variables have their variables expanded
# when the emitted script is executed, rather than being expanded prior to
# emitting the script.  This gives the scripts a degree of location
# transparency.  The _STR1 variables are similar to the _STR variables, 
# but are used to produce the localization script.  They lack the '$' )

BUILD_DIRECTORY="$RVM_BUILD"
BUILD_DIRECTORY_STR1="JAL_BUILD"
BUILD_DIRECTORY_STR="\$$BUILD_DIRECTORY_STR1"

ROOT_DIRECTORY="$RVM_ROOT"
ROOT_DIRECTORY_STR1="JAL_ROOT"
ROOT_DIRECTORY_STR="\$$ROOT_DIRECTORY_STR1"

# source path for configuration files 
# eg, BaseBaseSemispace
#
CONFIGURATION_FILE_SOURCE="$ROOT_DIRECTORY/rvm/config/build"

# Place to remember what configuration we've built.
#
CONFIGURATION_SUMMARY="$BUILD_DIRECTORY/RVM.configuration"

# Place to keep list of source directories to be scanned by preprocessor.
#
SOURCE_LIST="$BUILD_DIRECTORY/RVM.sources"
SOURCE_LIST_STR="$BUILD_DIRECTORY_STR/RVM.sources"

# Place to remember, if a cleansing pass should precede the build.
#
CLEANSE_STATUS="${BUILD_DIRECTORY}/RVM.cleanseRequired"
CLEANSE_STATUS_STR="${BUILD_DIRECTORY_STR}/RVM.cleanseRequired"

# Place to remember if preprocessor has yielded new/modified source files.
#
CLASSES_INVALID="${BUILD_DIRECTORY}/RVM.classesInvalid"
CLASSES_INVALID_STR="${BUILD_DIRECTORY_STR}/RVM.classesInvalid"

# Place to put preprocessed .java files and compiled .class files.
#
CLASSES_DIRECTORY="${BUILD_DIRECTORY}/RVM.classes"
CLASSES_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.classes"

# Place to put source files that are machine generated.
#
GENERATED_FILES_DIRECTORY="${BUILD_DIRECTORY}/RVM.generatedSources"
GENERATED_FILES_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.generatedSources"
   
# Place to put compiled versions of build tools and other glop
# generated during the build process.
#
SCRATCH_DIRECTORY="${BUILD_DIRECTORY}/RVM.scratch"
SCRATCH_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.scratch"

# Place to put the debugger, and other such tools.
#
TOOL_DIRECTORY="${BUILD_DIRECTORY}/RVM.tools"
TOOL_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.tools"

# Place to keep list of classes comprising the bootimage.
#
PRIMORDIAL_CLASSES="${BUILD_DIRECTORY}/RVM.primordials"
PRIMORDIAL_CLASSES_STR="${BUILD_DIRECTORY_STR}/RVM.primordials"

# Place to keep list of .class files to be excluded from bootimage.
#
EXCLUDED_CLASSES="${BUILD_DIRECTORY}/RVM.exclusions"
EXCLUDED_CLASSES_STR="${BUILD_DIRECTORY_STR}/RVM.exclusions"

# Place to put bootimage.
#
BOOTIMAGE="${BUILD_DIRECTORY}/RVM.image"
BOOTIMAGE_STR="${BUILD_DIRECTORY_STR}/RVM.image"

# Place to put bootimage map.
#
BOOTIMAGE_MAP=${BUILD_DIRECTORY}/RVM.map
BOOTIMAGE_MAP_STR=${BUILD_DIRECTORY_STR}/RVM.map

# Place to put booter.
#
BOOTER=${BUILD_DIRECTORY}/JikesRVM
BOOTER_STR=${BUILD_DIRECTORY_STR}/JikesRVM

# Variables to allow configuration files to alter the list of
# directories, primordials, exclusions and top level sources.
#
CONF_SPECIFIC_SOURCES_LIST=""
CONF_SPECIFIC_PRIMORDIALS_LIST=""
CONF_SPECIFIC_EXCLUSIONS_LIST=""
CONF_SPECIFIC_TOP_LEVEL_SOURCES=""

# Strings to use in the scripts as the locations of various commands.
#
HOST_JIKES_STR1="HOST_JIKES"
HOST_JIKES_STR="\$$HOST_JIKES_STR1"
HOST_JAVA_STR1="HOST_JAVA_RT"
HOST_JAVA_STR="\$$HOST_JAVA_STR1"
HOST_JAVA_HOME_STR1="HOST_JAVA_HOME"
HOST_JAVA_HOME="\$$HOST_JAVA_HOME_STR1"
HOST_JAVADOC_STR1="HOST_JAVADOC"
HOST_JAVADOC_STR="\$$HOST_JAVADOC_STR1"
HOST_JAR_STR1="HOST_JAR"
HOST_JAR_STR="\$$HOST_JAR_STR1"
HOST_REPOSITORIES_STR1="HOST_JAVA_REPOSITORIES"
HOST_REPOSITORIES_STR="\$$HOST_REPOSITORIES_STR1"
HOST_TOOLS_STR1="HOST_JAVA_TOOLS"
HOST_TOOLS_STR="\$$HOST_TOOLS_STR1"
GNU_MAKE_STR1="GNU_MAKE"
GNU_MAKE_STR="\$$GNU_MAKE_STR1"
HOST_CC_STR1="CC"
HOST_CC_STR="\$$HOST_CC_STR1"
HOST_CPP_STR1="CPP"
HOST_CPP_STR="\$$HOST_CPP_STR1"
HOST_CPLUS_STR1="CPLUS"
HOST_CPLUS_STR="\$$HOST_CPLUS_STR1"
HOST_SHLD_STR1="HOST_SHLD"
HOST_SHLD_STR="\$$HOST_SHLD_STR1"

# Generate map of bootimage?
#
declare -x -i GENERATE_MAP=1

# Current version of RVM
JIKESRVM_VERSION="Jikes Research VM for Java 2.2.2"

# Default values for RunBootImage constants.
# Reasonable default values.
# To change the defaults for a paricular configuration, 
# redefine appropriate environment variables in the configuration's stanza.
#
DEFAULT_HEAP_SIZE=20	# in megabytes

# Here are the choices for target architecture.
#
declare -i RVM_FOR_POWERPC=0  # does not imply aix
declare -i RVM_FOR_IA32=0     # also implies linux

# Here are the choices for target operating system.
#
declare -i RVM_FOR_AIX=0	   # also implies ppc
declare -i RVM_FOR_LINUX=0	   # 

# 32-bit or 64-bit address size
#
declare -i RVM_FOR_32_ADDR=0
declare -i RVM_FOR_64_ADDR=0
 
# Here are the choices for compiler components and extensions.
# Note: baseline compiler is always built into bootimage: its presence is not controlled by any flags.
#
declare -i RVM_WITH_OPT_COMPILER=0
declare -i RVM_WITH_ADAPTIVE_SYSTEM=0 # superset of opt
declare -i RVM_WITH_OPT_TEST_HARNESS=0  # superset of opt, for test/debug via OptTestHarness class

# Include support for hardware performance monitors (HPM)
declare -i RVM_WITH_HPM=0

declare -x -i RVM_WITH_NON_BLOCKING_FDS_FOR_CLASSPATH=0

# Here are the choices for compiler to generate code for classes that are loaded into bootimage.
#
declare -i RVM_WITH_BASE_BOOTIMAGE_COMPILER=0
declare -i RVM_WITH_OPT_BOOTIMAGE_COMPILER=0

# Here are the choices for compiler to generate code for classes that are loaded at runtime.
#
declare -i RVM_WITH_BASE_RUNTIME_COMPILER=0
declare -i RVM_WITH_OPT_RUNTIME_COMPILER=0
declare -i RVM_WITH_ADAPTIVE_RUNTIME_SYSTEM=0

# Here are the choices for the object model
#
declare -i RVM_WITH_DEFAULT_OBJECT_MODEL=1
declare -i RVM_WITH_ONE_WORD_MASK_OBJECT_MODEL=0
declare -i RVM_WITH_ONE_WORD_PTR_OBJECT_MODEL=0
declare -i RVM_WITH_ONE_WORD_INDEX_OBJECT_MODEL=0

# Here are the choices for additional components that are under development and/or are excluded from default build.
#
declare -i RVM_FOR_SINGLE_VIRTUAL_PROCESSOR=0   # use pThread library to access multiple CPU's (or not)
declare -i RVM_WITH_DETERMINISTIC_THREAD_SWITCHING=0 # thread switch after n method calls, don't use interrupts to drive preemption
declare -i RVM_WITHOUT_PREEMPTIVE_THREAD_SWITCHING=0 # thread switch only at explicit yield and wait calls
declare -i RVM_WITH_ALL_CLASSES=0   # include all vm classes in bootimage, not just those needed for startup
declare -i RVM_WITHOUT_ASSERTIONS=0 # exclude runtime assertion checks
declare -i RVM_WITH_EXTREME_ASSERTIONS=0 # include extra assertion checking 
declare -i RVM_WITHOUT_AOS_LOG=0    # turn off AOS logging
declare -i RVM_WITH_NATIVE_DAEMON_PROCESSOR=0

#
# intercept blocking system calls (currently Linux-only)
#
declare -x -i RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS=0

# The following flags tweak the memory model used by the optimizing compiler
# to constrain optimization
declare -i RVM_WITH_NOFLUSH=0	 # omit sync/isync in all cases

# controls for diagnostic flags
declare -i RVM_FOR_STRESSGC=0

# using on stack replacement 
declare -i RVM_WITH_OSR=0

#---------------------------------------#
# SECTION 3 - PROCESS RVM_TARGET_CONFIG # 
#---------------------------------------#
# One use of the target_config file is to define
# directives that hold for all configurations 
# defined on the target. By sourcing it here,
# we define such directives for all configs on the target,
# but still allow them to be overridden on the command line
# or in a build-config file.
. "${RVM_TARGET_CONFIG}"


#--------------------------------------#
# SECTION 4 - ARGUMENT PARSING         #
#--------------------------------------#

while ((1)); do
    case "$1" in 
	"-help" ) 
	    help_message;
	    trap '' EXIT
	    exit 0; ;;
	"-D" )
 	    shift
	    eval "export $1";;
	
	"-quiet" ) 
	    quiet=1;;

	"" ) break;;

	* ) CONFIGURATION_NAME="$1";;
    esac

    shift
done


function croak () {
    # Display the error message.  If it's a multi-line error message, indent
    # the second and subsequent lines by a few spaces.
    echo "${ME}: $*" | sed -e '2,$s/^/     /' >&2
    echo >&2 "${ME}: Type \"${ME} -help\" for usage information."
    trap '' EXIT
    exit 1
}

[[ "${CONFIGURATION_NAME}" ]] || croak "Please specify <configuration-name>"

if [[ -f "${CONFIGURATION_FILE_SOURCE}/${CONFIGURATION_NAME}" ]]; then
    . "${CONFIGURATION_FILE_SOURCE}/${CONFIGURATION_NAME}" "${CONFIGURATION_FILE_SOURCE}"
else
    croak "Unknown configuration ${CONFIGURATION_NAME}"
fi

# set the relative path to the object model.
if (( RVM_WITH_ONE_WORD_MASK_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordMaskTIB
elif (( RVM_WITH_ONE_WORD_PTR_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordTIBPtr
elif (( RVM_WITH_ONE_WORD_INDEX_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordIndexTIB
else
    OBJECT_MODEL_PATH_STR=objectModel/default
fi


if (( RVM_FOR_AIX || RVM_FOR_SINGLE_VIRTUAL_PROCESSOR == 1 )); then
    RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS=1
fi

# Convert configuration choices into preprocessor definitions.
#    RVM_FOR_xxx  --> -DRVM_FOR_xxx
#    RVM_ON_xxx --> -DRVM_ON_xxx
#    RVM_WITH_xxx --> -DRVM_WITH_xxx
#
PREPROCESSOR_DEFINITIONS="-DBOOTIMAGE_LOAD_ADDRESS=${BOOTIMAGE_LOAD_ADDRESS}"
PREPROCESSOR_DEFINITIONS="${PREPROCESSOR_DEFINITIONS} -DMAXIMUM_MAPPABLE_ADDRESS=${MAXIMUM_MAPPABLE_ADDRESS}"
PREPROCESSOR_DEFINITIONS="${PREPROCESSOR_DEFINITIONS} $(env     \
      | sed -n  -e 's/^RVM_ON_/-DRVM_ON_/p'		\
		-e 's/^RVM_FOR_/-DRVM_FOR_/p'		\
		-e 's/^RVM_WITH_/-DRVM_WITH_/p'		\
		-e 's/RVM_WITHOUT_/-DRVM_WITHOUT_/p')"

# Place where bootimage runner lives.
#
if (( RVM_FOR_POWERPC )); then
   BOOTIMAGE_RUNNER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner"
   BOOTIMAGE_RUNNER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner"
   BOOTIMAGE_RUNNER_SUBDIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner/powerPC"
   BOOTIMAGE_RUNNER_SUBDIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner/powerPC"
elif (( RVM_FOR_IA32 )); then
   BOOTIMAGE_RUNNER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner"
   BOOTIMAGE_RUNNER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner"
   BOOTIMAGE_RUNNER_SUBDIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner/IA32"
   BOOTIMAGE_RUNNER_SUBDIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner/IA32"
else
   BOOTIMAGE_RUNNER_DIR="UNKNOWN_BOOTIMAGE_RUNNER_DIRECTORY"
   BOOTIMAGE_RUNNER_DIR_STR="UNKNOWN_BOOTIMAGE_RUNNER_DIRECTORY"
fi

# Place where bootimage writer lives.
#
BOOTIMAGE_WRITER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageWriter"
BOOTIMAGE_WRITER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageWriter"

#--------------------------------------#
# SECTION 5 - DEFINITIONS OF FUNCTIONS #
#--------------------------------------#

# Check configuration options for sanity.
function checkConfigurationOptions {
    if (( ! RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )) \
	&& (( RVM_WITH_NATIVE_DAEMON_PROCESSOR ))
    then
	croak_nousage "\
If RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS is not specified,\
then RVM_WITH_NATIVE_DAEMON_PROCESSOR must not be specified";
    fi
}

# Emit list of source tree directories whose java files comprise the current configuration.
#
function emitSourceList () {
    if (( RVM_FOR_POWERPC )); then
	ARCH_DIR="powerPC"
    elif (( RVM_FOR_IA32 )); then
	ARCH_DIR="intel"
    else
	ARCH_DIR="UNSPECIFIED_ARCHITECTURE"
    fi
   
    # Common components.
    #
    echo $RVM_ROOT/rvm/src/vm
    echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR
    echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/runtime
    echo $RVM_ROOT/rvm/src/vm/classLoader
    echo $RVM_ROOT/rvm/src/vm/jni
    echo $RVM_ROOT/rvm/src/vm/runtime
    echo $RVM_ROOT/rvm/src/vm/scheduler
    echo $RVM_ROOT/rvm/src/vm/profiler                #!!TEMP kludge to resolve VM_EventLogger references
    echo $RVM_ROOT/rvm/src/vm/utility
    echo $RVM_ROOT/rvm/src/vm/verifier
    echo $RVM_ROOT/rvm/src/vm/compilers/compiledCode
    

    echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/jni

    # Baseline compiler components (always part of bootimage).
    #
    echo ${RVM_ROOT}/rvm/src/vm/compilers/baseline           # architecture independent
    echo ${RVM_ROOT}/rvm/src/vm/compilers/baseline/GCMap     # architecture independent
    echo ${RVM_ROOT}/rvm/src/vm/compilers/baseline/profiling # architecture independent
    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/baseline    # architecture dependent
    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/baseline/GCMap
    if [[ -e ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/assembler ]]; then
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/assembler # architecture dependent
    fi
    
    echo ${RVM_ROOT}/rvm/src/vm/objectModel
    echo ${RVM_ROOT}/rvm/src/vm/objectModel/lockNursery
    echo ${RVM_ROOT}/rvm/src/vm/${OBJECT_MODEL_PATH_STR}

    # other components
    #
    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/disassembler

    # Optimizing compiler components.
    #
    if (( RVM_WITH_OPT_COMPILER )); then
        # core components
        #
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/driver
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/instrumentation
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/cfg
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/bc2hir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/hir2lir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/lir2mir
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/mir2mc
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/gcmap
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/instruction
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/instruction/operand
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/util
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/control
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/control/dominators
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/coalesce
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/liveness
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/liveRangeSplitting
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/simpleSSA
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/simpleSSA/escape
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/abcd
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/builder
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/codePlacement
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/expressionFolding
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/gvn
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/loadElimination
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/redundantBranchElimination
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/storeElimination
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/inlining
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/specialization
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/summaries
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local/depGraph
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local/instructionScheduler
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/regalloc/linearScan
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/regalloc/util
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/dataflowUtil
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/exception
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis/vcg
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis/dot
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/list
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/dotgraph
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/set
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/classLoader
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/classLoader/jikesrvm
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/services
	echo ${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface

	# architecture-specific components
	#
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/instruction
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/instruction/operand
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/conversions/lir2mir
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/conversions/mir2mc
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/regalloc
	echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/vmInterface/services
    fi

    # Adaptive compiler components.
    #
    if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/controller
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/recompilation
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/listeners
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/organizers
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/database
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/database/methodSamples
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/database/callGraph
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/recompilation/instrumentation
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/instrumentation
	echo ${RVM_ROOT}/rvm/src/vm/adaptive/utility
    fi

   # On stack replacement components.
   #
   if (( RVM_WITH_OSR )); then
     echo $RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/executionState
     echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/optCompilationWithOsr
     echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/specialCompilation
     echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/util
     echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/executionState
     echo $RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/threadControls
   fi

   # architecture specific writebarrier support for baseline compilers
   #
   echo "$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/compilers/baseline/writeBarrier"

    # Bootimage compiler components.
    #
    if (( ${RVM_WITH_BASE_BOOTIMAGE_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/bootImage/baseline
    elif (( ${RVM_WITH_OPT_BOOTIMAGE_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/bootImage/optimizing
    fi

    # Runtime compiler components.
    #
    echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/runtime
    if (( ${RVM_WITH_BASE_RUNTIME_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/runtime/baseline
    elif (( ${RVM_WITH_OPT_RUNTIME_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/runtime/optimizing
    elif (( ${RVM_WITH_ADAPTIVE_RUNTIME_SYSTEM} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/runtime/adaptive
    fi

   # Common memory manager components.
   #
   echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk
   echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/vmInterface
   echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/header
   echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan
   echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/policy
   echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/utility
   # collector specific classes
   #
   if (( $RVM_WITH_SEMI_SPACE )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/semiSpace
   elif (( $RVM_WITH_MARK_SWEEP )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/markSweep
   elif (( $RVM_WITH_GEN_COPY )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genCopy
   elif (( $RVM_WITH_GEN_MS )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genMS
   elif (( $RVM_WITH_COPY_MS )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/copyMS
   elif (( $RVM_WITH_REF_COUNT )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/refCount
   elif (( $RVM_WITH_NO_GC )); then
       echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/noGC
   fi

   # standard library support
   #
   echo $RVM_ROOT/rvm/src/vm/libSupport
   echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang
   echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang/ref
   echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang/reflect
   echo $RVM_ROOT/rvm/src/vm/libSupport/java/net
   echo $RVM_ROOT/rvm/src/vm/libSupport/java/io

   # Add support for hardware performance monitors on PowerPC
   #
   if (( $RVM_WITH_HPM )); then
      echo $RVM_ROOT/rvm/src/vm/adaptive/runtimeMeasurements/hardwarePerformanceMonitors
   fi

   # Add the configuration specific directories
   #
   for dir in $CONF_SPECIFIC_SOURCES_LIST; do
     echo $RVM_ROOT/$dir
   done
}




function emitBoilerplate () {
    cat <<- 'EOF'
	# What is our name?
	# Bash internal shorthand that works like the "basename" command.

	ME="${0##*/}"
	. ${RVM_BUILD-.}/enable_exit_on_error
EOF
}

function emit_disable_exit_on_error () {
    cat << 'EOF'
	# disable_exit_on_error.  This has to be a source'd file; the ERR 
	# trap is not inherited by shell functions.  Too Bad.
	trap - ERR
	set +e
EOF
}

function emit_enable_exit_on_error () {
    cat << 'EOF'
	# enable_exit_on_error.  This has to be a source'd file; the ERR 
	# trap is not inherited by shell functions.  Too Bad.
	trap 'echo >&2 "$ME: A command I just ran (probably with a final argument of "$_")
	   exited with status $?.  Something is broken; I give up."' ERR
	set -e
EOF
}



# Emit script which sets all shell variables relative to the
# shadow and build directory
function emitEnvironmentBash () {
   # read the target environment file
   #
   echo '#! /bin/bash'
   echo '# Note: the above #! /bin/bash is there merely as documentation.'
   echo '# This file will not be run as a program directly, but rather sourced'
   echo '# by other routines.'
   echo ''
   echo '# Set the enviroment.'
   echo ""
   echo "# This file is generated by jconfigure from the configuration file"
   echo "# RVM_HOST_CONFIG ($RVM_HOST_CONFIG).  "
   echo "# You may edit this file, but"
   echo "# all your changes will be lost if jconfigure is executed again using"
   echo "# the current directory ($RVM_BUILD) as RVM_BUILD."
   echo ""
   echo "# This file was generated from the configuration file:"
   echo "#      $CURRENT_CONFIG_FILE"

   echo ""
   echo "export $BUILD_DIRECTORY_STR1=$RVM_BUILD"
   echo "export $ROOT_DIRECTORY_STR1=$RVM_ROOT"
   echo ""
   echo "export $HOST_JIKES_STR1=\"$JIKES\""
   echo "export $HOST_JAVA_STR1=\"$HOST_JAVA\""
   echo "export $HOST_JAVA_HOME_STR1=\"$HOST_JAVA_HOME\""
   echo "export $HOST_JAVADOC_STR1=\"$HOST_JAVADOC\""
   echo "export $HOST_JAR_STR1=\"$HOST_JAR\""
   echo "export $HOST_REPOSITORIES_STR1=$HOST_REPOSITORIES"
   echo "export $HOST_TOOLS_STR1=$HOST_TOOLS"
   echo "export LD_LIBRARY_PATH=\"\$LD_LIBRARY_PATH:$HOST_JAVA_LD_LIBRARY_PATH\""
   echo ""
   echo "export $GNU_MAKE_STR1=$GNU_MAKE"
   echo ""
   echo "export $HOST_CC_STR1='$CC'"
   echo "export $HOST_CPLUS_STR1='$CPLUS'"
   echo "export $HOST_CPP_STR1='$CPP'"
   echo "export $HOST_SHLD_STR1='$LDSHARED'"
   echo ""
   echo "export AWK='$AWK'"  
   echo "export BASH='$BASH'"  
   echo "export CVS='$CVS'"  
   echo "export DIFF='$DIFF'"  
   echo "export FGREP='$FGREP'"
   echo "export FIND='$FIND'"
   echo "export GNU_TAR='$GNU_TAR'"  
   echo "export GREP='$GREP'"
   echo "export MD5SUM='$MD5SUM'"  
   echo "export PS='$PS'"  
   echo "export SED='$SED'"
   echo "export WGET='$WGET'"
   echo "export XARGS='$XARGS'"
   echo "export UNZIP_CMD='$UNZIP_CMD'"
   echo "export ANT_CMD='$ANT_CMD'"
   echo ""
   echo "export ECLIPSE_INSTALL_DIR='$ECLIPSE_INSTALL_DIR'"
   echo ""
   echo "export CLASSPATH_LIBRARIES=YES"
   if [[ x$CLASSPATH_ROOT != x ]]; then
     echo "export CLASSPATH_ROOT=$CLASSPATH_ROOT"
   fi
   echo ""
}

#
# Emit a script which sets all shell variables relative to the
# shadow and build directories.
function emitEnvironmentPerl {
   # read the target environment file
#
   echo '#!/bin/perl'
   echo '# Set the enviroment.'
   echo ""
   echo "# This file is generated by jconfigure from the configuration file"
   echo "# RVM_HOST_CONFIG ($RVM_HOST_CONFIG).  "
   echo "# You may edit this file, but"
   echo "# all your changes will be lost if jconfigure is executed again using"
   echo "# the current directory ($RVM_BUILD) as RVM_BUILD."
   echo ""
   echo "# This file was generated from the configuration file:"
   echo "#      $CURRENT_CONFIG_FILE"

   echo ""
   echo "\$ENV{$BUILD_DIRECTORY_STR1} = '$RVM_BUILD';"
   echo "\$ENV{$ROOT_DIRECTORY_STR1} = '$RVM_ROOT';"
   echo ""
   echo "\$ENV{HOST_JIKES_STR1} = '$JIKES';"
   echo "\$ENV{HOST_JAVA_STR1} = '$HOST_JAVA';"
   echo "\$ENV{HOST_JAVA_HOME_STR1} = '$HOST_JAVA_HOME';"
   echo "\$ENV{HOST_JAVADOC_STR1} = '$HOST_JAVADOC';"
   echo "\$ENV{HOST_JAR_STR1} = '$HOST_JAR';"
   echo "\$ENV{HOST_REPOSITORIES_STR1} = '$HOST_REPOSITORIES';"
   echo "\$ENV{HOST_TOOLS_STR1} = '$HOST_TOOLS';"
   echo ""
   echo "\$ENV{GNU_MAKE_STR1} = '$GNU_MAKE';"
   echo ""
   echo "\$ENV{HOST_CC_STR1} = '$CC';"
   echo "\$ENV{HOST_CPLUS_STR1} = '$CPLUS';"
   echo "\$ENV{HOST_CPP_STR1} = '$CPP';"
   echo "\$ENV{HOST_SHLD_STR1} = '$LDSHARED';"
   echo ""
   echo "\$ENV{WK} = '$AWK';"  
   echo "\$ENV{ASH} = '$BASH';"  
   echo "\$ENV{VS} = '$CVS';"  
   echo "\$ENV{IFF} = '$DIFF';"  
   echo "\$ENV{IND} = '$FIND';"
   echo "\$ENV{GREP} = '$FGREP';"
   echo "\$ENV{NU_TAR} = '$GNU_TAR';"  
   echo "\$ENV{REP} = '$GREP';"
   echo "\$ENV{D5SUM} = '$MD5SUM';"  
   echo "\$ENV{S} = '$PS';"  
   echo "\$ENV{ED} = '$SED';"
   echo "\$ENV{GET} = '$WGET';"
   echo "\$ENV{ARGS} = '$XARGS';"
   echo "\$ENV{NZIP_CMD} = '$UNZIP_CMD';"
   echo ""
   echo "\$ENV{LASSPATH_LIBRARIES} = 'YES';"
   echo ""
}


#
# Emit Makefile
# 
function emitMakefile () {

cat <<- EOF
	# environment specific make rules
	
	# This file is generated by jconfigure according to values specified
	# in the configuration file RVM_HOST_CONFIG.  You may edit this file, but
	# all your changes will be lost if jconfigure is executed again using
	# the current directory as RVM_BUILD.
	
	# This file was generated from the configuration file:
	#      ${CURRENT_CONFIG_FILE}

	$BUILD_DIRECTORY_STR1 = $RVM_BUILD
	$ROOT_DIRECTORY_STR1 = $RVM_ROOT
	
	$HOST_JIKES_STR1 = $JIKES
	
	HOST_JAVA_HOME = $HOST_JAVA_HOME
	HOST_JAVA = $HOST_JAVA
	HOST_JAVAC = $HOST_JAVAC
	HOST_JAVADOC = $HOST_JAVADOC
	HOST_JAR = $HOST_JAR
	HOST_REPOSITORIES = $HOST_REPOSITORIES
	HOST_TOOLS = $HOST_TOOLS
	
	TARGET_INSTRUCTION_TYPE = $INSTRUCTION_TYPE
	
	CC = $CC
	CPLUS = $CPLUS
	CXX = $CPLUS
	LDSHARED = $LDSHARED
	JNI_NATIVE_LIBS_LD = $JNI_NATIVE_LIBS_LD
	
	AWK= $AWK
	BASH = $BASH
	CVS = $CVS
	DIFF= $DIFF
	FGREP = $FGREP
	FIND = $FIND
	GNU_TAR = $GNU_TAR
	GREP = $GREP
	MD5SUM = $MD5SUM
	PS= $PS
	SED = $SED
	WGET = $WGET
	XARGS = $XARGS
	UNZIP_CMD = $UNZIP_CMD
	
	
	CLASSPATH_LIBRARIES = YES
	EOF
}


# Emit a script to run each phase of vm builder in turn.
#
function emitController () {
    cat <<- 'EOF'
	#!/bin/bash
	# Run all phases of vm builder.

	. ./boilerplate.bash

	# timeit() $1: The command to run
	#	   $2: That command's arguments.

	# The old (until 2003 June) KSH script displayed
	# seconds of precision to three decimal places.  The
	# SECONDS variable in my version of Bash only returns
	# integers.

	function timeit () {
	    # We can either do some modifications to the output
	    # format, and use TIMEFORMAT instead of SECONDS...
	    # TIMEFORMAT="%3lR"
	    # time "$@"		
	    # ...Or we can just deal.with integer seconds.  Since the SECONDS
	    # variable is cumulative, it is compatible with the way we used to
	    # do this.

	    # Disable exit-on-error; inside "timeit", we can get a better
	    # exit message than the default one.
	    . ${RVM_BUILD}/disable_exit_on_error
	    "$@"
	    local status=$?
	    . ${RVM_BUILD}/enable_exit_on_error
	    echo "$SECONDS s"
	    if [ $status != 0 ]; then
		echo >&2 "$ME: Trouble while running \"$*\" (exit status $status); aborting execution"
		exit $status;
	    fi
	    return $status;	# will always return 0
	}

	while [[ $# != 0 ]]; do
	    if [[ $1 = -trace ]]; then
	       TRACE_FLAG=-trace
	    elif [[ $1 = -demographics ]]; then
	       DEMOGRAPHICS_FLAG=-demographics
	    elif [[ $1 = -clean ]]; then
	       CLEAN_FLAG=-clean
	    elif [[ $1 = -recompile ]]; then
	       RECOMPILE_FLAG=-recompile
	    elif [[ $1 = -nolink ]]; then
	       NOLINK_FLAG=-nolink
	    elif [[ $1 = -nobooter ]]; then
	       NOBOOTER_FLAG=-nobooter
	    elif [[ $1 = -booter ]]; then
	       NOLINK_FLAG=-nolink
	       BOOTER_FLAG=-booter
	    else
	       echo >&2 "Usage: $ME [-trace] [-demographics] [-clean] [-recompile] [-nolink] [-nobooter] [-booter]"
	       exit 1
	    fi
	    shift
	done

	
	if [[ $BOOTER_FLAG = -booter ]]; then
	  . ./environment
	else
	  . ./jbuild.environment
	fi
	
	# Ensure that we have the right version of the class libraries
	$JAL_ROOT/rvm/bin/jBuildClasspathJar --check
	
	if [[ $CLEAN_FLAG = -clean ]]; then
EOF
    echo "    rm -rf $TOOL_DIRECTORY_STR"
    cat <<- 'EOF'
	    timeit ./jbuild.expand     $TRACE_FLAG -clean
	    timeit ./jbuild.copy       $TRACE_FLAG -clean
	    timeit ./jbuild.compile    $TRACE_FLAG -clean
	    timeit ./jbuild.linkImage  $TRACE_FLAG $DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter $TRACE_FLAG -clean
	    exit 0
	fi

	if [[ $RECOMPILE_FLAG = -recompile ]]; then
	    timeit ./jbuild.compile $TRACE_FLAG -clean
	fi

EOF
    echo "if [[ -e $CLEANSE_STATUS_STR ]]; then"
    echo "   rm -rf $TOOL_DIRECTORY_STR"
    cat <<- 'EOF'
	    timeit ./jbuild.expand     $TRACE_FLAG -clean
	    timeit ./jbuild.copy       $TRACE_FLAG -clean
	    timeit ./jbuild.compile    $TRACE_FLAG -clean
	    timeit ./jbuild.linkImage  $TRACE_FLAG $DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter $TRACE_FLAG -clean
EOF
    echo "    rm -f $CLEANSE_STATUS_STR"
    cat <<- 'EOF'
	elif [[ $NOLINK_FLAG != -nolink ]]; then
	    timeit ./jbuild.linkImage  $TRACE_FLAG $DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter $TRACE_FLAG -clean
	fi
#
# The script, jbuild.linkBooter, will optionally run
# a command specified by the user of jbuildLinkBooter
# in the enviroment variable RVM_BUILD_COPY.
# This variable could be set to rsh the linkBooter
# command on the target machine.
# The syntax of the test, while awkward,
# is needed to run on all implementation of ksh,
# including linux ksh.  Maria for Steve Blackburn
	if [[ $BOOTER_FLAG = -booter ]]; then
	    if [[ X"$RVM_BUILD_COPY" != X ]]; then
	        timeit $RVM_BUILD_COPY
	    else
	        timeit ./jbuild.linkBooter $TRACE_FLAG
	    fi
	else
	    timeit ./jbuild.expand     $TRACE_FLAG
	    timeit ./jbuild.copy       $TRACE_FLAG
	    timeit ./jbuild.compile    $TRACE_FLAG
	    if [[ $NOLINK_FLAG != -nolink ]]; then
	        timeit ./jbuild.linkImage  $TRACE_FLAG $DEMOGRAPHICS_FLAG
	        if [[ X"$RVM_BUILD_COPY" != X ]]; then
	            timeit $RVM_BUILD_COPY
	        elif [[ $NOBOOTER_FLAG != -nobooter ]]; then
	            timeit  ./jbuild.linkBooter $TRACE_FLAG
	        fi
	    fi
	fi
EOF
}


# echo >&2  "HERE I AM! emitExpander" # DBG
# Emit script to generate VM source tree Java files that derive from templates.
# Taken:    .template files in source tree
# Returned: .java files in ${GENERATED_FILES_DIRECTORY}
#
function emitExpander () {
    cat <<- 'EOF'
	#! /bin/bash
	# Generate VM sources that derive from templates.
	. ./boilerplate.bash
	. ./jbuild.environment


	SILENT_MAKE=--silent
	if [[ $1 = -trace ]]; then
	    SILENT_MAKE=
	    shift
	fi

	echo -n "${ME}: "

	if [[ $1 = -clean ]]; then
EOF
    cat <<- EOF
	    rm -rf ${SCRATCH_DIRECTORY_STR}
	    mkdir -p ${SCRATCH_DIRECTORY_STR}/com/ibm/JikesRVM
	    cd ${GENERATED_FILES_DIRECTORY_STR}
	    echo *.* | xargs rm -f
EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	cat <<-EOF
	    cd ${GENERATED_FILES_DIRECTORY_STR}/instructionFormats
	    echo *.* | xargs rm -f
EOF
    fi
    echo '
    echo -n "(templates cleaned) "
    exit 0
fi
   # Make the tools that we need to do template expansion
'
   echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/tools/templateExpander && ${GNU_MAKE_STR} \${SILENT_MAKE} tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR})"

   if (( RVM_WITH_OPT_COMPILER )); then
       echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/tools/jburg && ${GNU_MAKE_STR} \${SILENT_MAKE} tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR})\
"
   fi

   # build VM_Assembler on Intel
   if (( RVM_FOR_IA32 )); then
       echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/assembler; ${GNU_MAKE_STR} \${SILENT_MAKE} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR})"
       if (( RVM_WITH_OPT_COMPILER )); then
	 echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/compilers/optimizing/ir/conversions/mir2mc; ${GNU_MAKE_STR} \${SILENT_MAKE} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR})"
       fi
   fi

   # Do the expansion
   echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/classLoader && ${GNU_MAKE_STR} \${SILENT_MAKE} MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR})

(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/baseline && ${GNU_MAKE_STR} \${SILENT_MAKE} MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR})"

   if (( RVM_WITH_OPT_COMPILER )); then
      echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/optimizing && ${GNU_MAKE_STR} \${SILENT_MAKE} MakeTemplates ARCH_DIR=${ARCH_DIR} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR} IS_ADAPTIVE=${RVM_WITH_ADAPTIVE_SYSTEM})"
      if (( RVM_WITH_EXTREME_ASSERTIONS )); then
	  echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/optimizing/ir/instruction && ${GNU_MAKE_STR} \${SILENT_MAKE} fatalInstructionFormat ARCH_DIR=${ARCH_DIR} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR})"
      fi
   fi
   if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
       echo "\
(cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/adaptive && ${GNU_MAKE_STR} \${SILENT_MAKE} MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR} IS_ADAPTIVE=${RVM_WITH_ADAPTIVE_SYSTEM})"
   fi
   
   echo '
if [[ ${TRACE_FLAG} = -trace ]]; then
    echo ""
fi
';
}


# Emit script to copy/preprocess VM Java files from source tree to 
# build directory.
# Taken:    .java files in source tree
# Returned: .java files in build directory
#
# echo >&2  "HERE I AM! emitCopier" # DBG
function emitCopier () {
    cat <<- 'EOF'
	#! /bin/bash
	# Copy or preprocess VM Java files from the source tree to 
	# the build directory.
	# Taken:    .java files in the source tree
	# Returned: .java files in the build directory

	. ./boilerplate.bash
	. ./jbuild.environment
	

	if [[ $1 = -trace ]]; then
	    TRACE_FLAG=-trace
	    shift
	fi

	if [[ $1 = -clean ]]; then
	    echo -n "${ME}: "
EOF
    cat <<- EOF
	    cd ${CLASSES_DIRECTORY_STR}
	    find . -name "*.java" -exec rm {} \;
	    touch ${CLASSES_INVALID_STR}
	    echo -n "(sources cleaned) "
	    exit 0
	fi
EOF
   
    echo "
# Make the preprocessor
(cd ${ROOT_DIRECTORY_STR}/rvm/src/tools/preprocessor && ${GNU_MAKE_STR} \${SILENT_MAKE} tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR})
cp ${SCRATCH_DIRECTORY_STR}/preprocessModifiedFiles ${BUILD_DIRECTORY_STR}/jbuild.prep"
    echo '

# This may be reset in the loop below.
FILES_HAVE_CHANGED=0

# Update from directories containing sources that implement the virtual machine.
#
for d in $(<' ${SOURCE_LIST_STR} '); do
    if [[ ${TRACE_FLAG} = -trace ]]; then
        echo -n "${ME}: ${d}"
    fi
    shopt -s nullglob
    # FILES may be empty.
    FILES="$(echo ${d}/*.java)"
    . ${RVM_BUILD}/disable_exit_on_error
    '${BUILD_DIRECTORY_STR}'/jbuild.prep ${TRACE_FLAG}' ${PREPROCESSOR_DEFINITIONS} ${CLASSES_DIRECTORY_STR} '${FILES}
    status=$?
    . ${RVM_BUILD}/enable_exit_on_error
    if [[ ${status} = 1 ]]; then
       FILES_HAVE_CHANGED=1
    elif [[ ${status} != 0 ]]; then
       echo >&2 "$ME: Trouble while running jbuild.prep (exit status ${status}).
    Aborting execution."
       exit 1
    fi
    # set -e	# Original set -e location.
    if [[ ${TRACE_FLAG} = -trace ]]; then
      echo ""
    fi
done

# Update from directories containing machine generated source files
# Do this after we copy the "normal" files to allow us to
# overwrite any dummy versions of the files we have sitting
# around in the shadow (telling people that the file is generated).
if [[ ${TRACE_FLAG} = -trace ]]; then
    echo -n "${ME}: '${GENERATED_FILES_DIRECTORY_STR}'/"
fi
FILES=$(${FIND} '${GENERATED_FILES_DIRECTORY_STR}'/ -name "*.java")
. ${RVM_BUILD}/disable_exit_on_error
'${BUILD_DIRECTORY_STR}'/jbuild.prep ${TRACE_FLAG}' ${PREPROCESSOR_DEFINITIONS} ${CLASSES_DIRECTORY_STR}' ${FILES}
status=$?
. ${RVM_BUILD}/enable_exit_on_error
if [[ ${status} = 1 ]]; then
    FILES_HAVE_CHANGED=1
elif [[ ${status} != 0 ]]; then
    echo >&2 "$ME: Trouble while running jbuild.prep (exit status ${status}); aborting execution."
    exit 1
fi
if [[ ${TRACE_FLAG} = -trace ]]; then
      echo ""
fi'

    # copy classpath jar file
    if ! [ "$CLASSPATH_ROOT" ]; then
	CPS=$RVM_ROOT/classpath
    else
	CPS="${CLASSPATH_ROOT}"
    fi
    echo '
SYSTEM_TYPE=$('$CPS'/classpath/config.guess)
cp -f '$CPS'/$SYSTEM_TYPE/lib/glibj.zip '${CLASSES_DIRECTORY_STR}'/rvmrt.jar

echo -n "(classpath.jar copied) "

# Remember if any new (or modified) source files were discovered.
#
if [[ ${FILES_HAVE_CHANGED} = 1 ]]; then
    touch' ${CLASSES_INVALID_STR} '
fi'
}
   

# Emit script to generate VM class files from Java files.
# Taken:    .java files in build directory 
#           CLASSES_INVALID
# Returned: .class files in build directory
#
# echo >&2  "HERE I AM! emitCompiler" # DBG

function emitCompiler () {
    cat <<- 'EOF'
	#! /bin/bash
	# Generate VM class files from Java files.
	# Taken:    .java files in build directory 
	#           CLASSES_INVALID
	# Returned: .class files in build directory
	. ./boilerplate.bash
	. ./jbuild.environment


	if [[ $1 = -trace ]]; then
	    TRACE_FLAG=-trace
	    shift
	fi

	echo -n "${ME}: "
EOF
	echo '
if [[ $1 = -clean ]]; then
    cd' ${CLASSES_DIRECTORY_STR} '
    echo *.class | xargs rm -f
    touch' ${CLASSES_INVALID_STR} '
    echo -n "(classes cleaned) "
    exit 0
fi';
   # Generate classes
   #
   TOP_LEVEL_SOURCES="Dummy.java"
   if (( RVM_WITH_OPT_COMPILER )); then
      TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} OptDummy.java"
   fi
   if (( RVM_WITH_OPT_TEST_HARNESS )); then
      TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} OptDummy.java OptTestHarness.java"
   fi
   TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} ${CONF_SPECIFIC_TOP_LEVEL_SOURCES}"
   TOP_LEVEL_CLASSES="$(echo ${TOP_LEVEL_SOURCES}| sed 's@\.java@.class@g')"

   if (( RVM_FOR_POWERPC )); then
       INSTRUCTION_TYPE="int"
   elif (( RVM_FOR_IA32 )); then
       INSTRUCTION_TYPE="byte"
   else
       INSTRUCTION_TYPE="UNSPECIFED_INSTRUCTION_TYPE"
   fi
   
   ADDRESS_TYPE="int"

   echo "if [[ -e $CLASSES_INVALID_STR ]]; then"
   echo "   cd $CLASSES_DIRECTORY_STR"
   echo "   rm -f $TOP_LEVEL_CLASSES"
   echo "   $HOST_JIKES_STR -nowarn +F +Z +KINSTRUCTION=$INSTRUCTION_TYPE +KADDRESS=$ADDRESS_TYPE +E -g +U -classpath .:rvmrt.jar $TOP_LEVEL_SOURCES"
   echo '   echo -n "(classes compiled) "'
   echo ""
   echo "   rm -f jksvm.jar"
   echo "   $HOST_JAR_STR cvf0 jksvm.jar Dummy.class > /dev/null 2>&1"
   echo "   \$FIND . -name '*.class' | xargs $HOST_JAR_STR uvf0 jksvm.jar > /dev/null 2>&1"
   echo '   echo -n "(jksvm.jar built) "'
   echo ""
   echo "   rm -f jksvmsrc.jar"
   echo "   $HOST_JAR_STR cvf jksvmsrc.jar Dummy.java > /dev/null 2>&1"
   echo "   \$FIND . -name '*.java' | xargs $HOST_JAR_STR uvf jksvmsrc.jar > /dev/null 2>&1"
   echo '   echo -n "(jksvmsrc.jar built) "'
   echo ""
   echo 'else'
   echo '   if [[ $TRACE_FLAG = -trace ]]; then'
   echo '      echo -n "(nothing needed to be compiled) "'
   echo '   fi'
   echo 'fi'
   echo "rm -f $CLASSES_INVALID_STR"
   echo ''

   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '  echo ""'
   echo 'fi'
}

# echo >&2  "HERE I AM! emitImageLinker" # DBG
function emitImageLinker () {
cat <<- 'EOF'
	#! /bin/bash
	# Generate the VM bootimage.
	# Taken:    .class files in build directory
	# Returned: PRIMORDIAL_CLASSES and bootimage in build directory
	#           InterfaceDeclarations.h in bootImageRunner directory
	#
	. ./boilerplate.bash
	. ./jbuild.environment

   
	TRACE_FLAG=
	SILENT_MAKE=--silent
	if [[ $1 = -trace ]]; then
	    TRACE_FLAG=-trace
	    SILENT_MAKE=
	    shift
	fi
	if [[ $1 = -demographics ]]; then
	    DEMOGRAPHICS_FLAG=-demographics
	    shift
	fi
	
	echo -n "${ME}: "
EOF
   
   BOOTIMAGE_WRITER_MAKEFILE=Makefile

   echo 'if [[ $1 = -clean ]]; then'
   echo "    rm -f $PRIMORDIAL_CLASSES_STR $EXCLUDED_CLASSES_STR $BOOTIMAGE_STR $BOOTIMAGE_MAP_STR"
   echo '    echo -n "(primordials cleaned) "'
   echo "    rm -f $SCRATCH_DIRECTORY_STR/GenerateInterfaceDeclaration.*"
   echo "    rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclaration.h"
   echo "    rm -f $SCRATCH_DIRECTORY_STR/BootImage*.java"
   echo "    rm -f $SCRATCH_DIRECTORY_STR/BootImage*.class"
   echo '    echo -n "(bootimage cleaned) "'
   echo '    exit 0'
   echo 'fi'
   echo ''
   echo "rm -f $SCRATCH_DIRECTORY_STR/GenerateInterfaceDeclaration.*"
   echo "rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclaration.h"
   echo "rm -f $SCRATCH_DIRECTORY_STR/BootImage*.java"
   echo "rm -f $SCRATCH_DIRECTORY_STR/BootImage*.class"
   echo 'echo -n "(bootimage cleaned) "'

   # Generate list of classes to include in the bootimage.
   #
   echo "if [[ ! -e ${PRIMORDIAL_CLASSES_STR} ]]; then"

   # 
   # (1) Generate a list of Excluded classes that we don't want in the bootimage
   #

   # skip: needed to build bootimage, but not to run it
   echo "   echo BootImageInterface               > ${EXCLUDED_CLASSES_STR}"
   echo "   echo Dummy.class                      >> ${EXCLUDED_CLASSES_STR}"
   echo "   echo OptDummy.class                   >> ${EXCLUDED_CLASSES_STR}"

   # skip: VM_InetAddress and JikesRVMSocketImpl; don't load native libs unless needed
   echo "   echo VM_InetAddress.class             >> ${EXCLUDED_CLASSES_STR}"
   echo "   echo JikesRVMSocketImpl               >> ${EXCLUDED_CLASSES_STR}"

   # skip: don't put application class loader in, due to static data issues
   echo "   echo ApplicationClassLoader.class     >> ${EXCLUDED_CLASSES_STR}"

   # Add any configuration specific exclusions
   for exclusion in ${CONF_SPECIFIC_EXCLUSIONS_LIST}; do
      echo "   echo '${exclusion}'                  >> ${EXCLUDED_CLASSES_STR}"
   done

   # 
   # (2) Generate a list of primary classes (non-arrays, non compiler generated (Foo${bar})
   #     classes that will be included in the bootimage unless explicitly excluded.
   
   echo "   cd ${CLASSES_DIRECTORY_STR}"
   if (( RVM_WITH_ALL_CLASSES )); then
     echo "   \${FIND} . -name '*.class' -print > ${PRIMORDIAL_CLASSES_STR}.1"
   else
     echo "   \$FIND . -name 'VM*.class' -print > $PRIMORDIAL_CLASSES_STR.1"
     echo "   \$FIND ./com/ibm/JikesRVM/memoryManagers -name '*.class' -print >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   \$FIND . -path '*/JikesRVMSupport.class' -print >> $PRIMORDIAL_CLASSES_STR.1"
   fi

   # VM daemon threads that don't start with VM for historical reasons
   echo "   echo 'com/ibm/JikesRVM/FinalizerThread' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'com/ibm/JikesRVM/MainThread' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'com/ibm/JikesRVM/DebuggerThread' >> ${PRIMORDIAL_CLASSES_STR}.1"

   # fundamental java classes
   #
   echo "   echo 'java/lang/Class'           >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Object'          >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Runtime'         >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/String'          >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/StringBuffer'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/util/StringTokenizer' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/System'          >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Thread'          >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/ThreadGroup'     >> ${PRIMORDIAL_CLASSES_STR}.1"

   echo "   echo 'java/lang/OutOfMemoryError'  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/Cloneable'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/VMObject'          >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/VMSystem'          >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/classpath/Configuration' >> $PRIMORDIAL_CLASSES_STR.1"

   # reflection support
   #
   echo "   echo 'java/lang/reflect/Field'            >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/reflect/Method'           >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/reflect/Member'           >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/reflect/Constructor'      >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/reflect/AccessibleObject' >> ${PRIMORDIAL_CLASSES_STR}.1"

   # hardware runtime errors
   #
   echo "   echo 'java/lang/ArithmeticException' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/ArrayIndexOutOfBoundsException' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Exception'           >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Error'               >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/IndexOutOfBoundsException'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/LinkageError'        >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/NullPointerException'>> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/RuntimeException'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/SecurityException'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/StackOverflowError'  >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Throwable'           >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/UnknownError'        >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/VirtualMachineError' >> ${PRIMORDIAL_CLASSES_STR}.1"

   # software runtime errors
   #
   echo "   echo 'java/lang/IncompatibleClassChangeError' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/ClassCastException'           >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/ArrayStoreException'          >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/NegativeArraySizeException'   >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/AbstractMethodError'          >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/StringIndexOutOfBoundsException' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/UnsatisfiedLinkError'         >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/InternalError'                >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/IllegalMonitorStateException' >> ${PRIMORDIAL_CLASSES_STR}.1"

   # primitive wrapper types
   #
   echo "   echo 'java/lang/Boolean'   >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Byte'      >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Character' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Double'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Float'     >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Integer'   >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Long'      >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Number'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/Short'     >> ${PRIMORDIAL_CLASSES_STR}.1"

   # class loading errors
   #
   echo "   echo 'java/io/IOException'              >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/io/EOFException'             >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/io/FileNotFoundException'    >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/ClassNotFoundException' >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/ClassFormatError'       >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/lang/NoClassDefFoundError'   >> ${PRIMORDIAL_CLASSES_STR}.1"
   echo "   echo 'java/util/zip/ZipException'       >> ${PRIMORDIAL_CLASSES_STR}.1"

   # util datastructures (needed by compilers, classloaders, etc)
   #
   echo "   echo 'java/util/AbstractList'      >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/AbstractMap'       >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/AbstractSet'       >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/ArrayList'    	   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Arrays'    	   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/HashMap'    	   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/HashSet'           >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Hashtable'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/List'              >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/ListResourceBundle'>> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/PropertyResourceBundle'>> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/MissingResourceException'  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Properties'        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/ResourceBundle'    >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Vector'            >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/AbstractCollection'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Collections'            >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Stack'		        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/WeakHashMap'            >> $PRIMORDIAL_CLASSES_STR.1"

   # class loaders
   #
   echo "   echo 'java/lang/ClassLoader'   	                        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/VMClassLoader'                         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/VMSecurityManager'                     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/PlatformHelper'                      >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/CodeSource'                        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/Policy'                            >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/PermissionCollection'              >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/Permissions'                       >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/Principal'                         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/locale/Calendar'		        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/ref/SoftReference'			>> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/reflect/InvocationTargetException'     >> $PRIMORDIAL_CLASSES_STR.1"

   # class loading from regular files
   #
   echo "   echo 'java/io/File'              >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/DataInputStream'   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/DataOutputStream'  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/FilterInputStream' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/InputStream'       >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/FileInputStream'   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/FileDescriptor'    >> $PRIMORDIAL_CLASSES_STR.1"
   if (( RVM_WITH_NON_BLOCKING_FDS_FOR_CLASSPATH )); then
     echo "   echo 'java/io/VMFileDescriptor'>> ${PRIMORDIAL_CLASSES_STR}.1"
   fi

   # class loading from zip files
   #
   echo "   echo 'java/util/zip/ZipFile'      >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/ZipFile'      >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/ZipEntry'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/Inflater'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/InflaterInputStream' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/Deflater'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/DeflaterOutputStream' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/ZipException' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/Adler32'      >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/StreamManipulator' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/OutputWindow' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/InflaterHuffmanTree' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/DeflaterHuffman' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/zip/InflaterDynHeader' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/InputStreamReader'  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/BufferedReader'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/Reader'             >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/Math'             >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/Serializable'       >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Calendar'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/GregorianCalendar'>> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Locale'           >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/Date'             >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/TimeZone'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/SimpleTimeZone'   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/Cloneable'        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/AccessController' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/PrivilegedAction' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/util/PropertyPermission' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/BasicPermission' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/Permission'   >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/AllPermission'>> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/security/AllPermissionCollection'>> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/RuntimePermission' >> $PRIMORDIAL_CLASSES_STR.1"
   
   # the application class loader uses jar classes (which can be loaded or not)
    if (( RVM_WITH_ALL_CLASSES )); then
	cat <<- EOF
	echo 'java/util/jar/JarException' >> ${PRIMORDIAL_CLASSES_STR}.1
	echo 'java/util/jar/JarInputStream' >> ${PRIMORDIAL_CLASSES_STR}.1
	echo 'java/util/jar/Attributes' >> ${PRIMORDIAL_CLASSES_STR}.1
	echo 'java/util/jar/JarOutputStream' >> ${PRIMORDIAL_CLASSES_STR}.1
	echo 'java/util/jar/JarEntry' >> ${PRIMORDIAL_CLASSES_STR}.1
	echo 'java/util/jar/JarFile' >> ${PRIMORDIAL_CLASSES_STR}.1
	echo 'java/util/jar/Manifest' >> ${PRIMORDIAL_CLASSES_STR}.1
	EOF
    fi

   echo "   echo 'java/io/BufferedOutputStream' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/BufferedInputStream'  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/ByteArrayInputStream' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/FileOutputStream'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/PrintStream'          >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/RandomAccessFile'     >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/ObjectStreamField'    >> $PRIMORDIAL_CLASSES_STR.1"

   if (( RVM_WITH_OSR )); then
     # on stack replacement
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_ObjectHolder' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_BaselineExecStateExtractor' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_OptExecStateExtractor' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_EncodedOSRMap' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_SpecialCompiler' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_AdjustBCIndexes' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/OSR/OSR_PostThreadSwitch' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementTrigger' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementEvent' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementPlan' >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/adaptive/OSR_OrganizerThread' >> $PRIMORDIAL_CLASSES_STR.1"
   fi

   echo "   echo 'java/io/PrintWriter'        >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/OutputStreamWriter' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/io/InputStreamReader'  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/EncodingManager'              >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/Decoder8859_1'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/Decoder8859_2'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/Decoder8859_3'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/Decoder8859_4'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/Decoder8859_5'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/DecoderEightBitLookup' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/decode/DecoderUTF8'           >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/Encoder8859_1'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/Encoder8859_2'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/Encoder8859_3'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/Encoder8859_4'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/Encoder8859_5'         >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/EncoderEightBitLookup' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/io/encode/EncoderUTF8'           >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/ref/Reference'                  >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'java/lang/ref/ReferenceQueue'             >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/security/provider/DefaultPolicy' >> $PRIMORDIAL_CLASSES_STR.1"
   echo "   echo 'gnu/java/locale/Calendar_en'              >> $PRIMORDIAL_CLASSES_STR.1"

   if (( RVM_WITH_OPT_COMPILER )); then
      # data structures that need to carry over from boot image writing
      # and/or classes that opt wants to be in the bootimage to 
      # generate decent code (avoid dynamic linking, get them opt compiled)
      if (( RVM_WITH_OPT_BOOTIMAGE_COMPILER )); then
         echo "   echo 'java/util/Enumeration'         >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'java/util/Dictionary'          >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'java/util/TreeMap'          >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'java/util/TreeSet'          >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'java/util/Stack'               >> $PRIMORDIAL_CLASSES_STR.1"

         echo "   echo 'com/ibm/JikesRVM/opt/ir/OPT_CallSiteTreeNode'  	>> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_FieldAnalysis'  	        >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_FieldDatabase'  	        >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_SpecializedMethod'         >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_InvokeeThreadLocalContext' >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_SpecializedMethodPool'     >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_SpecializationDatabase'     >> $PRIMORDIAL_CLASSES_STR.1"

         echo "   echo 'com/ibm/JikesRVM/opt/OPT_ClassLoadingDependencyManager'     >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_InvalidationDatabase'     >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_InterfaceHierarchy'     >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_SummaryDatabase'     >> $PRIMORDIAL_CLASSES_STR.1"
         echo "   echo 'com/ibm/JikesRVM/opt/OPT_MethodSummary'     >> $PRIMORDIAL_CLASSES_STR.1"
      fi

      if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
        echo "   echo 'com/ibm/JikesRVM/opt/OPT_ContextFreeInlinePlan'       >> $PRIMORDIAL_CLASSES_STR.1"
      fi
   fi

   if (( RVM_WITH_HPM )) ; then
     echo "   echo 'com/ibm/JikesRVM/HPM_counters'       >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'com/ibm/JikesRVM/HPM_info'           >> $PRIMORDIAL_CLASSES_STR.1"
     echo "   echo 'Lcom/ibm/JikesRVM/Java2HPM;'         >> $PRIMORDIAL_CLASSES_STR.1"
   fi
   echo "\
#
# (3) Now that we have a big file of root classes to include, 
#     process the exclusions,
#     find all the compiler-generated classes,
#     and convert to internal names."
# Old version of below:
   echo "   \$FGREP -v -f $EXCLUDED_CLASSES_STR ${PRIMORDIAL_CLASSES_STR}.1 | \${SED} -e'/\\\$/d' -e 's@^\\./@@' -e 's@\.class\$@@' -e 's@^\\(.*\\)\$@\\1.class\\
\\1\$@' > ${PRIMORDIAL_CLASSES_STR}.2"
   echo "   $HOST_JAR_STR tf rvmrt.jar > $PRIMORDIAL_CLASSES_STR.3"
   echo "   \$FIND . -name '*.class' -print | \$SED 's@^\./@@' >> $PRIMORDIAL_CLASSES_STR.3"
   echo "   \$FGREP -f $PRIMORDIAL_CLASSES_STR.2 $PRIMORDIAL_CLASSES_STR.3 | \$SED 's@\(.*\)\.class@L\1;@' > $PRIMORDIAL_CLASSES_STR"
   echo "   rm $PRIMORDIAL_CLASSES_STR.1"
   echo "   rm $PRIMORDIAL_CLASSES_STR.2"
   echo "   rm $PRIMORDIAL_CLASSES_STR.3"

   echo "\
# 
# (4) Add Array types.  NOTE: These must be in internal form.
#"
   echo "   echo '[Ljava/util/AbstractSet;'      >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/util/HashSet;'          >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/util/HashMap\$HashEntry;'  	    >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/util/WeakHashMap\$WeakBucket;'  >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/security/Principal;'     >> $PRIMORDIAL_CLASSES_STR"

   echo "   echo '[Ljava/util/zip/ZipEntry;'    >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_LockNursery\$VM_LockBucket;' >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_Atom;'           >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_BasicBlock;'                 >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_Field;'          >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_Method;'         >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_MemberReference;'>> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_Type;'           >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_TypeReference;'  >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/memoryManagers/vmInterface/VM_CollectorThread;'            >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/memoryManagers/JMTk/VMResource;'                      >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/memoryManagers/JMTk/MemoryResource;'                  >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/memoryManagers/JMTk/Plan;'                      >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/Object;'              >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[[Ljava/lang/Object;'             >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/String;'              >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/Class;'               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/reflect/Field;'       >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/reflect/Method;'      >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/reflect/Member;'      >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/reflect/Constructor;' >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/io/ObjectStreamField;'     >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/security/ProtectionDomain;'>> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Ljava/lang/Package;'             >> $PRIMORDIAL_CLASSES_STR"

   echo "   echo '[B'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[C'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[I'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[F'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[D'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[J'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[S'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Z'                               >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[[I'                              >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[[B'                              >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[[[I'                             >> $PRIMORDIAL_CLASSES_STR"
   echo "\
# These next arrays are really arrays of primitves to Jikes RVM 
#  (even though Java doesn't think they are...)"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Address;'   >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Word;'      >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Offset;'    >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Extent;'    >> $PRIMORDIAL_CLASSES_STR"

   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_Class;'          >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_UnusualMaps;'                >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Processor;'                  >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Thread;'                     >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_Lock;'                       >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_CompiledMethod;'             >> $PRIMORDIAL_CLASSES_STR"
   echo "   echo '[Lcom/ibm/JikesRVM/VM_DynamicLibrary;'             >> $PRIMORDIAL_CLASSES_STR"

   echo "   echo '[Lcom/ibm/JikesRVM/classloader/VM_InterfaceMethodSignature;'   >> $PRIMORDIAL_CLASSES_STR # for fast interface method invoker"

   echo "   echo '[Lcom/ibm/JikesRVM/VM_CommandLineArgs\$Prefix;' >> $PRIMORDIAL_CLASSES_STR # for command line argument processing"

   if (( RVM_WITH_OPT_COMPILER )); then
      echo "   echo '[[C'                       >> $PRIMORDIAL_CLASSES_STR"
      echo "   echo '[Ljava/util/HashSet;'      >> $PRIMORDIAL_CLASSES_STR"
      if (( RVM_WITH_ALL_CLASSES )); then
        echo "   echo '[Lcom/ibm/JikesRVM/opt/OPT_OperatorClass;'              >> $PRIMORDIAL_CLASSES_STR"
        echo "   echo '[Lcom/ibm/JikesRVM/opt/OPT_ResourceReservation;'              >> $PRIMORDIAL_CLASSES_STR"
        echo "   echo '[Lcom/ibm/JikesRVM/opt/ir/OPT_Operator;'                   >> $PRIMORDIAL_CLASSES_STR"
        echo "   echo '[Lcom/ibm/JikesRVM/opt/ir/OPT_Register;'                   >> $PRIMORDIAL_CLASSES_STR"
      fi

      if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
          echo "   echo '[[D'                               >> $PRIMORDIAL_CLASSES_STR"
          echo "   echo '[Lcom/ibm/JikesRVM/adaptive/VM_MethodListener;'              >> $PRIMORDIAL_CLASSES_STR"
          echo "   echo '[Lcom/ibm/JikesRVM/adaptive/VM_EdgeListener;'                >> $PRIMORDIAL_CLASSES_STR"
          echo "   echo '[Lcom/ibm/JikesRVM/adaptive/VM_ContextListener;'             >> $PRIMORDIAL_CLASSES_STR"
          echo "   echo '[Lcom/ibm/JikesRVM/adaptive/VM_NullListener;'                >> $PRIMORDIAL_CLASSES_STR"
      fi
   fi

   echo "\
# Add the configuration specific primordials
#"
   for primordial in $CONF_SPECIFIC_PRIMORDIALS_LIST; do
       echo "   echo '$primordial'			>> $PRIMORDIAL_CLASSES_STR"
   done

   echo '   echo -n "(primordials updated) "'
   echo 'fi'

   echo "\
# Create bootimage.
#"
   if (( RVM_FOR_POWERPC )); then
      ARCHITECTURE="PowerPC"
      INSTRUCTION_TYPE="int"
   elif (( RVM_FOR_IA32 )); then
      ARCHITECTURE="Intel"
      INSTRUCTION_TYPE="byte"
   else
      ARCHITECTURE="UNSPECIFED_ARCHITECTURE"
      INSTRUCTION_TYPE="UNSPECIFED_INSTRUCTION_TYPE"
   fi
   
   ADDRESS_TYPE="int"

   BOOTIMAGE_WRITER_ARGS="\$DEMOGRAPHICS_FLAG \$TRACE_FLAG"

   BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -ia $BOOTIMAGE_LOAD_ADDRESS"

   if (( GENERATE_MAP )); then
      BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -m $BOOTIMAGE_MAP_STR"
   fi
   
   if (( RVM_FOR_IA32 )); then
      BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -littleEndian"
   fi

   echo ""
   echo 'OPT_ARGS="'$OPT_ARGS' $DEBUG_ARGS"'

   if (( RVM_WITH_NOFLUSH )); then
      echo ' OPT_ARGS="$OPT_ARGS -X:bc:no_cache_flush=true"'
   fi

   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '   OPT_ARGS="$OPT_ARGS -X:bc:verbose=true"'
   echo '   VERBOSE_STR="VERBOSE_ARG=-verbose:gc"'
   echo 'fi'
   echo ""

   # copy and preprocess BootImageWriter sources
   #
   echo ''
   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '    echo -n "$ME: '$BOOTIMAGE_WRITER_DIR_STR'"'
   echo 'fi'
   echo 'FILES=$(/bin/ls' $BOOTIMAGE_WRITER_DIR_STR'/*.java)'
   echo $BUILD_DIRECTORY_STR/jbuild.prep --disable-modification-exit-status '$TRACE_FLAG' $PREPROCESSOR_DEFINITIONS $SCRATCH_DIRECTORY_STR ' $FILES'
   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '   echo ""'
   echo 'fi'
   echo ''

   # compile BootImageWriter.java
   #
   echo "cd $SCRATCH_DIRECTORY_STR &&\
          $HOST_JIKES_STR -nowarn +F +Z +KINSTRUCTION=$INSTRUCTION_TYPE +E -g +U\
	  -classpath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  BootImageWriter.java"

   # copy and preprocess GenerateInterfaceDeclarations.java
   #
   echo ''
   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '    echo -n "$ME: '$BOOTIMAGE_RUNNER_DIR_STR'"'
   echo 'fi'
   echo 'FILES=$(/bin/ls' $BOOTIMAGE_RUNNER_DIR_STR'/GenerateInterfaceDeclarations.java)'
   echo $BUILD_DIRECTORY_STR/jbuild.prep --disable-modification-exit-status '$TRACE_FLAG' $PREPROCESSOR_DEFINITIONS $SCRATCH_DIRECTORY_STR ' $FILES'
   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '    echo ""'
   echo 'fi'
   echo '
#
# compile GenerateInterfaceDeclarations.java
#'
   echo "cd $SCRATCH_DIRECTORY_STR &&\
          $HOST_JIKES_STR -nowarn +F +Z +KINSTRUCTION=$INSTRUCTION_TYPE +E -g +U\
	  -classpath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  GenerateInterfaceDeclarations.java"

   echo '#
# generate InterfaceDeclarations.h
#'
   echo "rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclarations.h"
   echo "cd $SCRATCH_DIRECTORY_STR && $HOST_JAVA_STR -Xms200M -Xmx200M\
          -classpath .:$CLASSES_DIRECTORY_STR:$CLASSES_DIRECTORY_STR/rvmrt.jar\
          GenerateInterfaceDeclarations -ia $BOOTIMAGE_LOAD_ADDRESS >\
	  $SCRATCH_DIRECTORY_STR/InterfaceDeclarations.h"
   echo ""

   echo "cd $BOOTIMAGE_WRITER_DIR_STR"

   echo "$GNU_MAKE_STR -f $BOOTIMAGE_WRITER_MAKEFILE \$SILENT_MAKE \$VERBOSE_STR\
          RVM_REPOSITORIES=$CLASSES_DIRECTORY_STR/jksvm.jar:$CLASSES_DIRECTORY_STR/rvmrt.jar\
          RVM_BOOTIMAGE_CLASSES=$PRIMORDIAL_CLASSES_STR\
          RVM_BOOTIMAGE=$BOOTIMAGE_STR\
          RVM_BOOTIMAGE_COMPILER_ARGS=\"\$OPT_ARGS\"\
          RVM_BOOTIMAGE_WRITER_ARGS=\"$BOOTIMAGE_WRITER_ARGS\"\
          SCRATCH_DIR=$SCRATCH_DIRECTORY_STR\
          $BOOTIMAGE_STR"

   echo 'if [[ $TRACE_FLAG = -trace ]]; then'
   echo '  echo ""'
   echo 'fi'
}

# Emit script to generate vm booter.
# echo >&2  "HERE I AM! emitBooterLinker" # DBG
function emitBooterLinker () {
   echo '#! /bin/bash'
   echo ""
   echo '# Generate vm booter.'
   echo ""
   echo '# Taken:    InterfaceDeclarations.h in bootImageRunner directory'
   echo '# Returned: booter in build directory'
   echo ""
   echo '# Allow the build directory to be different in the host/boot image'
   echo '# writing system, and on the target system.'
   echo ""
   echo '. ./boilerplate.bash'
   echo 'ROOT_DIR="${0%/*}"'
   echo '# I do not understand the point behind this code. --Steve Augart'
   echo 'if [[ "$ROOT_DIR" = "." ]]; then'
   echo '   ROOT_DIR="$PWD"'
   echo 'fi'
   echo 'if [[ "$ROOT_DIR" != "$CURRENT_DIR" ]]; then'
   echo '   if [[ -f "$CURRENT_DIR"/"$ROOT_DIR"/"$ME" ]]; then'
   echo '      ROOT_DIR=$CURRENT_DIR/$ROOT_DIR'
   echo '   fi'
   echo 'fi'
   echo ""
   echo '. $ROOT_DIR/environment'
   echo ""
   echo "$BUILD_DIRECTORY_STR1=\$ROOT_DIR"
   echo ""

   echo 'SILENT_MAKE=--silent'
   echo 'if [[ $1 = -trace ]]; then'
   echo '   TRACE_FLAG=-trace'
   echo '   SILENT_MAKE='
   echo '   shift'
   echo 'fi'

   echo 'echo -n "$ME: "'
   echo 'if [[ $TRACE_FLAG = -trace ]]; then set -x; fi'

   echo ""
   echo "rm -f libjni.a"
   echo "cd $SCRATCH_DIRECTORY_STR"
   echo "rm -f $BOOTER_STR RunBootImage.o initBootRecord.o sys.o bootThread.o bootThread.s libvm.o RunBootImage.h"
   echo 'echo -n "(booter cleaned) "'
   echo 'if [[ $1 = -clean ]]; then'

   echo '   exit 0'
   echo 'fi'
   echo ""

   if [[ $RVM_HOST_CONFIG != $RVM_TARGET_CONFIG ]]; then
     echo '  $JAL_ROOT/rvm/bin/jBuildClasspathJar --check'
   fi

   # copy native libraries
   if [[ x$CLASSPATH_ROOT = x ]]; then
     CPS=$RVM_ROOT/classpath
   else
     CPS=$CLASSPATH_ROOT
   fi
   echo 'SYSTEM_TYPE=$('$CPS'/classpath/config.guess)'
   if (( RVM_FOR_AIX )); then
     echo 'for _library in' $CPS/'$SYSTEM_TYPE/native/jni/*/.libs/*.so.0; do'
     echo '  cp $_library' $BUILD_DIRECTORY_STR'/${_library##*/}.so.0a'
     echo 'done'
   else
     echo 'cp -f '$CPS'/$SYSTEM_TYPE/native/jni/*/.libs/*.so '$BUILD_DIRECTORY_STR
   fi
   echo -e "\necho -n '(classpath native libraries copied) '"

   # Create RunBootImage.h file.
   echo "echo \"// RunBootImage.C boot-time constants\" >> RunBootImage.h"
   echo "echo \"int heap_default_size = $DEFAULT_HEAP_SIZE;\" >> RunBootImage.h"
   echo "echo \"char *rvm_version              = \\\"$JIKESRVM_VERSION\\\";\" >> RunBootImage.h"
   echo "echo \"char *rvm_configuration        = \\\"$CONFIGURATION_NAME\\\";\" >> RunBootImage.h"
   echo "echo \"char *rvm_host_configuration   = \\\"$RVM_HOST_CONFIG\\\";\" >> RunBootImage.h"
   echo "echo \"char *rvm_target_configuration = \\\"$RVM_TARGET_CONFIG\\\";\" >> RunBootImage.h"
   echo ""

   if (( RVM_FOR_AIX )); then
	echo 'if [[ $(uname) != AIX ]]; then'
	echo '   echo "please run me on AIX"'
	echo '   exit 1'
	echo 'fi'
   elif (( RVM_FOR_LINUX )); then
	echo 'if [[ $(uname) != Linux ]]; then'
	echo '   echo "please run me on Linux"'
	echo '   exit 1'
	echo 'fi'

	if (( RVM_FOR_POWERPC )); then
		echo 'if [[ $(uname -m) != ppc ]]; then'
		echo '   echo "please run me on Linux PowerPC"'
		echo '   exit 1'
		echo 'fi'
        elif (( RVM_FOR_IA32 )); then
		echo 'if [[ $(uname -m) != i686 ]]; then'
		echo '   echo "please run me on Linux IA32"'
		echo '   exit 1'
		echo 'fi'
	fi
   fi
   echo ""

   # build the JNI code for heavyweight networking calls
   echo 'cd ${JAL_ROOT}/rvm/src/tools/bootImageRunner/'
   if (( RVM_FOR_AIX )); then
     echo '$GNU_MAKE $SILENT_MAKE -f Makefile.inet DEST=$JAL_BUILD/libjpninet.a $JAL_BUILD/libjpninet.a'
     echo '$GNU_MAKE $SILENT_MAKE -f Makefile.proc DEST=$JAL_BUILD/libjpnexec.a $JAL_BUILD/libjpnexec.a'
   else
     echo '$GNU_MAKE $SILENT_MAKE -f Makefile.inet DEST=$JAL_BUILD/libjpninet.so $JAL_BUILD/libjpninet.so '
     echo '$GNU_MAKE $SILENT_MAKE -f Makefile.proc DEST=$JAL_BUILD/libjpnexec.so $JAL_BUILD/libjpnexec.so '
   fi

   if (( RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
    CC_DEFINES="-DRVM_FOR_SINGLE_VIRTUAL_PROCESSOR"
   else 
    CC_DEFINES="-URVM_FOR_SINGLE_VIRTUAL_PROCESSOR"
   fi

   if (( RVM_FOR_32_ADDR )); then
     CC_DEFINES="$CC_DEFINES -DRVM_FOR_32_ADDR -URVM_FOR_64_ADDR"
   fi
   if (( RVM_FOR_64_ADDR )); then
     CC_DEFINES="$CC_DEFINES -DRVM_FOR_64_ADDR -URVM_FOR_32_ADDR"
   fi
  
   if (( RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )); then
     CC_DEFINES="$CC_DEFINES -DRVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS"
   fi

   # Build the blocking system call wrapper library, if requested
   if (( ! RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )); then
      if (( RVM_FOR_AIX )); then
        echo '$GNU_MAKE $SILENT_MAKE -f Makefile.syswrap DEST=$JAL_BUILD/libsyswrap.a CXXFLAGS="'"$CC_DEFINES"'" $JAL_BUILD/libsyswrap.a'
      else
        echo '$GNU_MAKE $SILENT_MAKE -f Makefile.syswrap DEST=$JAL_BUILD/libsyswrap.so CXXFLAGS="'"$CC_DEFINES"'" $JAL_BUILD/libsyswrap.so'
      fi
   fi

   if (( RVM_FOR_POWERPC && RVM_FOR_AIX )); then
	 echo "BOOTER_CC=\"$HOST_CPLUS_STR -g -DRVM_FOR_AIX -DRVM_FOR_POWERPC $CC_DEFINES\""
 	 echo "LDSHARED=\"$HOST_SHLD_STR\""
         echo 'BOOTER_CCM="$BOOTER_CC -M"'
	 echo "CPP=\"$HOST_CC_STR -E $CC_DEFINES\""

	 echo 'CCLIBS="-lpthread -lm"'
         echo 'IMAGE='

   elif (( RVM_FOR_POWERPC && RVM_FOR_LINUX && RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	 echo "BOOTER_CC=\"$HOST_CPLUS_STR -g -DRVM_FOR_LINUX -DRVM_FOR_POWERPC $CC_DEFINES\""
 	 echo "LDSHARED=\"$HOST_SHLD_STR\""
	 echo 'BOOTER_CCM=$BOOTER_CC'
	 echo "CPP=\"$HOST_CPP_STR $CC_DEFINES\""

	 echo 'CCLIBS="${EXTRA_CCLIBS} -ldl -lm"'
	 echo 'IMAGE="-DIMAGE_ADDRESS=0x31000000"'

   elif (( RVM_FOR_POWERPC && RVM_FOR_LINUX && !RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	 echo "BOOTER_CC=\"$HOST_CPLUS_STR -g -rdynamic -DRVM_FOR_LINUX -DRVM_FOR_POWERPC $CC_DEFINES\""
 	 echo "LDSHARED=\"$HOST_SHLD_STR\""
	 echo 'BOOTER_CCM=$BOOTER_CC'
	 echo "CPP=\"$HOST_CPP_STR $CC_DEFINES -D__linuxsmp__\""

	 echo 'CCLIBS="-lpthread -ldl -lm"'
	 echo 'IMAGE="-DIMAGE_ADDRESS=0x31000000"' 

   elif (( RVM_FOR_IA32 && RVM_FOR_LINUX && !RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	 echo "BOOTER_CC=\"$HOST_CPLUS_STR -g -rdynamic -DRVM_FOR_LINUX -DRVM_FOR_IA32 -D_REENTRANT $CC_DEFINES\""

	 echo 'CCLIBS="-lpthread -ldl"'
         echo 'IMAGE='
   elif (( RVM_FOR_IA32 && RVM_FOR_LINUX && RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	 echo "BOOTER_CC=\"$HOST_CPLUS_STR -g -DRVM_FOR_LINUX -DRVM_FOR_IA32 $CC_DEFINES\""

	 echo 'CCLIBS="-ldl"'
         echo 'IMAGE='
   elif (( RVM_FOR_IA32 && RVM_FOR_CYGWIN )); then
	 echo "BOOTER_CC=\"$HOST_CPLUS_STR -DRVM_FOR_CYGWIN -DRVM_FOR_IA32 $CC_DEFINES\""

	 echo 'CCLIBS=""'
         echo 'IMAGE='
   fi
   echo ""

   if (( RVM_FOR_POWERPC && ( RVM_FOR_AIX || RVM_FOR_LINUX ) )); then
      echo "cd $BOOTIMAGE_RUNNER_DIR_STR &&\
		\$BOOTER_CC -c -O -I$SCRATCH_DIRECTORY_STR\
		-I$BOOTIMAGE_RUNNER_SUBDIR_STR\
		\$IMAGE -DRVM_BOOTIMAGE=\\\"$BOOTIMAGE_STR\\\"\
		-o $SCRATCH_DIRECTORY_STR/RunBootImage.o RunBootImage.C"

      echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
	    \$BOOTER_CC -c -O -I. -I$SCRATCH_DIRECTORY_STR \
	    -o $SCRATCH_DIRECTORY_STR/initBootRecord.o initBootRecord.C"
	
      echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
		\$CPP -I$SCRATCH_DIRECTORY_STR -P\
		bootThread.c > $SCRATCH_DIRECTORY_STR/bootThread.s"
      echo "\$BOOTER_CC -c -o $SCRATCH_DIRECTORY_STR/bootThread.o\
		$SCRATCH_DIRECTORY_STR/bootThread.s"
      echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
		\$BOOTER_CC -c -I. -I$SCRATCH_DIRECTORY_STR\
		\$IMAGE -DRVM_BOOTIMAGE=\\\"$BUILD_DIRECTORY_STR/RVM.image\\\"\
		-o $SCRATCH_DIRECTORY_STR/libvm.o libvm.C"

      if (( $RVM_WITH_HPM )); then
	echo "cd $BOOTIMAGE_RUNNER_DIR_STR &&\
	    \$BOOTER_CC -c -O -I$SCRATCH_DIRECTORY_STR -DRVM_WITH_HPM=1\
	    -o $SCRATCH_DIRECTORY_STR/sys.o sys.C"
	
	echo 'echo -n "(build libhpm.a library)"'
        echo "cd $ROOT_DIRECTORY_STR/rvm/src/vm/arch/powerPC/runtime &&\
	    \$BOOTER_CC -c -O -o $SCRATCH_DIRECTORY_STR/hpm.o hpm.c"
        echo "cd $SCRATCH_DIRECTORY_STR &&\
                \$LDSHARED -o \$JAL_BUILD/libhpm.a  hpm.o -L\"$RVM_HPM_DIR\" -lpmapi"

        echo "cd $SCRATCH_DIRECTORY_STR &&\
	    \$BOOTER_CC -o $BOOTER_STR RunBootImage.o initBootRecord.o libvm.o sys.o bootThread.o \$CCLIBS\
	    -L\"$RVM_HPM_DIR\" -lpmapi -L\"\$JAL_BUILD\" -lhpm"

	echo 'echo -n "(build libJava2HPM.a JNI library)"'
        echo "cd $ROOT_DIRECTORY_STR/rvm/src/vm/arch/powerPC/runtime &&\
  		\$BOOTER_CC -c -O -I$SCRATCH_DIRECTORY_STR -I$ROOT_DIRECTORY_STR/rvm/src/include\
 		-o $SCRATCH_DIRECTORY_STR/Java2HPM.o Java2HPM.C"

        echo "cd $SCRATCH_DIRECTORY_STR &&\
                \$LDSHARED -o \$JAL_BUILD/libJava2HPM.a  Java2HPM.o\
	        -L\"$RVM_HPM_DIR\" -lpmapi -L\"\$JAL_BUILD\" -lhpm > /dev/null 2>&1"
      else
	echo "cd ${BOOTIMAGE_RUNNER_DIR_STR} &&\
	    \${BOOTER_CC} -c -O -I${SCRATCH_DIRECTORY_STR}\
	    -o ${SCRATCH_DIRECTORY_STR}/sys.o sys.C"
	echo "cd ${SCRATCH_DIRECTORY_STR} &&\
	    \${BOOTER_CC} -o ${BOOTER_STR} RunBootImage.o initBootRecord.o libvm.o sys.o bootThread.o \${CCLIBS}"
      fi
      echo 'echo -n "(booter linked)"'

   elif (( RVM_FOR_IA32 && RVM_FOR_LINUX )); then
      echo "cd ${BOOTIMAGE_RUNNER_DIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
		\${IMAGE} -DRVM_BOOTIMAGE=\\\"${BOOTIMAGE_STR}\\\"\
		-o ${SCRATCH_DIRECTORY_STR}/RunBootImage.o RunBootImage.C"
      echo "cd ${BOOTIMAGE_RUNNER_SUBDIR_STR} &&\
		\${BOOTER_CC} -c -I. -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/initBootRecord.o initBootRecord.C"
      echo "cd ${BOOTIMAGE_RUNNER_DIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/sys.o sys.C"
      echo "cd ${BOOTIMAGE_RUNNER_SUBDIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/bootThread.o bootThread.S"
      echo "cd ${BOOTIMAGE_RUNNER_SUBDIR_STR} &&\
		\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR}\
                -I${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler\
		-o ${SCRATCH_DIRECTORY_STR}/libvm.o libvm.C"
      echo "cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler &&\
		\${BOOTER_CC} -funsigned-bitfields -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/disasm.o disasm.C"
      echo "cd ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler &&\
		\${BOOTER_CC} -funsigned-bitfields -c -I${SCRATCH_DIRECTORY_STR}\
		-o ${SCRATCH_DIRECTORY_STR}/ihnpdsm.o ihnpdsm.C"
      echo "cd ${SCRATCH_DIRECTORY_STR} &&\
	    \${BOOTER_CC} -o ${BOOTER_STR} RunBootImage.o initBootRecord.o sys.o bootThread.o libvm.o\
                                   disasm.o ihnpdsm.o \${CCLIBS}"
      echo 'echo "(booter linked)"'
      echo ""

   else
       echo 'echo "dont know how to link booter"'
       echo 'exit 1'
   fi
  
   echo '
if [[ ${TRACE_FLAG} = -trace ]]; then
    set +x
fi';
}

# Emit script to generate .class files for vm tools that are not part of the build.
#
# echo >&2  "HERE I AM! emitToolCompiler" # DBG
function emitToolCompiler () {
   echo '#! /bin/bash'
   echo '# Generate class files for vm tools that are not part of the build.'
   echo '# In simpler language, this runs the Jikes compiler with the environment'
   echo '# properly set up.'
   echo '. ${RVM_BUILD}/boilerplate.bash'
   echo '. ${RVM_BUILD}/environment'

   echo 'if [[ $# = 0 ]]; then'
   echo '    echo 2>&1 "usage: ${ME} [ -classpath x:y:z ] java-file [ java-file... ]"'
   echo '    exit 1'
   echo 'fi'

   if (( RVM_FOR_POWERPC )); then
      INSTRUCTION_TYPE="int"
   elif (( RVM_FOR_IA32 )); then
      INSTRUCTION_TYPE="byte"
   else
      INSTRUCTION_TYPE="UNSPECIFED_INSTRUCTION_TYPE"
   fi

   ADDRESS_TYPE="int"

   echo 'if [[ '${BUILD_DIRECTORY_STR}' = "" ]]; then'
   echo '   echo "${ME}: please set your' ${BUILD_DIRECTORY_STR1} 'environment variable (eg. ${HOME}/rvmBuild)"'
   echo '   exit 1'
   echo 'fi'

   echo 'if [[ '${HOST_JIKES_STR}' = "" ]]; then'
   echo '   echo "${ME}: please set your' ${HOST_JIKES_STR1} 'environment variable"'
   echo '   exit 1'
   echo 'fi'

   echo "CPATH=${BUILD_DIRECTORY_STR}/RVM.classes:${BUILD_DIRECTORY_STR}/RVM.classes/rvmrt.jar"
   echo 'if [[ $1 = -classpath ]]; then'
   echo '   CPATH=$2:${CPATH}'
   echo '   shift'
   echo '   shift'
   echo 'else'
   echo '   CPATH=.:${CPATH}'
   echo 'fi'

   echo 'set -x'
   echo "$HOST_JIKES_STR -nowarn +F +Z +KINSTRUCTION=$INSTRUCTION_TYPE +KADDRESS=$ADDRESS_TYPE +E -g +U -classpath \"\$CPATH\" \"\$@\""
}
  
# Emit script to run jbuild.prep on java files that are not part of the build
#
function emitToolPreprocessor () {
   echo '#! /bin/bash'
   echo '# Generate class files for vm tools that are not part of the build.'
   echo '. "$RVM_BUILD/boilerplate.bash"'
   echo '. "$RVM_BUILD/environment"'

   echo 'if [[ $# = 0 ]]; then'
   echo '   echo >&2 "usage: $ME java-file [ java-file... ]"'
   echo '   exit 1'
   echo 'fi'

   echo 'exec "$RVM_BUILD/jbuild.prep"' $PREPROCESSOR_DEFINITIONS '"$@"'
}
  
function emitPluginBuilder () {
    cat <<- 'EOF'
	#! /bin/bash
	# Build and install Jikes RVM launching plugin for Eclipse 2.x

	# pick up configuration to learn where Ant is
	. "${RVM_BUILD}/boilerplate.bash"
	. "${RVM_BUILD}/environment"

	# allow user-specified Eclipse install to override env
	if [[ x$1 != x ]]; then
	    ECLIPSE_INSTALL_DIR=$1
	fi

	# must have Eclipse for command line or env
	if [[ x${ECLIPSE_INSTALL_DIR} = x ]]; then
	    echo "must specify Eclipse home: either
	    echo "  1: set it in ${RVM_TARGET_CONFIG}, or
	    echo "  2: use jbuild.plugin <eclipse dir>"
	  exit 2
	fi

	# must have Ant
	if [[ x${ANT_CMD} = x ]]; then
	    echo "must specify ANT_CMD in ${RVM_TARGET_CONFIG}"
	    exit 2
	fi

	# build the plugin
	echo "building org.eclipse.jdt.launching.jikesrvm"

	echo "eclipse.dir=${ECLIPSE_INSTALL_DIR}" > ${JAL_ROOT}/rvm/src/tools/eclipse/plugin2/ant.properties

	cd ${JAL_ROOT}/rvm/src/tools/eclipse/plugin2
	export JAVA_HOME=${HOST_JAVA_HOME}
	${ANT_CMD} -quiet install

	EOF
}

#------------------------------------------------#
# SECTION 6 - Mainline Code that does the work.  #
#------------------------------------------------#
    
echo "${ME}: setting up ${BUILD_DIRECTORY} for ${CONFIGURATION_NAME}"

# Ensure configuration options are sensible.
checkConfigurationOptions

# Make a fresh start.
#
if [[ -e ${BUILD_DIRECTORY} ]]; then # old directory exists
    if [ -t 0 ]; then # keyboard is live (ie. this is not an automated build)
	echo -n "${ME}: ${BUILD_DIRECTORY} already exists, replace it? (y/n)"
	read response
	if [[ ${response} != y && ${response} != 'yes' ]]; then
	    echo "${ME}: operation aborted, nothing written"
	    trap '' EXIT
	    ## Why on earth do we want to keep Make happy in this situation?
	    ## Do we not want it to get upset?

	    exit 1 # to keep make happy
	fi
    fi
    ( cd ${BUILD_DIRECTORY} && rm -rf * )
fi

# Create output directory structure.
#
mkdir -p ${BUILD_DIRECTORY}
mkdir -p ${GENERATED_FILES_DIRECTORY}
mkdir -p ${GENERATED_FILES_DIRECTORY}/instructionFormats
mkdir -p ${SCRATCH_DIRECTORY}
mkdir -p ${CLASSES_DIRECTORY}

echo -n "(directories created) "

# Create control files and scripts.
#
PERM=+r+w

echo "configuration name: ${CONFIGURATION_NAME}"             >${CONFIGURATION_SUMMARY}
echo "preprocessor definitions:"                          >>${CONFIGURATION_SUMMARY}
for p in ${PREPROCESSOR_DEFINITIONS}; do echo -E ${p}; done   >>${CONFIGURATION_SUMMARY}
chmod ${PERM}                                                  ${CONFIGURATION_SUMMARY}

touch                          ${CLEANSE_STATUS}

emitSourceList                >${SOURCE_LIST}
chmod ${PERM}                    ${SOURCE_LIST}

emitController                >${BUILD_DIRECTORY}/jbuild
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild

emitExpander                  >${BUILD_DIRECTORY}/jbuild.expand
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.expand

emitCopier                    >${BUILD_DIRECTORY}/jbuild.copy
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.copy

emitCompiler                  >${BUILD_DIRECTORY}/jbuild.compile
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.compile

emitImageLinker               >${BUILD_DIRECTORY}/jbuild.linkImage
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.linkImage

emitBooterLinker              >${BUILD_DIRECTORY}/jbuild.linkBooter
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.linkBooter

emitToolCompiler              >${BUILD_DIRECTORY}/jbuild.tool
chmod +x${PERM}                  ${BUILD_DIRECTORY}/jbuild.tool

emitToolPreprocessor          >$BUILD_DIRECTORY/jbuild.toolPrep
chmod +x$PERM                  $BUILD_DIRECTORY/jbuild.toolPrep

emitPluginBuilder             >$BUILD_DIRECTORY/jbuild.plugin
chmod +x$PERM                  $BUILD_DIRECTORY/jbuild.plugin

# write the environment specific configuration files
#

# read the host environment file
. ${RVM_HOST_CONFIG}
export CURRENT_CONFIG_FILE=${RVM_HOST_CONFIG}
emitMakefile	      	      >${BUILD_DIRECTORY}/jbuild.Make.rules
chmod -x${PERM}		      ${BUILD_DIRECTORY}/jbuild.Make.rules

emitEnvironmentBash	      >${BUILD_DIRECTORY}/jbuild.environment
chmod -x${PERM}		      ${BUILD_DIRECTORY}/jbuild.environment

# read the target environment file
. ${RVM_TARGET_CONFIG}
export CURRENT_CONFIG_FILE=${RVM_TARGET_CONFIG}
# echo -n  >&2 "About to run emitMakefile"... # DBG
emitMakefile		      >${BUILD_DIRECTORY}/Make.rules
# echo >&2 "Ran emitMakefile"	# DBG

# echo -n >&2 "About to run chmod -x${PERM} ${BUILD_DIRECTORY}/Make.rules"... # DBG
chmod -x${PERM}		      ${BUILD_DIRECTORY}/Make.rules
# echo >&2 "Ran chmod."		# DBG

emitBoilerplate		      >${BUILD_DIRECTORY}/boilerplate.bash
chmod -x${PERM}		      ${BUILD_DIRECTORY}/boilerplate.bash

emit_enable_exit_on_error     > ${BUILD_DIRECTORY}/enable_exit_on_error
chmod -x${PERM}		      ${BUILD_DIRECTORY}/enable_exit_on_error

emit_disable_exit_on_error    > ${BUILD_DIRECTORY}/disable_exit_on_error
chmod -x${PERM}		      ${BUILD_DIRECTORY}/disable_exit_on_error

emitEnvironmentBash	      >${BUILD_DIRECTORY}/environment
chmod -x${PERM}		      ${BUILD_DIRECTORY}/environment

emitEnvironmentPerl	      >${BUILD_DIRECTORY}/environment.pl
chmod -x${PERM}		      ${BUILD_DIRECTORY}/environment.pl

# write the GNU Classpath security properties file
#
mkdir -p ${BUILD_DIRECTORY}/security
echo "security.provider.1=gnu.java.security.provider.Gnu" > ${BUILD_DIRECTORY}/security/JikesRVM.security
chmod -x${PERM} ${BUILD_DIRECTORY}/security/JikesRVM.security

echo "(control files and scripts installed) "

if [[ ${quiet} != 1 ]]; then
    if [ -t 0 ]; then # keyboard is live (ie. this is not an automated build)
	echo "${ME}: ${CONFIGURATION_NAME} configuration is ready"
	echo "${ME}: To build it, type:"
	echo "${ME}:    cd ${BUILD_DIRECTORY}"
	echo "${ME}:    ./jbuild"
	echo "${ME}: To execute it (from any directory) type:"
	echo "${ME}:    rvm <vm-args> classname <application-args>"
    fi
fi
trap '' EXIT
