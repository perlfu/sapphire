#! /bin/bash
#
# (C) Copyright IBM Corp. 2001, 2003
#
#$Id$
#
# Generate control files necessary to build a particular "configuration"
# of the Research Virtual Machine.
#
# See the usage message below, in section 1, the def. of function 
# help_message.  It gives much more information than is in this header comment.
#
# This script is organized into seven sections:
#    0 - Setup
#    1 - Documentation
#    2 - Definitions of constants
#    3 - Process RVM_TARGET_CONFIG
#    4 - ARGUMENT PARSING
#    5 - Definitions of functions
#    6 - Mainline Code that does the work
#
# @author Derek Lieber
# @date   19 Jan 2000
# @author Steven Augart (Bash version)
# @date 17 May 2003

## Exit statuses:

## We exit with status 0 upon success, as is conventional.
## In case of trouble, we exit with the triggering exit status (if invoked via 'set -e'.
## Exit status 33: Invalid arguments.
declare -r -i Exit_Status_Bad_Args=33
## Exit status 2: trouble (configuration, etc.)
## Exit status 1: misc. complaints.
##
## Exit status 111: The master "jbuild" script (generated by jconfigure) uses
## exit status "111" to mean that it has gone as far as it could with a
## cross-platform build, and that the target itself now needs to 
## run the linker.
declare -r -i Exit_Status_Run_Linker=111

#----------------------#
# SECTION 0 - Setup    #
#----------------------#

# What is our name?
# Bash internal shorthand that works like the "basename" command.
ME="${0##*/}"

# Where are we?
# Bash internal shorthand that works like the "dirname" command.
mydir="${0%/*}"			# temporary; directory we were run from

if [[ $mydir && $mydir != $ME ]]; then
    # Where to find auxiliary programs:
    bin_dir="${mydir}"
else
    bin_dir="${RVM_ROOT:?$ME: You must set the RVM_ROOT variable before you run this program.}/rvm/bin"
fi

# Stop immediately if any programs we call return errors.
#
## Check if the command does not support the ERR trap.
if trap '' ERR 2> /dev/null; then
    declare -i have_err_trap=1
else
    declare -i have_err_trap=0
fi
CLEANUP=":"
unset xited || :
if trap -- 'xited=$? finalarg=$_; set +vx; echo >&2 "$ME:$LINENO: some command we just ran (probably with a
      final argument of \"$finalarg\") exited with status $xited, possibly in source
      file line # $LINENO ${FUNCNAME+'"'"'and function '"'"'}$FUNCNAME
      I give up; aborting execution."; trap "echo >&2 \"Exiting due to an error\"" EXIT; eval $CLEANUP' ERR
then
    have_err_trap=1
else
    echo >&2 "$ME: You are under a version of Bash 
    ($BASH_VERSION; probably pre-2.05) that
    does not support
    the ERR trap.  You may not get as much diagnostic info as you would like."
    unset have_err_trap || :
fi

trap -- 'echo >&2 "$ME:$LINENO: We are exiting due to an error; the triggering exit status was ${xited:-$?}.
   possibly in source file line # $LINENO and function $FUNCNAME
"; eval $CLEANUP' EXIT
set -e;

function croak_nonusage () {
    # Display the error message.  If it's a multi-line error message, indent
    # the second and subsequent lines by a few spaces.  
    # Try to auto-wrap the message if we have GNU Fold.

    local gnufold="/usr/bin/fold --width=65 --spaces"
    $gnufold < /dev/null &> /dev/null || gnufold=cat

    echo "${ME}: $*" | $gnufold | sed -e '2,$s/^/     /' >&2
    trap '' EXIT
    exit 2
}

sanity_env="${bin_dir}/sanity-envars.bash"
[[ -f $sanity_env ]] || croak_nonusage "Internal error: Cannot find the file sanity-envars.bash ($sanity_env); something is badly broken."
[[ -r $sanity_env ]] || croak_nonusage "Internal error: Cannot read the file sanity-envars.bash ($sanity_env); something is badly broken.  You might check the file permissions or user id you used to extract Jikes RVM."
. "${sanity_env}";		# Defines checkenv()

## Place where source files reside.
checkenv RVM_ROOT

## Place where RVM bootimage, booter, and runtime support files will be placed.
checkenv --may-not-exist RVM_BUILD
## What configuration will host the build process?
checkenv RVM_HOST_CONFIG
## What configuration will run the system?
checkenv RVM_TARGET_CONFIG

#---------------------------#
# SECTION 1 - DOCUMENTATION #
#---------------------------#

function help_message () {

    # If PAGER is not set, set it to "more".
    ${PAGER=more} <<- EOF
	Usage: ${ME} [-nocleanse | -cleanse ] [-quiet]
	         [-D <variable>=<value>]... <configuration-name>
	Usage: ${ME} -help

	This script generates control files necessary to build a
	particular "configuration" of the Research Virtual Machine.
	
	Normally it is invoked as:
	
	   $ME <configuration-name>
	
	Where <configuration-name> indicates the configuration to be
	created and an environment variable, \$RVM_BUILD, specifies a
	directory where files comprising the configuration are to be
	placed.
	
	We normally do not request warnings from the C, C++, and Java
	compilers.  If you want to see C and/or C++ warnings, set the
	CFLAGS and/or CXXFLAGS environment variable before you invoke
	"jconfigure" and while running "jbuild".  You can also enable
	these by setting CC to "gcc -g \$CFLAGS" and CPLUS to "g++ -g
	\$CXXFLAGS" in your RVM_TARGET_CONFIG and RVM_HOST_CONFIG
	files.

	You can invoke this script as "${ME} < /dev/null" in order to
	suppress interactive questions.

	This script creates the \$RVM_BUILD directory and populates it
	with a skeleton directory structure along with some scripts
	and control files.

	After running this script, you can build an RVM executable by typing:
	
	    cd \$RVM_BUILD
	    ./jbuild
	
	Your \$RVM_ROOT tree will be template-expanded,
	macro-processed, compiled, and linked into a bootimage.  The
	processed sources, class files, bootimage, and booter will be
	placed into the \$RVM_BUILD directory.
	
	To execute the resulting bootimage (from any directory), type:
	
	   rvm <vm-flags> classname <application-args>
	
	Later, if you make changes to your \$RVM_ROOT tree, type
	"jbuild" again.  Modified source files will be discovered,
	copied to the build directory, recompiled, and the bootimage
	will be rebuilt.
	
	Special Cases when running "jbuild"
	===================================
	
	To avoid unnecessarily rebuilding the bootimage (when, for
	example, you've only modified classes that are dynamically
	loaded and which are not part of the bootimage) type "jbuild
	-nolink".
	
	To avoid building the booter (when, for example, running on
	the AIX side of an AIX/Linux cross-compilation) type "jbuild
	-nobooter".
	
	To build only the booter (when, for example, running on Linux
	side of a cross-port to Linux) type "jbuild -booter".
	
	To force recompilation of all classes (when, for example,
	you've modified a global constant or have added/removed
	fields/methods from a class) type "jbuild -recompile".
	
	To restore the build directory to its original "unbuilt" state
	type "jbuild -clean".
	
	To monitor the build process in more detail type "jbuild
	-trace".  "jbuild -help" will print the suboptions to
	"-trace", and may also print information about other options
	to jbuild.
	
	To monitor the build in even more detail, "jbuild" will pass
	on the flag "-demographics" to the boot image writer.  This
	makes the boot image writer display a summary of how the boot
	image's space is used up.

	If you want to pass additional options to the boot compiler
	(the compiler used when the Boot Image Writer compiles the
	boot image), then you can set these at configuration time by
	running "jconfigure" with the OPT_ARGS variable set, like so:

	     -DOPT_ARGS="-X:bc:opt1=val1 -Xbc:opt2=val2..."

	You can also set boot compiler options at build time by
	setting the environment variable DEBUG_ARGS, like so:

	     export DEBUG_ARGS="-X:bc:opt3=val3 -Xbc:opt4=val4..."
	or:
	     setenv DEBUG_ARGS "-X:bc:opt3=val3 -Xbc:opt4=val4..."

	before you invoke "jbuild".

	EOF
}
   
#--------------------------------------#
# SECTION 2 - DEFINITIONS OF CONSTANTS #
#--------------------------------------#


# The places to put scripts and control files. 

# (The *_STR variants of these variables have their variables expanded
# when the emitted script is executed, rather than being expanded prior to
# emitting the script.  This gives the scripts a degree of location
# transparency.  The _STR1 variables are similar to the _STR variables, 
# but are used to produce the localization script.  They lack the '$' )

BUILD_DIRECTORY="$RVM_BUILD"
BUILD_DIRECTORY_STR1="JAL_BUILD"
BUILD_DIRECTORY_STR="\$$BUILD_DIRECTORY_STR1"

ROOT_DIRECTORY="$RVM_ROOT"
ROOT_DIRECTORY_STR1="JAL_ROOT"
ROOT_DIRECTORY_STR="\$$ROOT_DIRECTORY_STR1"

# source path for configuration files 
# eg, BaseBaseSemispace
#
CONFIGURATION_FILE_SOURCE="$ROOT_DIRECTORY/rvm/config/build"

# Place to remember what configuration we've built.
#
CONFIGURATION_SUMMARY="$BUILD_DIRECTORY/RVM.configuration"

# Place to keep list of source directories to be scanned by preprocessor.
#
SOURCE_LIST="$BUILD_DIRECTORY/RVM.sources"
SOURCE_LIST_STR="$BUILD_DIRECTORY_STR/RVM.sources"

# Place to remember, if a cleansing pass should precede the build.
#
CLEANSE_STATUS="${BUILD_DIRECTORY}/RVM.cleanseRequired"
CLEANSE_STATUS_STR="${BUILD_DIRECTORY_STR}/RVM.cleanseRequired"

# Place to remember if preprocessor has yielded new/modified source files.
#
CLASSES_INVALID="${BUILD_DIRECTORY}/RVM.classesInvalid"
CLASSES_INVALID_STR="${BUILD_DIRECTORY_STR}/RVM.classesInvalid"

# Place to put preprocessed .java files and compiled .class files.
#
CLASSES_DIRECTORY="${BUILD_DIRECTORY}/RVM.classes"
CLASSES_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.classes"

# Place to put source files that are machine generated.
#
GENERATED_FILES_DIRECTORY="${BUILD_DIRECTORY}/RVM.generatedSources"
GENERATED_FILES_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.generatedSources"
   
# Place to put compiled versions of build tools and other glop
# generated during the build process.
#
SCRATCH_DIRECTORY="${BUILD_DIRECTORY}/RVM.scratch"
SCRATCH_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.scratch"

# Place to put the debugger, and other such tools.
#
TOOL_DIRECTORY="${BUILD_DIRECTORY}/RVM.tools"
TOOL_DIRECTORY_STR="${BUILD_DIRECTORY_STR}/RVM.tools"

# Place to keep list of classes comprising the bootimage.
#
PRIMORDIAL_CLASSES="${BUILD_DIRECTORY}/RVM.primordials"
PRIMORDIAL_CLASSES_STR="${BUILD_DIRECTORY_STR}/RVM.primordials"

# Place to keep list of .class files to be excluded from bootimage.
#
EXCLUDED_CLASSES="${BUILD_DIRECTORY}/RVM.exclusions"
EXCLUDED_CLASSES_STR="${BUILD_DIRECTORY_STR}/RVM.exclusions"

# Place to put bootimage.
#
BOOTIMAGE="${BUILD_DIRECTORY}/RVM.image"
BOOTIMAGE_STR="${BUILD_DIRECTORY_STR}/RVM.image"

# Place to put bootimage map.
#
BOOTIMAGE_MAP=${BUILD_DIRECTORY}/RVM.map
BOOTIMAGE_MAP_STR=${BUILD_DIRECTORY_STR}/RVM.map

# Place to put booter.
#
BOOTER=${BUILD_DIRECTORY}/JikesRVM
BOOTER_STR=${BUILD_DIRECTORY_STR}/JikesRVM

# Variables to allow configuration files to alter the list of
# directories, primordials, exclusions and top level sources.
#
CONF_SPECIFIC_SOURCES_LIST=""
CONF_SPECIFIC_PRIMORDIALS_LIST=""
CONF_SPECIFIC_EXCLUSIONS_LIST=""
CONF_SPECIFIC_TOP_LEVEL_SOURCES=""

# Strings to use in the scripts as the locations of various commands.
#
HOST_JIKES_STR1="HOST_JIKES"
HOST_JIKES_STR="\$$HOST_JIKES_STR1"
HOST_JAVA_STR1="HOST_JAVA_RT"
HOST_JAVA_STR="\$$HOST_JAVA_STR1"
HOST_JAVAC_STR1="HOST_JAVAC"
HOST_JAVAC_STR="\$$HOST_JAVAC_STR1"
HOST_JAVA_HOME_STR1="HOST_JAVA_HOME"
HOST_JAVA_HOME="\$$HOST_JAVA_HOME_STR1"
HOST_JAVADOC_STR1="HOST_JAVADOC"
HOST_JAVADOC_STR="\$$HOST_JAVADOC_STR1"
HOST_JAR_STR1="HOST_JAR"
HOST_JAR_STR="\$$HOST_JAR_STR1"
HOST_REPOSITORIES_STR1="HOST_JAVA_REPOSITORIES"
HOST_REPOSITORIES_STR="\$$HOST_REPOSITORIES_STR1"
HOST_TOOLS_STR1="HOST_JAVA_TOOLS"
HOST_TOOLS_STR="\$$HOST_TOOLS_STR1"
GNU_MAKE_STR1="GNU_MAKE"
GNU_MAKE_STR="\$$GNU_MAKE_STR1"
HOST_CC_STR1="CC"
HOST_CC_STR="\$$HOST_CC_STR1"
HOST_CPP_STR1="CPP"
HOST_CPP_STR="\$$HOST_CPP_STR1"
HOST_CPLUS_STR1="CPLUS"
HOST_CPLUS_STR="\$$HOST_CPLUS_STR1"
HOST_SHLD_STR1="HOST_SHLD"
HOST_SHLD_STR="\$$HOST_SHLD_STR1"

# Generate map of bootimage?
#
declare -x -i GENERATE_MAP=1

# Current version of RVM
JIKESRVM_VERSION="Jikes RVM 2.3.0.1"

# Default values for RunBootImage constants.
# Reasonable default values.
# To change the defaults for a paricular configuration, 
# redefine appropriate environment variables in the configuration's stanza.
#
DEFAULT_INITIAL_HEAP_SIZE=20   # in megabytes
DEFAULT_MAXIMUM_HEAP_SIZE=100  # in megabytes

# Here are the choices for target architecture.
#
declare -i RVM_FOR_POWERPC=0  # does not imply aix, nor Linux
declare -i RVM_FOR_IA32=0     # also implies linux

# Here are the choices for target operating system.
#
declare -i RVM_FOR_AIX=0	   # Implies PPC
declare -i RVM_FOR_LINUX=0	   # Implies nothing.

# 32-bit or 64-bit address size
#
declare -i RVM_FOR_32_ADDR=0
declare -i RVM_FOR_64_ADDR=0
 
# Here are the choices for compiler components and extensions.
# Note: baseline compiler is always built into bootimage: its presence is not controlled by any flags.
#
declare -i RVM_WITH_OPT_COMPILER=0
declare -i RVM_WITH_ADAPTIVE_SYSTEM=0 # superset of opt
declare -i RVM_WITH_OPT_TEST_HARNESS=0  # superset of opt, for test/debug via OptTestHarness class

# Include support for hardware performance monitors (HPM)
declare -i RVM_WITH_HPM=0

declare -x -i RVM_WITH_NON_BLOCKING_FDS_FOR_CLASSPATH=0

# Here are the choices for compiler to generate code for classes that are loaded into bootimage.
#
declare -i RVM_WITH_BASE_BOOTIMAGE_COMPILER=0
declare -i RVM_WITH_OPT_BOOTIMAGE_COMPILER=0

# Here are the choices for the object model
#
declare -i RVM_WITH_DEFAULT_OBJECT_MODEL=1
declare -i RVM_WITH_ONE_WORD_MASK_OBJECT_MODEL=0
declare -i RVM_WITH_ONE_WORD_PTR_OBJECT_MODEL=0
declare -i RVM_WITH_ONE_WORD_INDEX_OBJECT_MODEL=0

# Here are the choices for additional components that are under development and/or are excluded from default build.
#
declare -i RVM_FOR_SINGLE_VIRTUAL_PROCESSOR=0   # use pThread library to access multiple CPU's (or not)
declare -i RVM_WITH_DETERMINISTIC_THREAD_SWITCHING=0 # thread switch after n method calls, don't use interrupts to drive preemption
declare -i RVM_WITHOUT_PREEMPTIVE_THREAD_SWITCHING=0 # thread switch only at explicit yield and wait calls
declare -i RVM_WITH_ALL_CLASSES=0   # include all vm classes in bootimage, not just those needed for startup
declare -i RVM_WITHOUT_ASSERTIONS=0 # exclude runtime assertion checks
declare -i RVM_WITH_EXTREME_ASSERTIONS=0 # include extra assertion checking 
declare -i RVM_WITHOUT_AOS_LOG=0    # turn off AOS logging
declare -i RVM_WITH_NATIVE_DAEMON_PROCESSOR=0

#
# intercept blocking system calls (currently Linux-only)
#
declare -x -i RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS=0

# controls for diagnostic flags
declare -i RVM_FOR_STRESSGC=0

# using on stack replacement 
declare -i RVM_WITH_OSR=0


# These have preprocessor "//-#if" conditional directives that 
# test against them.   If we put the preprocessor into paranoid mode, it
# complains about any tests against undefined conditionals.
# Search for "BUILD_WITH_PARANOID_PREPROCESSOR" below and way below.
declare -i RVM_WITHOUT_LOAD_BALANCING=0	# default in VM_IdleThread.java
declare -i RVM_WITH_FREE_LOCK_BALANCING=0	# In VM_Lock.java
declare -i RVM_WITH_TENTATIVE_MICROLOCKING=0	
declare -i RVM_FOR_MCS_PROCESSOR_LOCKS=0
declare -i RVM_WITH_VARIABLE_LOCK_RETRY_LIMIT=0
declare -i RVM_WITH_LOCK_CONTENTION_TRACING=0
declare -i RVM_WITH_DEBUG=0

## Just affects the build process
declare -i BUILD_WITH_PARANOID_PREPROCESSOR=0

#---------------------------------------#
# SECTION 3 - PROCESS RVM_TARGET_CONFIG # 
#---------------------------------------#
# One use of the target_config file is to define
# directives that hold for all configurations 
# defined on the target. By sourcing it here,
# we define such directives for all configs on the target,
# but still allow them to be overridden on the command line
# or in a build-config file.
. "${RVM_TARGET_CONFIG}"


#--------------------------------------#
# SECTION 4 - ARGUMENT PARSING         #
#--------------------------------------#

function croak_usage () {
    # Display the error message.  If it's a multi-line error message, indent
    # the second and subsequent lines by a few spaces.
    echo "${ME}: $*" | sed -e '2,$s/^/     /' >&2
    echo >&2 "${ME}: Type \"${ME} -help\" for usage information."
    trap '' EXIT
    exit $Exit_Status_Bad_Args
}

declare -i quiet=0 cleanse=1
while :
do
    case "$1" in 
	-help|--help ) 
	    help_message;
	    trap '' EXIT
	    exit 0; ;;
	-D )
 	    shift
	    export "$1";;
	
	-D* )
	    arg="$1";
	    arg="${arg#-D}"	# trim off the leading -D
	    export "$arg" ;;
	
	-quiet|--quiet ) 
	    quiet=1;;

	-cleanse|--cleanse ) 
	    cleanse=1;;

	-nocleanse|--nocleanse ) 
	    cleanse=0;;

	-*)  croak_usage "I don't understand the flag \"$1\""
	    ;;

	--) shift;
	    break;
	    ;;
	* ) break;;
    esac

    shift
done

(( $# >= 1 )) || croak_usage "Please specify <configuration-name>"
CONFIGURATION_NAME="$1"
shift

(( $# == 0 )) || croak_usage "Too many arguments; specify only one <configuration-name>."


if [[ -f "${CONFIGURATION_FILE_SOURCE}/${CONFIGURATION_NAME}" ]]; then
    . "${CONFIGURATION_FILE_SOURCE}/${CONFIGURATION_NAME}" "${CONFIGURATION_FILE_SOURCE}"
else
    croak_usage "Unknown configuration ${CONFIGURATION_NAME}"
fi

# set the relative path to the object model.
if (( RVM_WITH_ONE_WORD_MASK_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordMaskTIB
elif (( RVM_WITH_ONE_WORD_PTR_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordTIBPtr
elif (( RVM_WITH_ONE_WORD_INDEX_OBJECT_MODEL )); then
    OBJECT_MODEL_PATH_STR=objectModel/oneWordIndexTIB
else
    OBJECT_MODEL_PATH_STR=objectModel/default
fi


if (( RVM_FOR_AIX || RVM_FOR_SINGLE_VIRTUAL_PROCESSOR == 1 )); then
    RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS=1
fi

## Setting PREPROCESSOR_DEFINITIONS:
## We keep this variable with a newline-separated list of definitions.
# Convert configuration choices into preprocessor definitions.
#    RVM_FOR_xxx  --> -DRVM_FOR_xxx
#    RVM_WITH_xxx --> -DRVM_WITH_xxx
#    RVM_WITHOUT_xxx --> -DRVM_WITH_xxx
#
## To find out which programmable conditions are still alive (i.e., which ones
## are currently in use in the program source code), look at 
## rvm/GNUmakefile, the 'conditionals' target.  
## The BUILD_WITH_PARANOID_PREPROCESSOR directive affects this.
PREPROCESSOR_DEFINITIONS="-DBOOTIMAGE_LOAD_ADDRESS=${BOOTIMAGE_LOAD_ADDRESS}"
PREPROCESSOR_DEFINITIONS="${PREPROCESSOR_DEFINITIONS}
-DMAXIMUM_MAPPABLE_ADDRESS=${MAXIMUM_MAPPABLE_ADDRESS}"
CLEANUP='/bin/rm -f $tmpf'	# used by EXIT trap.
tmpf=/tmp/jconfigure.$$
set | sed -n -e 's/^RVM_FOR_/-DRVM_FOR_/p' \
		-e 's/^RVM_WITH_/-DRVM_WITH_/p'			\
		-e 's/RVM_WITHOUT_/-DRVM_WITHOUT_/p' > $tmpf
if (( BUILD_WITH_PARANOID_PREPROCESSOR )); then
    from_vars="$(< $tmpf)"
else
    ## To cut down on the number of definitions that appear in our generated
    ## code, if we are not compiling with the paranoid preprocessor flags 
    ## enabled, we can remove all of the ones which just set to 
    ## the default value (zero) 
    from_vars="$(sed -e '/=0/d' $tmpf)"
fi
eval $CLEANUP
# rm -f $tmpf
CLEANUP=":"
# echo "from_vars are $from_vars"
PREPROCESSOR_DEFINITIONS="${PREPROCESSOR_DEFINITIONS}
${from_vars}"
unset from_vars
# Place where bootimage runner lives.
#
if (( RVM_FOR_POWERPC )); then
    BOOTIMAGE_RUNNER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_SUBDIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner/powerPC"
    BOOTIMAGE_RUNNER_SUBDIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner/powerPC"
elif (( RVM_FOR_IA32 )); then
    BOOTIMAGE_RUNNER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner"
    BOOTIMAGE_RUNNER_SUBDIR="${RVM_ROOT}/rvm/src/tools/bootImageRunner/IA32"
    BOOTIMAGE_RUNNER_SUBDIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageRunner/IA32"
else
    echo >&2 "$ME: Trouble is looming; neither RVM_FOR_POWERPC nor RVM_FOR_IA32 is defined."
    BOOTIMAGE_RUNNER_DIR="UNKNOWN_BOOTIMAGE_RUNNER_DIRECTORY"
    BOOTIMAGE_RUNNER_DIR_STR="UNKNOWN_BOOTIMAGE_RUNNER_DIRECTORY"
fi

# Place where bootimage writer lives.
#
BOOTIMAGE_WRITER_DIR="${RVM_ROOT}/rvm/src/tools/bootImageWriter"
BOOTIMAGE_WRITER_DIR_STR="${ROOT_DIRECTORY_STR}/rvm/src/tools/bootImageWriter"

#--------------------------------------#
# SECTION 5 - DEFINITIONS OF FUNCTIONS #
#--------------------------------------#

# Check configuration options for sanity.
function checkConfigurationOptions {
    if (( ! RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )) \
	&& (( RVM_WITH_NATIVE_DAEMON_PROCESSOR ))
    then
	croak_nonusage "\
If RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS is not specified,\
then RVM_WITH_NATIVE_DAEMON_PROCESSOR must not be specified";
    fi
}

# Emit list of source tree directories whose java files comprise the current configuration.
#
function emitSourceList () {
    if (( RVM_FOR_POWERPC )); then
	ARCH_DIR="powerPC"
    elif (( RVM_FOR_IA32 )); then
	ARCH_DIR="intel"
    else
	ARCH_DIR="UNSPECIFIED_ARCHITECTURE"
    fi
   
    # Common components.
    #
    sed -e 's/[ 	]*#.*//' -e '/^$/d' <<- EOF
	$RVM_ROOT/rvm/src/vm
	$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR
	$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/runtime
	$RVM_ROOT/rvm/src/vm/classLoader
	$RVM_ROOT/rvm/src/vm/jni
	$RVM_ROOT/rvm/src/vm/runtime
	$RVM_ROOT/rvm/src/vm/scheduler
	$RVM_ROOT/rvm/src/vm/utility
	$RVM_ROOT/rvm/src/vm/verifier
	$RVM_ROOT/rvm/src/vm/compilers/compiledCode
    

	$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/jni

    # Baseline compiler components (always part of bootimage).
    #
	${RVM_ROOT}/rvm/src/vm/compilers/baseline           # architecture independent
	${RVM_ROOT}/rvm/src/vm/compilers/baseline/GCMap     # architecture independent
	${RVM_ROOT}/rvm/src/vm/compilers/baseline/profiling # architecture independent

	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/baseline    # architecture dependent
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/baseline/GCMap
    	$( if [[ -e ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/assembler ]]; then
	    echo ${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/assembler # architecture dependent
    	fi)
    
	${RVM_ROOT}/rvm/src/vm/objectModel
	${RVM_ROOT}/rvm/src/vm/objectModel/lockNursery
	${RVM_ROOT}/rvm/src/vm/${OBJECT_MODEL_PATH_STR}

    # other components
    #
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/disassembler

EOF
    # Optimizing compiler components.
    #
    if (( RVM_WITH_OPT_COMPILER )); then
	# core components
	#
	sed -e 's/[ 	]*#.*//' -e '/^$/d' <<- EOF
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/driver
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/instrumentation
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/cfg
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/bc2hir
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/hir2lir
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/lir2mir
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/conversions/mir2mc
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/gcmap
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/instruction
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/instruction/operand
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/ir/util
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/control
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/control/dominators
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/coalesce
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/liveness
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/liveRangeSplitting
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/simpleSSA
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/simpleSSA/escape
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/abcd
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/builder
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/codePlacement
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/expressionFolding
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/gvn
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/loadElimination
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/redundantBranchElimination
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/global/ssa/storeElimination
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/inlining
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/specialization
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/ipa/summaries
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local/depGraph
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/optimizations/local/instructionScheduler
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/regalloc/linearScan
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/regalloc/util
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/dataflowUtil
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/exception
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis/vcg
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/graph/vis/dot
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/list
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/dotgraph
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/util/set
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/classLoader
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/classLoader/jikesrvm
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface/services
	${RVM_ROOT}/rvm/src/vm/compilers/optimizing/vmInterface

	# architecture-specific components
	#
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/instruction
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/instruction/operand
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/conversions/lir2mir
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/ir/conversions/mir2mc
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/regalloc
	${RVM_ROOT}/rvm/src/vm/arch/${ARCH_DIR}/compilers/optimizing/vmInterface/services
EOF
    fi

    # Adaptive compiler components.
    #
    if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
    sed -e 's/[ 	]*#.*//' -e '/^$/d' <<- EOF
	${RVM_ROOT}/rvm/src/vm/adaptive/controller
	${RVM_ROOT}/rvm/src/vm/adaptive/recompilation
	${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements
	${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/listeners
	${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/organizers
	${RVM_ROOT}/rvm/src/vm/adaptive/database
	${RVM_ROOT}/rvm/src/vm/adaptive/database/methodSamples
	${RVM_ROOT}/rvm/src/vm/adaptive/database/callGraph
	${RVM_ROOT}/rvm/src/vm/adaptive/recompilation/instrumentation
	${RVM_ROOT}/rvm/src/vm/adaptive/runtimeMeasurements/instrumentation
	${RVM_ROOT}/rvm/src/vm/adaptive/utility
EOF
    fi

    # On stack replacement components.
    #
    if (( RVM_WITH_OSR )); then
	sed -e 's/[ 	]*#.*//' -e '/^$/d' <<- EOF
	$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/executionState
	$RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/optCompilationWithOsr
	$RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/specialCompilation
	$RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/util
	$RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/executionState
	$RVM_ROOT/rvm/src/vm/adaptive/onStackReplacement/threadControls
EOF
    fi

    # architecture specific writebarrier support for baseline compilers
    #
    echo "$RVM_ROOT/rvm/src/vm/arch/$ARCH_DIR/compilers/baseline/writeBarrier"

    # Bootimage compiler components.
    #
    if (( ${RVM_WITH_BASE_BOOTIMAGE_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/bootImage/baseline
    elif (( ${RVM_WITH_OPT_BOOTIMAGE_COMPILER} )); then
	echo ${RVM_ROOT}/rvm/src/vm/compilers/harness/bootImage/optimizing
    fi

    sed -e 's/[ 	]*#.*//' -e '/^$/d' <<- EOF
    # Runtime compiler components.
    #
	${RVM_ROOT}/rvm/src/vm/compilers/harness/runtime

    # Common memory manager components.
    #
	$RVM_ROOT/rvm/src/vm/memoryManagers/JMTk
	$RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/vmInterface
	$RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/header
	$RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan
	$RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/policy
	$RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/utility
EOF
    # collector specific classes
    #
    if (( $RVM_WITH_SEMI_SPACE )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/semiSpace
    elif (( $RVM_WITH_MARK_SWEEP )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/markSweep
    elif (( $RVM_WITH_GEN_COPY )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genCopy
    elif (( $RVM_WITH_GEN_MS )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genMS
    elif (( $RVM_WITH_GEN_RC )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/genRC
    elif (( $RVM_WITH_COPY_MS )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/copyMS
    elif (( $RVM_WITH_REF_COUNT )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/refCount
    elif (( $RVM_WITH_NO_GC )); then
        echo $RVM_ROOT/rvm/src/vm/memoryManagers/JMTk/plan/noGC
    fi

    # standard library support
    #
    echo $RVM_ROOT/rvm/src/vm/libSupport
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang/ref
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/lang/reflect
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/net
    echo $RVM_ROOT/rvm/src/vm/libSupport/java/io

    # Add support for hardware performance monitors on PowerPC
    #
    if (( $RVM_WITH_HPM )); then
	echo $RVM_ROOT/rvm/src/vm/adaptive/runtimeMeasurements/hardwarePerformanceMonitors
    fi

    # Add the configuration specific directories
    #
    for dir in $CONF_SPECIFIC_SOURCES_LIST; do
        echo $RVM_ROOT/$dir
    done
}




## We only emit the boilerplate inline.
function emitBoilerplate () {
    cat <<- 'EOF'
	## BEGIN inline Bash boilerplate.
	# What is our name?
	# Bash internal shorthand that works like the "basename" command.
	ME="${0##*/}"
	EOF
    emit_enable_exit_on_error
	# tracing() takes 0 or 1 arguments.

	# The trace argument can be:
	# -trace		 (gets most things but skips the thousands of
        #			  lines of bootimagewriter output)
	# -trace=ant		# Just ant is of interest
	# -trace=jbuild		# high-level
	# 
	# This is then converted to:
	# TRACE_FLAG: (empty)  # only if nothing was said
	# TRACE_FLAG: ,no-all,
	# TRACE_FLAG: ,-trace,
	# We can be tracing any of the following
	#	preprocessor,make,BootImageWriter,ant,jbuild
	# As well as the groups:
	#	most,all
	# See the help message in "jbuild -help" for more info.

	# Returns true (exit 0) if we are tracing
	# Returns false (exit 1) if we are not.
    cat <<- 'EOF'
	function tracing() {
	    set +vx
	    # We go through some skulduggery here so that running jbuild
	    # with -v or -x won't generate lots of junk output.
	    [[ $TRACE_FLAG ]] || { [ ! "$VFLAG$XFLAG" ] || set $VFLAG $XFLAG ; return 1 ; }

	    local -i dflt=1      # default answer, false  (using exit codes)
	    # If $TRACE_FLAG is not in canonical form...
	    if [[ $TRACE_FLAG != ,*, ]]; then
	        # ...then canonicalize it.
	        if [[ $TRACE_FLAG = -trace ]]; then
	            TRACE_FLAG=,most,
	        elif [[ $TRACE_FLAG != -trace=* ]]; then
	            echo >&2 "${ME}: I don't understand the trace flag \"$TRACE_FLAG\"."
	            echo >&2 "${ME}: Aborting execution."
	            trap '' EXIT
	            kill $$
	        else	        # TRACE_FLAG has the form -trace=<something>
	            TRACE_FLAG=",${TRACE_FLAG#-trace=},";
	        fi
	        # No-all is a no-op, since we only 
	        # trace if it's explicitly requested.
	        TRACE_FLAG=${TRACE_FLAG/,no-most,/,no-all,}
	        TRACE_FLAG=${TRACE_FLAG/,most,/,preprocessor,make,no-BootImageWriter,ant,jbuild,}
	    fi
	    # TRACE_FLAG is now in canonical form.
	    if [[ $TRACE_FLAG == *,all,* ]]; then
	        dflt=0  # true
	    fi
	    if (( $# > 0 )); then
	        local arg="$1"
	        # If an exact match, return YES.
	        if [[ $TRACE_FLAG == *,${arg},* ]]; then
	            { [ ! "$VFLAG$XFLAG" ] || set $VFLAG $XFLAG ; return 0; }
	        # If an exact anti-match, return NO
	        elif [[ $TRACE_FLAG == *,no-${arg},* ]]; then
	            { [ ! "$VFLAG$XFLAG" ] || set $VFLAG $XFLAG ; return 1; }
	        fi
	    fi 
	    # Give in to the default, whatever that is.
	    { [ ! "$VFLAG$XFLAG" ] || set $VFLAG $XFLAG ; return $dflt; }
	}
	## END inline Bash boilerplate.
	EOF
}

function emit_disable_exit_on_error () {
    cat <<- 'EOF'
	## BEGIN disable_exit_on_error.
	EOF
    if (( have_err_trap )); then
	cat <<- 'EOF'
	# This has to be inline or a source'd file; the ERR trap is not
	# inherited by shell functions.
	# trap - ERR || echo >&2 "$ME: We do not have the ERR Trap in this shell.  Must be cross-configuring or something of the sort."
	trap - ERR 2> /dev/null || :
	EOF
    fi
    cat <<- 'EOF'
	set +e
	## END disable_exit_on_error.
EOF
}

function emit_enable_exit_on_error () {
    # This has to be inline or a source'd file; the ERR trap is not
    # inherited by shell functions.
    cat <<- 'EOF'
	## BEGIN enable_exit_on_error.
	EOF
    if (( have_err_trap )); then
	cat <<- 'EOF'
	if trap -- 'finalarg="$_" xited=$?; set +vx; echo >&2 "$ME:$LINENO: some command we just ran (probably with a
	      final argument of \"$finalarg\") exited with status $xited, possibly in source
	      file line # $LINENO${FUNCNAME+'"'"' and function '"'"'\"}$FUNCNAME${FUNCNAME+\"}
	      I give up; aborting execution."; trap "echo >&2 \"Exiting due to an error\"" EXIT' ERR
	then
	    declare -i have_err_trap=1
	else
# 	    echo >&2 "$ME: You are under a version of Bash 
# 	    ($BASH_VERSION; probably pre-2.05) that
# 	    does not support
# 	    the ERR trap.  You may not get as much diagnostic info as you would like."
# 	    unset have_err_trap || :
	    declare -i have_err_trap=0
	fi
	EOF
	if false; then
	    cat <<- 'EOF'
	trap 'echo >&2 "$ME: A command I just ran (probably with a final argument of "$_")
	   exited with status $?.  Something is broken; I give up."' ERR \
	  || echo >&2 "$ME: We do not have the ERR Trap in this shell.  Must be cross-configuring or something of the sort."
		EOF
	fi
    fi
    cat <<- 'EOF'
	set -e
	## END enable_exit_on_error
	EOF
}



# Emit script which sets all shell variables relative to the
# shadow and build directory
function emitEnvironmentBash () {
    # read the target environment file
    #
    echo '#! /bin/bash'
    echo '# Note: the above #! /bin/bash is there merely as documentation.'
    echo '# This file will not be run as a program directly, but rather sourced'
    echo '# by other routines.'
    echo ''
    echo '# Set the environment.'
    echo ""
    echo "# This file is generated by jconfigure from the configuration file"
    echo "# RVM_HOST_CONFIG ($RVM_HOST_CONFIG).  "
    echo "# You may edit this file, but"
    echo "# all your changes will be lost if jconfigure is executed again using"
    echo "# the current directory ($RVM_BUILD) as RVM_BUILD."
    echo ""
    echo "# This file was generated from the configuration file:"
    echo "#      $CURRENT_CONFIG_FILE"

    echo ""
    echo "export $BUILD_DIRECTORY_STR1=$RVM_BUILD"
    echo "export $ROOT_DIRECTORY_STR1=$RVM_ROOT"
    echo ""
    echo "export $HOST_JIKES_STR1=\"$JIKES\""
    echo "export $HOST_JAVA_STR1=\"$HOST_JAVA\""
    echo "export $HOST_JAVAC_STR1=\"$HOST_JAVAC\""
    echo "export $HOST_JAVA_HOME_STR1=\"$HOST_JAVA_HOME\""
    echo "export $HOST_JAVADOC_STR1=\"$HOST_JAVADOC\""
    echo "export $HOST_JAR_STR1=\"$HOST_JAR\""
    echo "export $HOST_REPOSITORIES_STR1=$HOST_REPOSITORIES"
    echo "export $HOST_TOOLS_STR1=$HOST_TOOLS"
    echo "export LD_LIBRARY_PATH=\"\$LD_LIBRARY_PATH:$HOST_JAVA_LD_LIBRARY_PATH\""
    echo ""
    echo "export $GNU_MAKE_STR1=$GNU_MAKE"
    echo ""
    echo "export $HOST_CC_STR1='$CC'"
    echo "export $HOST_CPLUS_STR1='$CPLUS'"
    echo "export $HOST_CPP_STR1='$CPP'"
    echo "export $HOST_SHLD_STR1='$LDSHARED'"
    echo ""
    echo "export AWK='$AWK'"  
    echo "export BASH='$BASH'"  
    echo "export CVS='$CVS'"  
    echo "export DIFF='$DIFF'"  
    echo "export FGREP='$FGREP'"
    echo "export FIND='$FIND'"
    echo "export GNU_TAR='$GNU_TAR'"  
    echo "export GREP='$GREP'"
    echo "export MD5SUM='$MD5SUM'"  
    echo "export PS='$PS'"  
    echo "export SED='$SED'"
    echo "export WGET='$WGET'"
    echo "export XARGS='$XARGS'"
    echo "export UNZIP_CMD='$UNZIP_CMD'"
    echo "export ANT_CMD='$ANT_CMD'"
    echo ""
    echo "export ECLIPSE_INSTALL_DIR='$ECLIPSE_INSTALL_DIR'"
    echo ""
    echo "export CLASSPATH_LIBRARIES=YES"
    if [[ $CLASSPATH_ROOT ]]; then
        echo "export CLASSPATH_ROOT=$CLASSPATH_ROOT"
    fi
    echo ""
}

#
# Emit Makefile
# 
function emitMakefile () {
    cat <<- EOF
        include $RVM_ROOT/rvm/Make.rules.generic

	# environment specific make rules
	
	# This file is generated by jconfigure according to values specified
	# in the configuration file RVM_HOST_CONFIG.  You may edit this file, but
	# all your changes will be lost if jconfigure is executed again using
	# the current directory as RVM_BUILD.
	
	# This file was generated from the configuration file:
	#      ${CURRENT_CONFIG_FILE}

	$BUILD_DIRECTORY_STR1 = $RVM_BUILD
	$ROOT_DIRECTORY_STR1 = $RVM_ROOT
	
	$HOST_JIKES_STR1 = $JIKES
	
	HOST_JAVA_HOME = $HOST_JAVA_HOME
	HOST_JAVA = $HOST_JAVA
	HOST_JAVAC = $HOST_JAVAC
	HOST_JAVADOC = $HOST_JAVADOC
	HOST_JAR = $HOST_JAR
	HOST_REPOSITORIES = $HOST_REPOSITORIES
	HOST_TOOLS = $HOST_TOOLS
	
	CC = $CC
	CPLUS = $CPLUS
	CXX = $CPLUS
	LDSHARED = $LDSHARED
	JNI_NATIVE_LIBS_LD = $JNI_NATIVE_LIBS_LD
	
	AWK= $AWK
	BASH = $BASH
	CVS = $CVS
	DIFF= $DIFF
	FGREP = $FGREP
	FIND = $FIND
	GNU_TAR = $GNU_TAR
	GREP = $GREP
	MD5SUM = $MD5SUM
	PS= $PS
	SED = $SED
	WGET = $WGET
	XARGS = $XARGS
	UNZIP_CMD = $UNZIP_CMD
	
	
	CLASSPATH_LIBRARIES = YES
	EOF
}


# Emit a script to run each phase of vm builder in turn.

function emitController () {
    cat <<- EOF
	#!/bin/bash

	# Run all phases of vm builder.

	$(emitBoilerplate)

	# timeit() \$1: The command to run
	#	   \$2: That command's arguments.

	# The old (until 2003 June) KSH script displayed
	# seconds of precision to three decimal places.  The
	# SECONDS variable in my version of Bash only returns
	# integers.

	function timeit () {
	    # We can either do some modifications to the output
	    # format, and use TIMEFORMAT instead of SECONDS...
	    # TIMEFORMAT="%3lR"
	    # time "\$@"		
	    # ...Or we can just deal.with integer seconds.  Since the SECONDS
	    # variable is cumulative, it is compatible with the way we used to
	    # do this.

	    # The --via-RUN-BUILD-COPY flag adds text to one of the 
	    # error messages and makes sure we don't run the remote command
	    # with \$TRACE, \$VFLAG, and \$XFLAG
	    declare -i via_RUN_BUILD_COPY=0
	    if [[ \$1 = --via-RUN-BUILD-COPY ]]; then
		let ++via_RUN_BUILD_COPY
		shift
	    fi	
	    # Disable exit-on-error; inside "timeit", we can get a better
	    # exit message than the default one.
    $(emit_disable_exit_on_error)
	    local cmd="\$1"
	    shift
	    if (( via_RUN_BUILD_COPY )); then
	        "\${cmd}" "\$@"
	    else
	        "\${cmd}" \$TRACE_FLAG \$VFLAG \$XFLAG "\$@"
	    fi
	    local status=\$?
    $(emit_enable_exit_on_error)
	    echo "\$SECONDS s"
	    if (( status == $Exit_Status_Run_Linker )); then
		echo >&2 "\$ME: You need to run the linker on the appropriate platform."
		trap '' EXIT
		exit $Exit_Status_Run_Linker
	    elif (( status != 0 )); then
		if (( via_RUN_BUILD_COPY )); then
		    echo >&2 "$ME: Possible difficulty with the remote command specified in RUN_BUILD_COPY:"
		fi
	        echo >&2 "\$ME: Trouble while running \"\$cmd \$*\" (exit status \$status); aborting execution"
	        trap '' EXIT
	        exit \$status;
	    fi
	    return \$status;	# will always return 0
	}

	VFLAG="" XFLAG="" DEMOGRAPHICS_FLAG="" CLEAN_FLAG="" RECOMPILE_FLAG="" NOLINK_FLAG="" BOOTER_FLAG="" NOBOOTER_FLAG=""
	while (( \$# > 0 )); do
	    arg="\$1"
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	       VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	       XFLAG=-x
	    elif [[ \$arg = -demographics ]]; then
	        DEMOGRAPHICS_FLAG=-demographics
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    elif [[ \$arg = -recompile ]]; then
	        RECOMPILE_FLAG=-recompile
	    elif [[ \$arg = -nolink ]]; then
	        NOLINK_FLAG=-nolink
	    elif [[ \$arg = -nobooter ]]; then
	        NOBOOTER_FLAG=-nobooter
	    elif [[ \$arg = -booter ]]; then
	        NOLINK_FLAG=-nolink
	        BOOTER_FLAG=-booter
	    else
	        echo >&2 \
	"Usage: \$ME [-trace[=<trace-opts>]] [-v] [-x] [-demographics] 
	          [-clean] [-recompile] [-nolink] [-nobooter] [-booter]

	   -trace: As if \"-trace=most\".  Some debugging information.
	
	   -trace=make:  Make is no longer run with --silent.  Make is run
	      with the -w option, which generates additional output useful for 
	      GNU Emacs's M-x compile mode.
	
	   -trace=ant:  Ant is no longer run with -quiet.
	
	   -trace=preprocessor: Follow the process of running the preprocessor 
	      on Java source code
	
	   -trace=BootImageWriter: Makes the Boot Image Writer send out lots of
	      information -- about 9420 lines in a BaseBaseCopyMS build.
	      (That's why "-trace" does not imply "-trace=BootImageWriter".)
	
	   -trace=jbuild:  Higher-level info as the build progresses.
	
	   -trace=most:   Same as -trace=all,no-BootImageWriter
	
	   -trace=all:   Everything.
	
	   "
	        echo >&2 \
       "   -v, -x: Turn on the -v and/or -x debugging flags in the subshells we spawn.
	   -nobooter: avoid building the booter (when, for example, running on
	      the AIX side of an AIX/Linux cross-compilation)

	   -booter:  Build only the booter (when, for example, running on
	      the Linux side of an AIX cross-build to Linux)

	   -nolink:  Avoid unnecessarily rebuilding the bootimage (when, 
	      for example, you've only modified classes that are dynamically 
	      loaded and which are not part of the bootimage)

	   -recompile:  Force recompilation of all classes (when, for example, 
	      you've modified a global constant or have added/removed
	      fields/methods from a class)

	   -clean:  Restore the build directory to its original unbuilt state

	There may be additional useful information not in this message
	that you can get by running \"jconfigure -help\"."

	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done

	cd $RVM_BUILD
	
	if [[ \$BOOTER_FLAG = -booter ]]; then
	  . ./environment.target
	else
	  . ./environment.host
	fi
	
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	# Ensure that we have the right version of the class libraries
	\$JAL_ROOT/rvm/bin/jBuildClasspathJar --check
	
	if [[ \$CLEAN_FLAG = -clean ]]; then
	    rm -rf \$TOOL_DIRECTORY_STR
	    timeit ./jbuild.expand      -clean
	    timeit ./jbuild.copy        -clean
	    timeit ./jbuild.compile     -clean
	    timeit ./jbuild.linkImage   \$DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter  -clean
	    trap '' EXIT
	    exit 0
	fi

	if [[ \$RECOMPILE_FLAG = -recompile ]]; then
	    timeit ./jbuild.compile -clean
	fi

	if [[ -e $CLEANSE_STATUS_STR ]]; then
	    rm -rf $TOOL_DIRECTORY_STR
	    timeit ./jbuild.expand     -clean
	    timeit ./jbuild.copy       -clean
	    timeit ./jbuild.compile    -clean
	    timeit ./jbuild.linkImage  \$DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter -clean
	    rm -f $CLEANSE_STATUS_STR
	elif [[ \$NOLINK_FLAG != -nolink ]]; then
	    timeit ./jbuild.linkImage  \$DEMOGRAPHICS_FLAG -clean
	    timeit ./jbuild.linkBooter -clean
	fi

	if [[ \$BOOTER_FLAG = -booter ]]; then
	    # Instead of running "jbuild.linkBooter", we can optionally
	    # run a command specified
	    # in the environment variable RUN_BUILD_COPY.
	    #
	    # For example, this variable could use rsh or ssh 
	    # to run the linkBooter command remotely on the target machine.
	    if [[ \$RUN_BUILD_COPY ]]; then
	         timeit --via-RUN-BUILD-COPY \$RUN_BUILD_COPY
	    else
	         timeit ./jbuild.linkBooter
	    fi
	else
	    timeit ./jbuild.expand 
	    timeit ./jbuild.copy   
	    timeit ./jbuild.compile
	    if [[ \$NOLINK_FLAG != -nolink ]]; then
	        timeit ./jbuild.linkImage  \$DEMOGRAPHICS_FLAG
	        if [[ \$NOBOOTER_FLAG != -nobooter ]]; then
		    if [[ \$RUN_BUILD_COPY ]]; then
			timeit --via-RUN-BUILD-COPY \$RUN_BUILD_COPY
		    else
			timeit  ./jbuild.linkBooter
		    fi
		fi
	    fi
	fi
	
	if [[ -x JikesRVM ]] && [[ -f JikesRVM ]]; then
	    echo "\${ME}: To execute the $CONFIGURATION_NAME RVM (from any directory) type:"
	    echo "\${ME}:    rvm <vm-args> classname <application-args>"
	    if ! type -p rvm > /dev/null; then
	        echo "${ME}: You will also need to add ${RVM_ROOT}/bin to your path"
	    fi
	fi
	EOF
}


# echo >&2  "HERE I AM! emitExpander" # DBG
# Emit script to generate VM source tree Java files that derive from templates.
# Taken:    .template files in source tree
# Returned: .java files in ${GENERATED_FILES_DIRECTORY}
#
function emitExpander () {
    cat <<- EOF
	#! /bin/bash
	# Generate VM sources that derive from templates.
	$(emitBoilerplate)
	. ./environment.host


	# Process command-line args   
	unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG || :
	MFLAGS=--silent
	while (( \$# > 0 )); do
	    arg="\$1"
	    [[ \$arg != --?* ]] || arg=\${arg#-}
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
		trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done
	if tracing make; then
	    MFLAGS=-w
	fi

	echo -n "\${ME}: "

#	! tracing jbuild || XFLAG=-x
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	if [[ \$CLEAN_FLAG ]]; then
	    rm -rf ${SCRATCH_DIRECTORY_STR}
	    mkdir -p ${SCRATCH_DIRECTORY_STR}/com/ibm/JikesRVM
	    cd ${GENERATED_FILES_DIRECTORY_STR}
	    echo *.* | \$XARGS -r rm -f
	EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	cat <<- EOF
	    cd ${GENERATED_FILES_DIRECTORY_STR}/instructionFormats
	    echo *.* | \$XARGS -r rm -f
	EOF
    fi
    cat <<- EOF

	    echo -n "(templates cleaned) "
	    trap '' EXIT
	    exit 0
	fi
	# Make the tools that we need to do template expansion
	${GNU_MAKE_STR} \${MFLAGS} -C "${ROOT_DIRECTORY_STR}/rvm/src/tools/templateExpander" tool SCRATCH_DIR="${SCRATCH_DIRECTORY_STR}"
EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	echo "
declare -a cmd
cmd=(${GNU_MAKE_STR} \${MFLAGS} -f ${ROOT_DIRECTORY_STR}/rvm/src/tools/jburg/Makefile -C ${SCRATCH_DIRECTORY_STR} VPATH=${ROOT_DIRECTORY_STR}/rvm/src/tools/jburg tool)
! tracing make || echo \"\${cmd[@]}\"
\"\${cmd[@]}\"
"
    fi

    # build command line options for core VM
    echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/utility MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    
    # build command line options for JMTk
    echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/memoryManagers/JMTk/utility MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    
    # build VM_Assembler on Intel
    if (( RVM_FOR_IA32 )); then
	echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/assembler GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR}"
	if (( RVM_WITH_OPT_COMPILER )); then
	echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/compilers/optimizing/ir/conversions/mir2mc GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR}"
	fi
    fi

    # Do the expansion
    echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/classLoader MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR}

${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/baseline MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"

    if (( RVM_WITH_OPT_COMPILER )); then
	echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/optimizing MakeTemplates ARCH_DIR=${ARCH_DIR} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
	if (( RVM_WITH_EXTREME_ASSERTIONS )); then
	    echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/compilers/optimizing/ir/instruction fatalInstructionFormat ARCH_DIR=${ARCH_DIR} GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
	fi
    fi
    if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	echo "\
${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/vm/adaptive MakeTemplates GEN_FILES_DIR=${GENERATED_FILES_DIRECTORY_STR} SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    fi
    
    echo '
if tracing jbuild; then
    echo ""
fi
';
}


# Emit script to copy/preprocess VM Java files from source tree to 
# build directory.
# Taken:    .java files in source tree
# Returned: .java files in build directory
#
# echo >&2  "HERE I AM! emitCopier" # DBG
function emitCopier () {
    if (( BUILD_WITH_PARANOID_PREPROCESSOR )); then
	PARANOID_PREPROCESSOR_FLAG=" --no-undefined-constants-in-conditions"
    fi
    cat <<- EOF
	#! /bin/bash
	# Copy or preprocess VM Java files from the source tree to 
	# the build directory.
	# Taken:    .java files in the source tree
	# Returned: .java files in the build directory

	$(emitBoilerplate)
	. ./environment.host
	

	# Process command-line args   
	unset TRACE_FLAG  VFLAG XFLAG CLEAN_FLAG || :
	MFLAGS=--silent
	while (( \$# > 0 )); do
	    arg="\$1"
	    if [[ \$arg = -- ]]; then
	        shift		# The end of the flag arguments
	        break;
	    fi
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done

	if tracing make; then
	    MFLAGS=-w
	fi
	echo -n "\${ME}: "

	if [[ \$CLEAN_FLAG ]]; then
	    if tracing jbuild; then
		echo " (nuking .java files in ${CLASSES_DIRECTORY_STR})"
	    fi
	    find ${CLASSES_DIRECTORY_STR} -name "*.java" -exec rm {} \;
	    echo "This file indicates that some or all classes need to be recompiled" > ${CLASSES_INVALID_STR}
	    echo -n "(sources cleaned) "
	    trap '' EXIT
	    exit 0
	fi
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	# Make the preprocessor
	${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/tools/preprocessor INCLUDED_MAKEFILE=${BUILD_DIRECTORY_STR}/Make.rules.host tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}
	cp ${SCRATCH_DIRECTORY_STR}/preprocessModifiedFiles ${BUILD_DIRECTORY_STR}/jbuild.prep.host
	echo -n '(preprocessor built) '

	# This may be reset in the loop below.
	FILES_HAVE_CHANGED=0

	# Update from directories containing sources that implement the virtual machine.
	#
	PREPROC_FLAGS="--only-boolean-constants-in-conditions ${PARANOID_PREPROCESSOR_FLAG}"
	if tracing preprocessor; then
	    PREPROC_FLAGS="-trace \$PREPROC_FLAGS"
	fi
	for d in \$(< ${SOURCE_LIST_STR} ); do
	    if tracing preprocessor; then
	         echo -n "\${ME}: expanding \${d}..."
	    fi
	    shopt -s nullglob
	    # FILES may be empty.
	    FILES="\$(echo \${d}/*.java)"
EOF
    emit_disable_exit_on_error
    ## Approach abandoned because xargs will exit with status 123
    ## upon nonzero exit status from jbuild.prep.host, but 
    ## jbuild.prep.host will exit with status 1 when files are modified.
    ## So, all the non-zero return values get mapped to 123, and we 
    ## want to distinguish 1 (OK) 
    ## from other non-zero return values (trouble).
    # The odd code below with $(echo  ...) is because 
    # we need to turn the PREPROCESSOR_DEFINITIONS from a 
    # newline-separated list to a space-separated list.
    # echo \$FILES | \$XARGS -r ${BUILD_DIRECTORY_STR}/jbuild.prep.host \${PREPROC_FLAGS} $(echo ${PREPROCESSOR_DEFINITIONS}) ${CLASSES_DIRECTORY_STR} 

    cat <<- EOF

	    if [[ ! \$FILES ]]; then
	        continue;
	    fi
	    ${BUILD_DIRECTORY_STR}/jbuild.prep.host \${PREPROC_TRACE_FLAG} $(echo ${PREPROCESSOR_DEFINITIONS}) ${CLASSES_DIRECTORY_STR} \$FILES 
	    status=\$?
EOF
    emit_enable_exit_on_error
    echo '
    if (( status == 1 )); then
	FILES_HAVE_CHANGED=1
    elif (( status != 0 )); then
	echo >&2 "$ME: Trouble while running jbuild.prep.host (exit status ${status}).
    Aborting execution."
	trap "" EXIT
	exit $status
    fi
    if tracing preprocessor; then
	echo ""
    fi
done

# Update from directories containing machine generated source files
# Do this after we copy the "normal" files to allow us to
# overwrite any dummy versions of the files we have sitting
# around in the shadow (telling people that the file is generated).
if tracing preprocessor; then
    echo -n "${ME}: '${GENERATED_FILES_DIRECTORY_STR}'/"
fi
FILES=$(${FIND} '${GENERATED_FILES_DIRECTORY_STR}'/ -name "*.java")'
    emit_disable_exit_on_error
    ## See above comment on xargs.
    # echo 'echo $FILES | $XARGS -r '${BUILD_DIRECTORY_STR}'/jbuild.prep.host ${PREPROC_TRACE_FLAG}' ${PREPROCESSOR_DEFINITIONS} ${CLASSES_DIRECTORY_STR}'
    echo ${BUILD_DIRECTORY_STR}/jbuild.prep.host "\${PREPROC_TRACE_FLAG}" ${PREPROCESSOR_DEFINITIONS} ${CLASSES_DIRECTORY_STR} "\${FILES}"
    echo 'status=$?'
    emit_enable_exit_on_error
    echo '
if [[ ${status} = 1 ]]; then
    FILES_HAVE_CHANGED=1
elif [[ ${status} != 0 ]]; then
    echo >&2 "$ME: Trouble while running jbuild.prep.host (exit status ${status}); aborting execution."
    trap '' EXIT
    exit ${status}
fi
if tracing preprocessor; then
    echo ""
fi'

    # copy classpath jar file
    if ! [[ $CLASSPATH_ROOT ]]; then
	CPS="$RVM_ROOT/classpath"
    else
	CPS="${CLASSPATH_ROOT}"
    fi
    echo '
SYSTEM_TYPE=$('$CPS'/classpath/config.guess)
cp -f '$CPS'/$SYSTEM_TYPE/lib/glibj.zip '${CLASSES_DIRECTORY_STR}'/rvmrt.jar

echo -n "(classpath.jar copied) "

# Remember if any new (or modified) source files were discovered.
#
if [[ ${FILES_HAVE_CHANGED} = 1 ]]; then
    touch' ${CLASSES_INVALID_STR} '
fi'
}
    

# Emit script to generate VM class files from Java files.
# Taken:    .java files in build directory 
#            CLASSES_INVALID
# Returned: .class files in build directory
#
# echo >&2  "HERE I AM! emitCompiler" # DBG

function emitCompiler () {
    cat <<- 'EOF'
	#! /bin/bash
	# Generate VM class files from Java files.
	# Taken:    .java files in build directory 
	#            CLASSES_INVALID
	# Returned: .class files in build directory
EOF
    emitBoilerplate;
    cat <<- EOF
	. ./environment.host


	unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG || :
	while (( \$# > 0 )); do
	    arg="\$1"
	    if [[ \$arg = -- ]]; then
	        shift		# The end of the flag arguments
	        break;
	    fi
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
		TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done

	echo -n "\${ME}: "
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG

	if [[ \$CLEAN_FLAG ]]; then
	    cd ${CLASSES_DIRECTORY_STR}
	    # This avoids any limits on the size of the command-line arguments.
	    # 'echo' is a bash builtin, and as such is unaffected by such O/S 
	    # limits. 
	    echo *.class | \$XARGS -r rm -f
	    touch ${CLASSES_INVALID_STR} 
	    echo -n "(classes cleaned) "
	    trap "" EXIT
	    exit 0
	fi
EOF
    # Generate classes
    #
    TOP_LEVEL_SOURCES="Dummy.java"
    if (( RVM_WITH_OPT_COMPILER )); then
	TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} OptDummy.java"
    fi
    if (( RVM_WITH_OPT_TEST_HARNESS )); then
	TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} OptDummy.java OptTestHarness.java"
    fi
    TOP_LEVEL_SOURCES="${TOP_LEVEL_SOURCES} ${CONF_SPECIFIC_TOP_LEVEL_SOURCES}"
    TOP_LEVEL_CLASSES="$(echo ${TOP_LEVEL_SOURCES}| sed 's@\.java@.class@g')"

    cat <<- EOF
	if [[ -e $CLASSES_INVALID_STR ]]; then
	    cd $CLASSES_DIRECTORY_STR
	    rm -f $TOP_LEVEL_CLASSES
	    jikes_invocation="$HOST_JIKES_STR -nowarn -g +U -classpath .:rvmrt.jar $TOP_LEVEL_SOURCES"
	    $(emit_disable_exit_on_error)
	    if \${jikes_invocation}; then
	        echo -n '(classes compiled) '
	    else
	        status=\$?
	        echo >&2 "\$ME: The Jikes compiler exited with status \${status} while we were building the source file(s): $TOP_LEVEL_SOURCES"
	        echo >&2 "\$ME: We invoked the Jikes compiler in the directory $CLASSES_DIRECTORY_STR"
	        echo >&2 "\$ME: With the command-line: \$jikes_invocation"
	        exit \$status
	    fi
	    $(emit_enable_exit_on_error)
	    rm -f jksvm.jar
	    ## The Sun JAR manual page claims that '-O' is the flag for
	    ## no-compression.  It's actually '0' (zero), not the letter 'O'.
	    $HOST_JAR_STR -c0f jksvm.jar Dummy.class

	    \$FIND . -name '*.class' | \$XARGS -r $HOST_JAR_STR -u0f jksvm.jar
	    echo -n '(jksvm.jar built) '

	    rm -f jksvmsrc.jar
	    $HOST_JAR_STR -c0f jksvmsrc.jar Dummy.java
	    ## -r is XARGS's no-run-if-empty flag.
	    \$FIND . -name '*.java' | \$XARGS -r $HOST_JAR_STR -u0f jksvmsrc.jar
	    echo -n '(jksvmsrc.jar built) '

	else
	    if tracing jbuild; then
	         echo -n "(nothing needed to be compiled) "
	    fi
	fi
	rm -f $CLASSES_INVALID_STR

	if tracing jbuild; then
	    echo ""
	fi
	EOF
}

# echo >&2  "HERE I AM! emitImageLinker" # DBG
function emitImageLinker () {
    cat <<- EOF
	#! /bin/bash
	# Generate the VM bootimage.
	# Taken:    .class files in build directory
	# Returned: PRIMORDIAL_CLASSES and bootimage in build directory
	#            InterfaceDeclarations.h in bootImageRunner directory
	#
	$(emitBoilerplate)

	. ./environment.host

	# Process command-line args
	unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG DEMOGRAPHICS_FLAG || :
	MFLAGS=--silent
	while (( \$# > 0 )); do
	    arg="\$1"
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg == -trace* ]]; then
	        TRACE_FLAG="\$arg"
	    elif [[ \$arg = -v ]]; then
	       VFLAG=-v
	    elif [[ \$arg = -x ]]; then
	       XFLAG=-x
	    elif [[ \$arg = -demographics ]]; then
	        DEMOGRAPHICS_FLAG=-demographics
	    elif [[ \$arg = -clean ]]; then
	        CLEAN_FLAG=-clean
	    else
	        echo >&2 "\$ME: Unknown argument: \$arg"
	        trap '' EXIT
	        exit $Exit_Status_Bad_Args
	    fi
	    shift
	done
	
	echo -n "\${ME}: "
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	if tracing make; then
	    MFLAGS=-w
	fi

EOF
    
    BOOTIMAGE_WRITER_MAKEFILE=Makefile

    echo "if [[ \$CLEAN_FLAG ]]; then"
    echo "    rm -f $PRIMORDIAL_CLASSES_STR $EXCLUDED_CLASSES_STR $BOOTIMAGE_STR $BOOTIMAGE_MAP_STR"
    echo '    echo -n "(primordials cleaned) "'
    echo "    rm -f $SCRATCH_DIRECTORY_STR/GenerateInterfaceDeclaration.*"
    echo "    rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclaration.h"
    echo "    rm -f $SCRATCH_DIRECTORY_STR/BootImage*.java"
    echo "    rm -f $SCRATCH_DIRECTORY_STR/BootImage*.class"
    echo '    echo -n "(bootimage cleaned) "'
    echo '    trap "" EXIT'
    echo '    exit 0'
    echo 'fi'
    echo ''
    echo "rm -f $SCRATCH_DIRECTORY_STR/GenerateInterfaceDeclaration.*"
    echo "rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclaration.h"
    echo "rm -f $SCRATCH_DIRECTORY_STR/BootImage*.java"
    echo "rm -f $SCRATCH_DIRECTORY_STR/BootImage*.class"
    echo 'echo -n "(bootimage cleaned) "'

    # Generate list of classes to include in the bootimage.
    #
    echo "if [[ ! -e ${PRIMORDIAL_CLASSES_STR} ]]; then"

    # 
    # (1) Generate a list of Excluded classes that we don't want in the bootimage
    #

    cat <<- EOF
        sed -e 's/^[ 	]*//' -e 's/[ 	]*#.*//' -e '/^$/d' > ${EXCLUDED_CLASSES_STR} <<- EOF_EXCLUDED_CLASSES
	# skip: needed to build bootimage, but not to run it
	    BootImageInterface.class
	    Dummy.class
	    OptDummy.class

	# skip: JikesRVMSocketImpl; don't load native libs unless needed
	    JikesRVMSocketImpl.class

	# skip: don't put application class loader in, due to static data issues
	    ApplicationClassLoader.class

	# We can't carry these from bootimage writing to runtime without special treatment
	    java/lang/ref/PhantomReference.class
	    java/lang/ref/SoftReference.class
	    java/lang/ref/WeakReference.class
EOF_EXCLUDED_CLASSES
EOF

    # Add any configuration specific exclusions
    for exclusion in ${CONF_SPECIFIC_EXCLUSIONS_LIST}; do
	echo "    echo '${exclusion}'          >> ${EXCLUDED_CLASSES_STR}"
    done

    # 
    # (2) Generate a list of primary classes (non-arrays, non compiler generated (Foo${bar})
    #     classes that will be included in the bootimage unless explicitly excluded.
    
    echo "    cd ${CLASSES_DIRECTORY_STR}"
    
    # Start a subshell where the output from a series of commands will go to
    # one output stream.
    echo "("
    # ${FIND}'s action defaults to -print if none is explicitly specified.
    if (( RVM_WITH_ALL_CLASSES )); then
        echo "    \${FIND} . -name '*.class'"
    else
	echo "    \$FIND . -name 'VM*.class'"
	if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	    echo "    \$FIND ./com/ibm/JikesRVM/opt -name '*.class'"
        fi
	echo "    \$FIND ./com/ibm/JikesRVM/memoryManagers -name '*.class'"
	echo "    \$FIND . -name JikesRVMSupport.class"
    fi
    echo ") > ${PRIMORDIAL_CLASSES_STR}.1"
    cat <<- EOF
    \${SED} -e 's/#.*//' -e '/^[ \t]*\$/d' >> ${PRIMORDIAL_CLASSES_STR}.1 << EOF_PRIMORDIAL_CLASSES_STR_1
# VM daemon threads that don't start with VM for historical reasons
com/ibm/JikesRVM/FinalizerThread
com/ibm/JikesRVM/MainThread
com/ibm/JikesRVM/DebuggerThread

# Classes needed for OutOfMemory servicing which we can't afford to load when we are actually out of memory
com/ibm/JikesRVM/PrintLN
com/ibm/JikesRVM/PrintContainer

## Classes involved with the process of class loading...
# fundamental java classes
#
java/lang/Class
java/lang/Object
java/lang/Runtime
java/lang/String
java/lang/StringBuffer
java/util/StringTokenizer
java/lang/System
java/lang/Thread
java/lang/ThreadGroup

java/lang/OutOfMemoryError
java/lang/Cloneable
java/lang/VMObject
java/lang/VMSystem
java/lang/VMString
gnu/classpath/Configuration

    # reflection support
    #
java/lang/reflect/Field
java/lang/reflect/Method
java/lang/reflect/Member
java/lang/reflect/Constructor
java/lang/reflect/AccessibleObject

    # hardware runtime errors
    #
java/lang/ArithmeticException
java/lang/ArrayIndexOutOfBoundsException
java/lang/Exception
java/lang/Error
java/lang/IndexOutOfBoundsException
java/lang/LinkageError
java/lang/NullPointerException
java/lang/RuntimeException
java/lang/SecurityException
java/lang/StackOverflowError
java/lang/Throwable
java/lang/UnknownError
java/lang/VirtualMachineError

    # software runtime errors
    #
java/lang/IncompatibleClassChangeError
java/lang/ClassCastException
java/lang/ArrayStoreException
java/lang/NegativeArraySizeException
java/lang/AbstractMethodError
java/lang/StringIndexOutOfBoundsException
java/lang/UnsatisfiedLinkError
java/lang/InternalError
java/lang/IllegalMonitorStateException

    # primitive wrapper types
    #
java/lang/Boolean
java/lang/Byte
java/lang/Character
java/lang/Double
java/lang/Float
java/lang/Integer
java/lang/Long
java/lang/Number
java/lang/Short

    # class loading errors
    #
java/io/IOException
java/io/EOFException
java/io/FileNotFoundException
java/lang/ClassNotFoundException
java/lang/ClassFormatError
java/lang/NoClassDefFoundError
java/util/zip/ZipException

    # util datastructures (needed by compilers, classloaders, etc)
    #
java/util/AbstractList
java/util/AbstractMap
java/util/AbstractSet
java/util/ArrayList
java/util/Arrays
java/util/HashMap
java/util/HashSet
java/util/Hashtable
java/util/List
java/util/ListResourceBundle
java/util/PropertyResourceBundle
java/util/MissingResourceException
java/util/Properties
java/util/ResourceBundle
java/util/Vector
java/util/AbstractCollection
java/util/Collections
java/util/Stack
java/util/WeakHashMap

    # class loaders
    #
java/lang/ClassLoader
java/lang/VMClassLoader
java/lang/VMSecurityManager
gnu/java/io/PlatformHelper
java/security/CodeSource
java/security/Policy
java/security/PermissionCollection
java/security/Permissions
java/security/Principal
gnu/java/locale/Calendar
java/lang/reflect/InvocationTargetException

    # class loading from regular files
    #
java/io/File
java/io/DataInputStream
java/io/DataOutputStream
java/io/FilterInputStream
java/io/InputStream
java/io/FileInputStream
java/io/FileDescriptor
EOF

    if (( RVM_WITH_NON_BLOCKING_FDS_FOR_CLASSPATH )); then
	echo "java/io/VMFileDescriptor"
    fi

	cat <<EOF
    # class loading from zip files
    #
java/util/zip/ZipFile
java/util/zip/ZipFile
java/util/zip/ZipEntry
java/util/zip/Inflater
java/util/zip/InflaterInputStream
java/util/zip/Deflater
java/util/zip/DeflaterOutputStream
java/util/zip/ZipException
java/util/zip/Adler32
java/util/zip/StreamManipulator
java/util/zip/OutputWindow
java/util/zip/InflaterHuffmanTree
java/util/zip/DeflaterHuffman
java/util/zip/InflaterDynHeader
java/io/InputStreamReader
java/io/BufferedReader
java/io/Reader
java/lang/Math
java/io/Serializable
java/util/Calendar
java/util/GregorianCalendar
java/util/Locale
java/util/Date
java/util/TimeZone
java/util/SimpleTimeZone
java/lang/Cloneable
java/security/AccessController
java/security/PrivilegedAction
java/util/PropertyPermission
java/security/BasicPermission
java/security/Permission
java/security/AllPermission
java/security/AllPermissionCollection
java/lang/RuntimePermission
EOF
    
    # the application class loader uses jar classes (which can be loaded or not)

    if (( RVM_WITH_ALL_CLASSES )); then
	cat <<- EOF
java/util/jar/JarException
java/util/jar/JarInputStream
java/util/jar/Attributes
java/util/jar/JarOutputStream
java/util/jar/JarEntry
java/util/jar/JarFile
java/util/jar/Manifest
	EOF

    fi

	cat <<- EOF
java/io/BufferedOutputStream
java/io/BufferedInputStream
java/io/ByteArrayInputStream
java/io/FileOutputStream
java/io/PrintStream
java/io/RandomAccessFile
java/io/ObjectStreamField
EOF
    if (( RVM_WITH_OSR )); then
	cat <<- EOF
	# on stack replacement
com/ibm/JikesRVM/OSR/OSR_ObjectHolder
com/ibm/JikesRVM/OSR/OSR_BaselineExecStateExtractor
com/ibm/JikesRVM/OSR/OSR_OptExecStateExtractor
com/ibm/JikesRVM/OSR/OSR_EncodedOSRMap
com/ibm/JikesRVM/OSR/OSR_SpecialCompiler
com/ibm/JikesRVM/OSR/OSR_AdjustBCIndexes
com/ibm/JikesRVM/OSR/OSR_PostThreadSwitch
com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementTrigger
com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementEvent
com/ibm/JikesRVM/adaptive/OSR_OnStackReplacementPlan
com/ibm/JikesRVM/adaptive/OSR_OrganizerThread
EOF
    fi

	cat <<- EOF
java/io/PrintWriter
java/io/OutputStreamWriter
java/io/InputStreamReader
gnu/java/io/EncodingManager
gnu/java/io/decode/Decoder8859_1
gnu/java/io/decode/Decoder8859_2
gnu/java/io/decode/Decoder8859_3
gnu/java/io/decode/Decoder8859_4
gnu/java/io/decode/Decoder8859_5
gnu/java/io/decode/DecoderEightBitLookup
gnu/java/io/decode/DecoderUTF8
gnu/java/io/encode/Encoder8859_1
gnu/java/io/encode/Encoder8859_2
gnu/java/io/encode/Encoder8859_3
gnu/java/io/encode/Encoder8859_4
gnu/java/io/encode/Encoder8859_5
gnu/java/io/encode/EncoderEightBitLookup
gnu/java/io/encode/EncoderUTF8
java/lang/ref/Reference
java/lang/ref/ReferenceQueue
gnu/java/security/provider/DefaultPolicy
gnu/java/locale/Calendar_en
EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	# data structures that need to carry over from boot image writing
	# and/or classes that opt wants to be in the bootimage to 
	# generate decent code (avoid dynamic linking, get them opt compiled)
	if (( RVM_WITH_OPT_BOOTIMAGE_COMPILER )); then
	cat <<- EOF
java/util/Enumeration
java/util/Dictionary
java/util/TreeMap
java/util/TreeSet
java/util/Stack

com/ibm/JikesRVM/opt/ir/OPT_CallSiteTreeNode
com/ibm/JikesRVM/opt/OPT_FieldAnalysis
com/ibm/JikesRVM/opt/OPT_FieldDatabase
com/ibm/JikesRVM/opt/OPT_SpecializedMethod
com/ibm/JikesRVM/opt/OPT_InvokeeThreadLocalContext
com/ibm/JikesRVM/opt/OPT_SpecializedMethodPool
com/ibm/JikesRVM/opt/OPT_SpecializationDatabase

com/ibm/JikesRVM/opt/OPT_ClassLoadingDependencyManager
com/ibm/JikesRVM/opt/OPT_InvalidationDatabase
com/ibm/JikesRVM/opt/OPT_InterfaceHierarchy
com/ibm/JikesRVM/opt/OPT_SummaryDatabase
com/ibm/JikesRVM/opt/OPT_MethodSummary
EOF
	fi

	if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	    echo com/ibm/JikesRVM/opt/OPT_ContextFreeInlinePlan
	fi
    fi

    if (( RVM_WITH_HPM )) ; then
	cat << EOF
com/ibm/JikesRVM/HPM_counters
com/ibm/JikesRVM/HPM_info
Lcom/ibm/JikesRVM/Java2HPM;
EOF
    fi
    cat <<- EOF
EOF_PRIMORDIAL_CLASSES_STR_1
	#
	# (3) Now that we have a big file of root classes to include, 
	#     process the exclusions,
	#     find all the compiler-generated classes,
	#     and convert to internal names.
	    \$FGREP -v -f $EXCLUDED_CLASSES_STR ${PRIMORDIAL_CLASSES_STR}.1 | \${SED} -e'/\\\$/d' -e 's@^\\./@@' -e 's@\.class\$@@' -e 's@^\\(.*\\)\$@\\1.class\\
\\1\$@' > ${PRIMORDIAL_CLASSES_STR}.2
	    $HOST_JAR_STR tf rvmrt.jar > $PRIMORDIAL_CLASSES_STR.3
	    \$FIND . -name '*.class' -print | \$SED 's@^\./@@' >> $PRIMORDIAL_CLASSES_STR.3
	    > $PRIMORDIAL_CLASSES_STR # Create it clean
#	DEBUGGING -- lets us test for junk in the RVM.primordials file:
#	    echo fi > $PRIMORDIAL_CLASSES_STR
	    \$FGREP -f $PRIMORDIAL_CLASSES_STR.2 $PRIMORDIAL_CLASSES_STR.3 | \$SED 's@\(.*\)\.class@L\1;@' >> $PRIMORDIAL_CLASSES_STR
	    rm $PRIMORDIAL_CLASSES_STR.1
	    rm $PRIMORDIAL_CLASSES_STR.2
	    rm $PRIMORDIAL_CLASSES_STR.3
	# 
	# (4) Add Array types.  NOTE: These must be in internal form.
	#
	\${SED} -e 's/#.*//' -e '/^\$/d' >> $PRIMORDIAL_CLASSES_STR << 'EOF_PRIMORDIAL_CLASSES_STR'
	[Ljava/util/AbstractSet;
	[Ljava/util/HashSet;
	[Ljava/util/HashMap\$HashEntry;
	[Ljava/util/WeakHashMap\$WeakBucket;
	[Ljava/security/Principal;

	[Ljava/util/zip/ZipEntry;
	[Lcom/ibm/JikesRVM/VM_LockNursery\$VM_LockBucket;
	[Lcom/ibm/JikesRVM/classloader/VM_Atom;
	[Lcom/ibm/JikesRVM/VM_BasicBlock;
	[Lcom/ibm/JikesRVM/classloader/VM_Field;
	[Lcom/ibm/JikesRVM/classloader/VM_Method;
	[Lcom/ibm/JikesRVM/classloader/VM_MemberReference;
	[Lcom/ibm/JikesRVM/classloader/VM_Type;
	[Lcom/ibm/JikesRVM/classloader/VM_TypeReference;
	[Lcom/ibm/JikesRVM/memoryManagers/vmInterface/VM_CollectorThread;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/VMResource;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/MemoryResource;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/Plan;
	[Lcom/ibm/JikesRVM/memoryManagers/JMTk/SynchronizedCounter;
	[Ljava/lang/Object;
	[[Ljava/lang/Object;
	[Ljava/lang/String;
	[Ljava/lang/Class;
	[Ljava/lang/reflect/Field;
	[Ljava/lang/reflect/Method;
	[Ljava/lang/reflect/Member;
	[Ljava/lang/reflect/Constructor;
	[Ljava/io/ObjectStreamField;
	[Ljava/security/ProtectionDomain;
	[Ljava/lang/Package;

	[B
	[C
	[I
	[F
	[D
	[J
	[S
	[Z
	[[I
	[[B
	[[D
	[[[I

	# These next arrays are really arrays of primitves to Jikes RVM 
	#  (even though Java doesn't think they are...)
	[Lcom/ibm/JikesRVM/VM_Address;
	[Lcom/ibm/JikesRVM/VM_Word;
	[Lcom/ibm/JikesRVM/VM_Offset;
	[Lcom/ibm/JikesRVM/VM_Extent;
	[Lcom/ibm/JikesRVM/VM_Code;
	    
	[Lcom/ibm/JikesRVM/VM_CodeArray;

	[Lcom/ibm/JikesRVM/classloader/VM_Class;
	[Lcom/ibm/JikesRVM/VM_UnusualMaps;
	[Lcom/ibm/JikesRVM/VM_Processor;
	[Lcom/ibm/JikesRVM/VM_Thread;
	[Lcom/ibm/JikesRVM/VM_Lock;
	[Lcom/ibm/JikesRVM/VM_CompiledMethod;
	[Lcom/ibm/JikesRVM/VM_DynamicLibrary;

	[Lcom/ibm/JikesRVM/classloader/VM_InterfaceMethodSignature; # For fast interface method invoker

	[Lcom/ibm/JikesRVM/VM_CommandLineArgs\$Prefix; # For command-line argument processing
	EOF
    if (( RVM_WITH_OPT_COMPILER )); then
	cat <<- EOF
		[[C
		[Ljava/util/HashSet;
	EOF
	if (( RVM_WITH_ALL_CLASSES )); then
	cat <<- EOF
		[Lcom/ibm/JikesRVM/opt/OPT_OperatorClass;
		[Lcom/ibm/JikesRVM/opt/OPT_ResourceReservation;
		[Lcom/ibm/JikesRVM/opt/ir/OPT_Operator;
		[Lcom/ibm/JikesRVM/opt/ir/OPT_Register;
	EOF
	fi

	if (( RVM_WITH_ADAPTIVE_SYSTEM )); then
	cat <<- EOF
		[Lcom/ibm/JikesRVM/adaptive/VM_MethodListener;
		[Lcom/ibm/JikesRVM/adaptive/VM_EdgeListener;
		[Lcom/ibm/JikesRVM/adaptive/VM_ContextListener;
		[Lcom/ibm/JikesRVM/adaptive/VM_NullListener;
EOF
	fi
    fi

# Add the configuration specific primordials
#
    for primordial in $CONF_SPECIFIC_PRIMORDIALS_LIST; do
	echo $primordial
    done

cat <<-EOF
EOF_PRIMORDIAL_CLASSES_STR
EOF
    echo '    echo -n "(primordial class names written) "'
    echo 'fi'

    echo "\
# Create bootimage.
#"
    BOOTIMAGE_WRITER_ARGS="\$DEMOGRAPHICS_FLAG \$BOOTIMAGE_WRITER_TRACE_FLAG"

    BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -ia $BOOTIMAGE_LOAD_ADDRESS"

    if (( GENERATE_MAP )); then
	BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -m $BOOTIMAGE_MAP_STR"
    fi
    
    if (( RVM_FOR_IA32 )); then
	BOOTIMAGE_WRITER_ARGS="$BOOTIMAGE_WRITER_ARGS -littleEndian"
    fi

    # OPT_ARGS may be set at build time in jconfigure.
    echo ""
    echo 'OPT_ARGS="'$OPT_ARGS' $DEBUG_ARGS"'

    if (( RVM_WITH_NOFLUSH )); then
	echo ' OPT_ARGS="$OPT_ARGS -X:bc:no_cache_flush=true"'
    fi

    echo "if tracing BootImageWriter; then"
    echo '    OPT_ARGS="$OPT_ARGS -X:bc:verbose=true"'
    echo '    VERBOSE_STR="VERBOSE_ARG=-verbose:gc"'
    echo 'fi'
    echo "if tracing preprocessor; then"
    echo '    PREPROC_TRACE_FLAG="-trace"'
    echo 'else'
    echo '    PREPROC_TRACE_FLAG=""'
    echo 'fi'
    echo ""

    # copy and preprocess BootImageWriter sources
    #
    echo ''
    echo "BOOTIMAGE_WRITER_TRACE_FLAG="
    echo "if tracing BootImageWriter; then"
    echo '    echo -n "$ME: '$BOOTIMAGE_WRITER_DIR_STR'"'
    echo "    BOOTIMAGE_WRITER_TRACE_FLAG=-trace"
    echo 'fi'
    echo "FILES=\$(echo $BOOTIMAGE_WRITER_DIR_STR/*.java)"
    echo "if ! [[ \$FILES ]]; then"
    echo "    echo >&2 \$ME: Trouble: Cannot find any files in $BOOTIMAGE_WRITER_DIR_STR!"
    echo "    trap '' EXIT"
    echo "    exit 2"
    echo "fi"
    # See above comment in jconfigure on xargs.
    echo "echo \$FILES | \$XARGS -r \"$BUILD_DIRECTORY_STR/jbuild.prep.host\" --disable-modification-exit-status \$PREPROC_TRACE_FLAG" $PREPROCESSOR_DEFINITIONS $SCRATCH_DIRECTORY_STR 
    # echo $BUILD_DIRECTORY_STR/jbuild.prep.host --disable-modification-exit-status '$PREPROC_TRACE_FLAG' $PREPROCESSOR_DEFINITIONS $SCRATCH_DIRECTORY_STR "\$FILES"
    echo "if tracing preprocessor; then"
    echo '    echo ""'
    echo 'fi'
    echo ''

    # compile BootImageWriter.java
    #
    echo "cd $SCRATCH_DIRECTORY_STR &&\
	  $HOST_JAVAC_STR -nowarn -g \
	  -classpath .:$BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  -bootclasspath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  BootImageWriter.java"

    # copy and preprocess GenerateInterfaceDeclarations.java
    #
    echo ''
    echo "if tracing jbuild; then"
    echo "    echo -n \"\$ME: $BOOTIMAGE_RUNNER_DIR_STR\""
    echo "fi"
    echo "FILE=$BOOTIMAGE_RUNNER_DIR_STR/GenerateInterfaceDeclarations.java"
    echo "if ! [[ -f \$FILE ]]; then"
    echo "    echo >&2 \$ME: Trouble: Cannot find \$FILE!"
    echo "    trap '' EXIT"
    echo "    exit 2"
    echo "fi"
    # We explicitly do not double-quote $PREPROCESSOR_DEFINITIONS, since we
    # need the newlines in that string to be replaced with spaces.
    echo "$BUILD_DIRECTORY_STR/jbuild.prep.host --disable-modification-exit-status \$PREPROC_TRACE_FLAG" $PREPROCESSOR_DEFINITIONS "$SCRATCH_DIRECTORY_STR  \$FILE"
    echo "if tracing jbuild; then"
    echo '    echo ""'
    echo 'fi'
    echo '
#
# compile GenerateInterfaceDeclarations.java
#'
    echo "cd $SCRATCH_DIRECTORY_STR &&\
	  $HOST_JAVAC_STR -nowarn -g \
	  -classpath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  -bootclasspath $BUILD_DIRECTORY_STR/RVM.classes:$BUILD_DIRECTORY_STR/RVM.classes/rvmrt.jar\
	  GenerateInterfaceDeclarations.java"

    echo '#
# generate InterfaceDeclarations.h
#'
    echo "rm -f $SCRATCH_DIRECTORY_STR/InterfaceDeclarations.h"
    echo "cd $SCRATCH_DIRECTORY_STR && $HOST_JAVA_STR -Xms200M -Xmx200M\
	  -classpath .:$CLASSES_DIRECTORY_STR:$CLASSES_DIRECTORY_STR/rvmrt.jar\
	  GenerateInterfaceDeclarations -ia $BOOTIMAGE_LOAD_ADDRESS >\
	  $SCRATCH_DIRECTORY_STR/InterfaceDeclarations.h"
    echo ""

    echo "cd $BOOTIMAGE_WRITER_DIR_STR"

    echo "$GNU_MAKE_STR -f $BOOTIMAGE_WRITER_MAKEFILE \$MFLAGS \$VERBOSE_STR\
	  RVM_REPOSITORIES=$CLASSES_DIRECTORY_STR/jksvm.jar:$CLASSES_DIRECTORY_STR/rvmrt.jar\
	  RVM_BOOTIMAGE_CLASSES=$PRIMORDIAL_CLASSES_STR\
	  RVM_BOOTIMAGE=$BOOTIMAGE_STR\
	  RVM_BOOTIMAGE_COMPILER_ARGS=\"\$OPT_ARGS\"\
	  RVM_BOOTIMAGE_WRITER_ARGS=\"$BOOTIMAGE_WRITER_ARGS\"\
	  SCRATCH_DIR=$SCRATCH_DIRECTORY_STR\
	  $BOOTIMAGE_STR"

    echo "if tracing jbuild; then"
    echo '  echo ""'
    echo 'fi'
}

function emitCheckIfIAmTheTarget () {
    echo "# Make sure that the architecture and O/S I'm running on are"
    echo "# the ones I should be on in order to link native executables."
    echo "# (This assumes we can only link native executables on the"
    echo "# native software and O/S.)"


    if (( RVM_FOR_AIX )); then
	echo "if [[ \$(uname) != AIX ]]; then"
	echo '    echo "please run me on AIX"'
	echo '    trap "" EXIT'
	echo "    exit $Exit_Status_Run_Linker"
	echo 'fi'
    elif (( RVM_FOR_LINUX )); then
	echo "if [[ \$(uname) != Linux ]]; then"
	echo '    echo "please run me on Linux"'
	echo '    trap "" EXIT'
	echo "    exit $Exit_Status_Run_Linker"
	echo 'fi'

	if (( RVM_FOR_POWERPC )); then
	    echo "if [[ \$(uname -m) != ppc ]]; then"
	    echo '    echo "please run me on Linux PowerPC"'
	    echo '    trap "" EXIT'
	    echo "    exit $Exit_Status_Run_Linker"
	    echo 'fi'
	elif (( RVM_FOR_IA32 )); then
	    echo "if [[ \$(uname -m) != i686 ]]; then"
	    echo '    echo "please run me on Linux IA32"'
	    echo '    trap "" EXIT'
	    echo "    exit $Exit_Status_Run_Linker"
	    echo 'fi'
	fi
    fi
    echo ""
}

# Emit script to generate jbuild.linkBooter, the vm booter, 
# echo >&2  "HERE I AM! emitBooterLinker" # DBG
function emitBooterLinker () {
    echo '#! /bin/bash'
    echo ""
    echo '# Generate vm booter.'
    echo ""
    echo '# Taken:    InterfaceDeclarations.h in bootImageRunner directory'
    echo '# Returned: booter in build directory'
    echo ""
    echo '# Allow the build directory to be different between'
    echo '# the host/boot image'
    echo '# writing system and the target system.'
    echo ""
    emitBoilerplate
    echo 'ROOT_DIR="${0%/*}"'
    echo '# If a relative path, go over to a fully-qualified path.'
    echo 'if [[ "$ROOT_DIR" = "." ]]; then'
    echo '    ROOT_DIR="$PWD"'
    echo 'fi'
    echo '# I do not understand the point behind this code. --Steve Augart'
    echo '# The strange part for me is that CURRENT_DIR is not defined anywhere else in this build process.'
    echo 'if [[ "$ROOT_DIR" != "$CURRENT_DIR" ]]; then'
    echo '    if [[ -f "$CURRENT_DIR"/"$ROOT_DIR"/"$ME" ]]; then'
    echo '      ROOT_DIR=$CURRENT_DIR/$ROOT_DIR'
    echo '    fi'
    echo 'fi'
    echo ""
    echo ". \$ROOT_DIR/environment.target"
    echo ""
    echo "$BUILD_DIRECTORY_STR1=\$ROOT_DIR"
    echo ""

    echo 'unset TRACE_FLAG VFLAG XFLAG CLEAN_FLAG || :'
    echo 'MFLAGS=--silent'
    echo "while (( \$# > 0 )); do"
    echo '    arg="$1"'
    echo '    [[ $arg != --?* ]] || arg="${arg#-}"'
    echo "    if [[ \$arg == -trace* ]]; then"
    echo '        TRACE_FLAG="$arg"'
    echo "    elif [[ \$arg = -v ]]; then"
    echo "        VFLAG=-v"
    echo "    elif [[ \$arg = -x ]]; then"
    echo "        XFLAG=-x"
    echo "    elif [[ \$arg = -clean ]]; then"
    echo "        CLEAN_FLAG=-clean"
    echo "    else"
    echo "        echo >&2 \"\$ME: Unknown argument: \$arg\""
    echo "	  trap '' EXIT"
    echo "        exit $Exit_Status_Bad_Args"
    echo "    fi"
    echo "    shift"
    echo "done"
 
    echo "if tracing make; then"
    echo "    MFLAGS=-w"
    echo "fi"
    echo "echo -n \"\$ME: \""
#    echo "! tracing jbuild || XFLAG=-x"
#    echo "[[ \$VFLAG ]] || VFLAG=+v"
#    echo "[[ \$XFLAG ]] || XFLAG=+x"
    echo "[ ! \"\$VFLAG\$XFLAG\" ] || set \$VFLAG \$XFLAG"

    echo ""
    echo "# Here, we go ahead and delete some .o files because it takes"
    echo "# only a second or two to regenerate them, and there was a long"
    echo "# trail of problems getting the dependencies correct."
    echo "rm -f libjni.a"
    echo "cd $SCRATCH_DIRECTORY_STR"
    echo "rm -f $BOOTER_STR RunBootImage.o initBootRecord.o sys.o bootThread.o bootThread.s libvm.o RunBootImage.h preprocessModifiedFiles"
    echo "if [[ \$CLEAN_FLAG ]]; then"
    echo "    rm -f disasm.o innpdsm.o"
    echo 'fi'
    echo 'echo -n "(booter cleaned) "'
    echo "if [[ \$CLEAN_FLAG ]]; then"
    echo '    trap "" EXIT'
    echo '    exit 0'
    echo 'fi'
    echo ""

    emitCheckIfIAmTheTarget
    echo ""

    if [[ $RVM_HOST_CONFIG != $RVM_TARGET_CONFIG ]]; then
	echo "  \$JAL_ROOT/rvm/bin/jBuildClasspathJar --check"
    fi

    # copy native libraries
    if [[ $CLASSPATH_ROOT ]]; then
	CPS=$CLASSPATH_ROOT
    else
	CPS=$RVM_ROOT/classpath
    fi
    echo "SYSTEM_TYPE=\$(${CPS}/classpath/config.guess)"
    ## AIX requires that dynamically loaded libraries end in .a, 
    ## so that dlopen() will find them.  Also, the classpath builder, on AIX,
    ## generates the files with the suffix ".so.0".  We transform one to the othr.
    if (( RVM_FOR_AIX )); then
	echo 'for _library in' $CPS/'$SYSTEM_TYPE/native/jni/*/.libs/*.so.0; do'
	echo '    oldbase=$(basename ${_library} .so.0)'
	echo '    dest_lib='${BUILD_DIRECTORY_STR}'/${oldbase}.a'
	echo '    cp $_library $dest_lib'
	echo 'done'
	echo 'unset oldbase dest_lib _library || :'
    else
	## On Linux, on the other hand, dynamically loaded libraries end in 
	## .so.  The classpath builder conveniently generates them 
	## with this suffix.
	echo 'cp -f '$CPS'/$SYSTEM_TYPE/native/jni/*/.libs/*.so '$BUILD_DIRECTORY_STR
    fi
    echo -e "\necho -n '(classpath native libraries copied) '"

    # Make a target platform preprocessor for use in gctest
    echo "${GNU_MAKE_STR} \${MFLAGS} -C ${ROOT_DIRECTORY_STR}/rvm/src/tools/preprocessor INCLUDED_MAKEFILE=${BUILD_DIRECTORY_STR}/Make.rules.target tool SCRATCH_DIR=${SCRATCH_DIRECTORY_STR}"
    echo "cp ${SCRATCH_DIRECTORY_STR}/preprocessModifiedFiles ${BUILD_DIRECTORY_STR}/jbuild.prep.target"

    # Create RunBootImage.h file.
    local tgt=RunBootImage.h
    local tmp=${tgt},tmp
    cat <<- EOF2
    	cat << EOF_RUNBOOTIMAGE_H > ${tmp}
	// RunBootImage.C boot-time constants
	const unsigned heap_default_initial_size  = $DEFAULT_INITIAL_HEAP_SIZE*1024*1024;
	const unsigned heap_default_maximum_size      = $DEFAULT_MAXIMUM_HEAP_SIZE*1024*1024;
	const char *rvm_version              = "$JIKESRVM_VERSION";
	const char *rvm_configuration        = "$CONFIGURATION_NAME";
	const char *rvm_host_configuration   = "$RVM_HOST_CONFIG";
	const char *rvm_target_configuration = "$RVM_TARGET_CONFIG";
EOF_RUNBOOTIMAGE_H
	{ [[ -f $tgt ]] && cmp -s $tgt $tmp ; } || mv -f $tmp $tgt
	rm -f $tmp

	# build the JNI library for creating processes
	cd \${JAL_ROOT}/rvm/src/tools/bootImageRunner/
EOF2
    if (( RVM_FOR_AIX )); then
	local -r shlib_suffix=.a
    else
	local -r shlib_suffix=.so
    fi
    DEST='$JAL_BUILD/libjpnexec'${shlib_suffix}
    echo '$GNU_MAKE $MFLAGS -f Makefile.proc DEST='$DEST $DEST 

    if (( RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	CC_DEFINES="-DRVM_FOR_SINGLE_VIRTUAL_PROCESSOR"
    else 
	CC_DEFINES="-URVM_FOR_SINGLE_VIRTUAL_PROCESSOR"
    fi

    if (( RVM_FOR_32_ADDR )); then
	CC_DEFINES="$CC_DEFINES -DRVM_FOR_32_ADDR -URVM_FOR_64_ADDR"
    fi
    if (( RVM_FOR_64_ADDR )); then
	CC_DEFINES="$CC_DEFINES -DRVM_FOR_64_ADDR -URVM_FOR_32_ADDR"
    fi
  
    if (( RVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS )); then
	CC_DEFINES="$CC_DEFINES -DRVM_WITHOUT_INTERCEPT_BLOCKING_SYSTEM_CALLS"
    else
	# Build the blocking system call wrapper library, if requested
	DEST='$JAL_BUILD/libsyswrap'${shlib_suffix}
	echo '$GNU_MAKE $MFLAGS -f Makefile.syswrap DEST="'$DEST'" CXXFLAGS+="'"$CC_DEFINES"\" "$DEST"
    fi

    echo "BOOTER_CXX=run_booter_cxx"
    echo "BOOTER_CC=run_booter_cc"
    # Generate information useful for GNU Emacs.
    echo "\
function run () {
    ! tracing make || echo \"\$@\"
    \"\$@\"
}
function chdir() {
    ! tracing make || echo \"\$ME[0]: Entering directory \\\`\$1'\"
    \\cd \"\$1\"
}
"
    if (( RVM_FOR_POWERPC && RVM_FOR_AIX )); then
	echo "function run_booter_cxx() { run $HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -DRVM_FOR_AIX -DRVM_FOR_POWERPC $CC_DEFINES \"\$@\"; }"
        echo "LDSHARED=\"$HOST_SHLD_STR\""
	echo 'BOOTER_CXXM="$BOOTER_CXX -M"'
	echo "CPP=\"$HOST_CC_STR -E $CC_DEFINES\""

	echo 'CCLIBS="-lpthread -lm"'
	echo 'IMAGE='

    elif (( RVM_FOR_POWERPC && RVM_FOR_LINUX && RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "function run_booter_cxx() { run $HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -DRVM_FOR_LINUX -DRVM_FOR_POWERPC $CC_DEFINES \"\$@\"; }"
 	echo "LDSHARED=\"$HOST_SHLD_STR\""
	echo "BOOTER_CXXM=\$BOOTER_CXX"
	echo "CPP=\"$HOST_CPP_STR $CC_DEFINES\""

	echo 'CCLIBS="${EXTRA_CCLIBS} -ldl -lm"'
	echo 'IMAGE="-DIMAGE_ADDRESS=0x31000000"'

    elif (( RVM_FOR_POWERPC && RVM_FOR_LINUX && !RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "function run_booter_cxx() { run $HOST_CPLUS_STR \${CXXFLAGS} -g -O2 -rdynamic -DRVM_FOR_LINUX -DRVM_FOR_POWERPC $CC_DEFINES \"\$@\"; }"

	echo "LDSHARED=\"$HOST_SHLD_STR\""
	echo "BOOTER_CXXM=\$BOOTER_CXX"
	echo "CPP=\"$HOST_CPP_STR $CC_DEFINES -D__linuxsmp__\""
	
	echo 'CCLIBS="-lpthread -ldl -lm"'
	echo 'IMAGE="-DIMAGE_ADDRESS=0x31000000"' 

    elif (( RVM_FOR_IA32 && RVM_FOR_LINUX && !RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "declare -a gnu_compiler_flags
gnu_compiler_flags=(-O2 -rdynamic -DRVM_FOR_LINUX -DRVM_FOR_IA32 -D_REENTRANT $CC_DEFINES)"
	echo "function run_booter_cxx() { run $HOST_CPLUS_STR \"\${gnu_compiler_flags[@]}\" \"\$@\"; }"
	echo "function run_booter_cc() { run $HOST_CC_STR \"\${gnu_compiler_flags[@]}\" \"\$@\"; }"
	echo 'CCLIBS="-lpthread -ldl"'
	echo 'IMAGE='
    elif (( RVM_FOR_IA32 && RVM_FOR_LINUX && RVM_FOR_SINGLE_VIRTUAL_PROCESSOR )); then
	echo "declare -a gnu_compiler_flags
gnu_compiler_flags=(-O2 -DRVM_FOR_LINUX -DRVM_FOR_IA32 $CC_DEFINES)"
	echo "function run_booter_cxx() { run $HOST_CPLUS_STR \"\${gnu_compiler_flags[@]}\" \"\$@\"; }"
	echo "function run_booter_cc() { run $HOST_CC_STR \"\${gnu_compiler_flags[@]}\" \"\$@\"; }"
	echo 'CCLIBS="-ldl"'
	echo 'IMAGE='
    fi
    echo ""

    if (( RVM_FOR_POWERPC && ( RVM_FOR_AIX || RVM_FOR_LINUX ) )); then
	echo "cd $BOOTIMAGE_RUNNER_DIR_STR &&\
		\$BOOTER_CXX -c -O -I$SCRATCH_DIRECTORY_STR\
		-I$BOOTIMAGE_RUNNER_SUBDIR_STR\
		\$IMAGE -DRVM_BOOTIMAGE=\\\"$BOOTIMAGE_STR\\\"\
		-o $SCRATCH_DIRECTORY_STR/RunBootImage.o RunBootImage.C"

	echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
	    \$BOOTER_CXX -c -O -I. -I$SCRATCH_DIRECTORY_STR \
	    -o $SCRATCH_DIRECTORY_STR/initBootRecord.o initBootRecord.C"
	
	echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
		\$CPP -I$SCRATCH_DIRECTORY_STR -P\
		bootThread.c > $SCRATCH_DIRECTORY_STR/bootThread.s"
	echo "\$BOOTER_CXX -c -o $SCRATCH_DIRECTORY_STR/bootThread.o\
		$SCRATCH_DIRECTORY_STR/bootThread.s"
	echo "cd $BOOTIMAGE_RUNNER_SUBDIR_STR &&\
		\$BOOTER_CXX -c -I. -I$SCRATCH_DIRECTORY_STR\
		\$IMAGE -DRVM_BOOTIMAGE=\\\"$BUILD_DIRECTORY_STR/RVM.image\\\"\
		-o $SCRATCH_DIRECTORY_STR/libvm.o libvm.C"

	if (( $RVM_WITH_HPM )); then
	echo "cd $BOOTIMAGE_RUNNER_DIR_STR &&\
	    \$BOOTER_CXX -c -O -I$SCRATCH_DIRECTORY_STR -DRVM_WITH_HPM=1\
	    -o $SCRATCH_DIRECTORY_STR/sys.o sys.C"
	
	echo 'echo -n "(build libhpm.a library) "'
	echo "cd $ROOT_DIRECTORY_STR/rvm/src/vm/arch/powerPC/runtime &&\
	    \$BOOTER_CXX -c -O -o $SCRATCH_DIRECTORY_STR/hpm.o hpm.c"
	echo "cd $SCRATCH_DIRECTORY_STR &&\
	        \$LDSHARED -o \$JAL_BUILD/libhpm.a  hpm.o -L\"$RVM_HPM_DIR\" -lpmapi"

	echo "cd $SCRATCH_DIRECTORY_STR &&\
	    \$BOOTER_CXX -o $BOOTER_STR RunBootImage.o initBootRecord.o libvm.o sys.o bootThread.o \$CCLIBS\
	    -L\"$RVM_HPM_DIR\" -lpmapi -L\"\$JAL_BUILD\" -lhpm"

	echo 'echo -n "(build libJava2HPM.a JNI library) "'
	echo "cd $ROOT_DIRECTORY_STR/rvm/src/vm/arch/powerPC/runtime &&\
  		\$BOOTER_CXX -c -O -I$SCRATCH_DIRECTORY_STR -I$ROOT_DIRECTORY_STR/rvm/src/include\
 		-o $SCRATCH_DIRECTORY_STR/Java2HPM.o Java2HPM.C"

	echo "cd $SCRATCH_DIRECTORY_STR &&\
	        \$LDSHARED -o \$JAL_BUILD/libJava2HPM.a  Java2HPM.o\
	        -L\"$RVM_HPM_DIR\" -lpmapi -L\"\$JAL_BUILD\" -lhpm > /dev/null 2>&1"
	else
	    cat <<- EOF
	cd ${BOOTIMAGE_RUNNER_DIR_STR} && \
	  \${BOOTER_CXX} -c -O -I${SCRATCH_DIRECTORY_STR} \
	    -o ${SCRATCH_DIRECTORY_STR}/sys.o sys.C

	cd ${SCRATCH_DIRECTORY_STR} &&\
	  \${BOOTER_CXX} -o ${BOOTER_STR} RunBootImage.o initBootRecord.o \
	    libvm.o sys.o bootThread.o \${CCLIBS}
	EOF
	fi
	echo 'echo -n "(booter linked)"'

    elif (( RVM_FOR_IA32 && RVM_FOR_LINUX )); then
	cat <<- EOF
	chdir ${BOOTIMAGE_RUNNER_DIR_STR}
	\${BOOTER_CXX} -c -I${SCRATCH_DIRECTORY_STR} \
	  \${IMAGE} -DRVM_BOOTIMAGE=\"${BOOTIMAGE_STR}\" \
	  -o ${SCRATCH_DIRECTORY_STR}/RunBootImage.o RunBootImage.C

	\${BOOTER_CXX} -c -I${SCRATCH_DIRECTORY_STR} \
	  -o ${SCRATCH_DIRECTORY_STR}/sys.o sys.C

	chdir ${BOOTIMAGE_RUNNER_SUBDIR_STR}
	\${BOOTER_CXX} -c -I. -I${SCRATCH_DIRECTORY_STR} \
	  -o ${SCRATCH_DIRECTORY_STR}/initBootRecord.o initBootRecord.C
	\${BOOTER_CC} -c -I${SCRATCH_DIRECTORY_STR} \
	  -o ${SCRATCH_DIRECTORY_STR}/bootThread.o bootThread.S
	\${BOOTER_CXX} -c -I${SCRATCH_DIRECTORY_STR} \
	  -I${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler \
	  -o ${SCRATCH_DIRECTORY_STR}/libvm.o libvm.C

	chdir ${ROOT_DIRECTORY_STR}/rvm/src/vm/arch/intel/disassembler

	\${BOOTER_CXX} -funsigned-bitfields -c -I${SCRATCH_DIRECTORY_STR} \
	  -o ${SCRATCH_DIRECTORY_STR}/disasm.o disasm.C

	\${BOOTER_CXX} \
	  -funsigned-bitfields -c -I${SCRATCH_DIRECTORY_STR} \
	   -o ${SCRATCH_DIRECTORY_STR}/ihnpdsm.o ihnpdsm.C

	chdir ${SCRATCH_DIRECTORY_STR}
	\${BOOTER_CXX} -o ${BOOTER_STR} RunBootImage.o initBootRecord.o \
	    sys.o bootThread.o libvm.o disasm.o ihnpdsm.o \${CCLIBS}

	echo "(booter linked)"
EOF
    else
	echo 'echo "I do not know how to link the booter"'
	echo 'trap "" EXIT'
	echo 'exit' $Exit_Status_Run_Linker
    fi
}

# Emit script to generate .class files for vm tools that are not part of 
# the build.   This becomes jbuild.tool
#
# echo >&2  "HERE I AM! emitToolCompiler" # DBG
function emitToolCompiler () {
    cat <<EOF
	#! /bin/bash
	# Generate class files for vm tools that are not part of the build.
	# This runs the Jikes Compiler with the
	# classpath and command-line flags set up so that we can just
	# make .class files for Jikes RVM to run.
$(emitBoilerplate)
	. \${RVM_BUILD}/environment.target

	function usage () {
	    echo 2>&1 "usage: ${ME} [ -trace[=<commands>] ] [ -classpath x:y:z ] [ -- ] java-file [ java-file... ]"
	    trap "" EXIT
	    exit $Exit_Status_Bad_Args
	}

	if [[ ${BUILD_DIRECTORY_STR} = "" ]]; then
	    echo >&2 "${ME}: please set your ${BUILD_DIRECTORY_STR1} environment variable (eg. \${HOME}/rvmBuild)"
	    trap "" EXIT
	    exit $Exit_Status_Bad_Args
	fi

	if [[ ${HOST_JAVAC_STR} = "" ]]; then
	    echo >&2 "\${ME}: please set your ${HOST_JAVAC_STR1} environment variable"
	    trap "" EXIT
	    exit $Exit_Status_Bad_Args
	fi

	unset EXTRA_CPATH TRACE_FLAG XFLAG VFLAG || :
	while :; do
	    arg="\$1"
	    [[ \$arg != -- ]] || { shift ; break; }
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg = -classpath ]]; then
	        (( \$# > 1 )) || usage
	        EXTRA_CPATH=\$2\${EXTRA_CPATH+:}\${EXTRA_CPATH}
	        shift
	        shift
	    elif [[ \$arg = -v ]]; then
	        VFLAG=-v
	        shift
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
	        shift
	    elif [[ \$arg == -trace* ]]; then
	        TRACE_FLAG=\$arg
	        shift
#	    elif [[ \$arg == -* ]]; then
#		echo >&2 "\${ME}: Unknown argument: \$arg"
#		exit 33
	    else
	        break # must be a regular argument or a flag we do not handle.
	    fi
	done
	CPATH=\${EXTRA_CPATH-.}:${BUILD_DIRECTORY_STR}/RVM.classes:${BUILD_DIRECTORY_STR}/RVM.classes/rvmrt.jar
	! tracing jbuild || XFLAG=-x
	[ ! \"\$VFLAG\$XFLAG\" ] || set \$VFLAG \$XFLAG
	
	exec $HOST_JAVAC_STR -nowarn -g -classpath "\$CPATH" -bootclasspath "\$CPATH" "\$@"
EOF
}
  
# Emit script to run jbuild.prep.target on java files that are not part of the build
#
function emitToolPreprocessor () {
    echo '#! /bin/bash'
    echo "# Run Jikes RVM's preprocessor on some source code files."
    echo "# Provides all of the standard preprocessor definitions we need for"
    echo "# the target environment.  Sticks the pure .java files that are the output"
    echo "# into the <output-directory> specified as the first non-flag"
    echo "# command-line argument."
    emitBoilerplate;
    echo '. "$RVM_BUILD/environment.target"'

    echo "if (( \$# == 0 )); then"
    echo '    echo >&2 "usage: $ME [ extra-preprocessor-flags...] output-directory java-file [ java-file... ]"'
    echo '    trap "" EXIT'
    echo "    exit $Exit_Status_Bad_Args"
    echo 'fi'

    echo 'exec "$RVM_BUILD/jbuild.prep.target"' $PREPROCESSOR_DEFINITIONS '"$@"'
}
  
function emitPluginBuilder () {
    cat <<- EOF
	#! /bin/bash
	# Build and install Jikes RVM launching plugin for Eclipse 2.x

	# pick up configuration to learn where Ant is
	$(emitBoilerplate)

	. "\${RVM_BUILD}/environment.target"


	usage () {
	    echo "Usage: \$ME [ --help ] [ -trace[=<args>] ] [ -v ] [ -x ]"
	    echo "      [ -- ] [ <eclipse-install-dir> ]"
	}

	help() {
	    usage;
	    echo "\$ME: To specify Eclipse's installation directory, do one"
	    echo "\$ME:  of the following (in order of decreasing precedence):" 
	    echo "  1: invoke this program as \$ME [<flags>] <eclipse-install-dir>"
	    echo "  2: set ECLIPSE_INSTALL_DIR in \${RVM_TARGET_CONFIG}, or"
	    echo "  3: set the environment variable ECLIPSE_INSTALL_DIR"
	}

	QUIET_ANT=-quiet
	unset XFLAG VFLAG || :

	while (( \$# > 0 )); do
	    arg="\$1"
	    if [[ \$arg = -- ]]; then
	        shift		# The end of the flag arguments
	        break;
	    fi
	    [[ \$arg != --?* ]] || arg="\${arg#-}"
	    if [[ \$arg = -v ]]; then
	        VFLAG=-v
	        shift
	    elif [[ \$arg = -x ]]; then
	        XFLAG=-x
		shift
	    elif [[ \$arg == -trace* ]]; then
		TRACE_FLAG="\$arg"
	        ! tracing ant || QUIET_ANT=
	        shift
	    elif [[ \$arg = -help ]] || [[ \$arg = -help ]]; then
	        shift
	        help
	        exit 0
	    elif [[ \$arg == -* ]]; then
	        echo >&2 "\$ME: Unknown flag: \$arg"
	        usage >&2
	        exit $Exit_Status_Bad_Args
	    fi
	done

	# allow user-specified Eclipse install to override env
	if [[ \$1 ]]; then
	    ECLIPSE_INSTALL_DIR=\$1
	    shift
	fi

	if (( \$# != 0 )); then
	    echo >&2 "$ME: Too many arguments."
	    usage >&2
	    exit $Exit_Status_Bad_Args;
	fi
	# must have Eclipse for command line or env
	if [[ ! \${ECLIPSE_INSTALL_DIR} ]]; then
	    echo "\$ME: You must (but didn't) specify the directory where Eclipse is installed."
	    help;
	    trap "" EXIT
	    exit 2
	fi >&2

	# must have Ant
	if [[ ! \${ANT_CMD} ]]; then
	    echo "must specify ANT_CMD in \${RVM_TARGET_CONFIG}"
	    trap "" EXIT
	    exit 2
	fi

	# build the plugin
#    	[[ \$VFLAG ]] || VFLAG=+v
#    	[[ \$XFLAG ]] || XFLAG=+x
	[ ! "\$VFLAG\$XFLAG" ] || set \$VFLAG \$XFLAG
	srcdir=\${JAL_ROOT}/rvm/src/tools/eclipse/plugin2
	! tracing ||  echo "Building in \${srcdir}"
	cd \${srcdir}
	# Get the name of the package we're building.  It changes with each
	# new version of Jikes RVM.  Only used for showing progress.
	declare -r pkgname=\$(sed -n -e 's/.*name="package".*value="\\([^"][^"]*[Jj]ikes[Rr][Vv][Mm][^"]*\\)".*/\\1/p' build.xml)
	echo "Building and installing the Eclipse plugin \$pkgname"
	( ! tracing jbuild && ! tracing ant ) || echo "Setting up ant.properties"

	echo "eclipse.dir=\${ECLIPSE_INSTALL_DIR}" > ant.properties

	if tracing ant; then
	    echo "build.trace=true"
	else
	    echo "build.trace=false"
	fi >> ant.properties
	export JAVA_HOME=\${HOST_JAVA_HOME}

	\${ANT_CMD} \$QUIET_ANT install

	EOF
}

#------------------------------------------------#
# SECTION 6 - Mainline Code that does the work.  #
#------------------------------------------------#
    
echo "${ME}: setting up ${BUILD_DIRECTORY} for ${CONFIGURATION_NAME}"

# Ensure configuration options are sensible.
checkConfigurationOptions

# Make a fresh start.
#
if (( cleanse )) && [[ -e ${BUILD_DIRECTORY} ]] # old directory exists; 
then 
    if [ -t 0 ]    # keyboard is live (ie. this is not an automated build)
    then
	## && [[ ! $EMACS ]] 
	## It would be nice to test whether we are running under EMACS's 
	## M-x compile mode.   But I do not know how to do that. 
 	got_EOF=""
	response="unset"
	status=0
	if ! read -n 1 -p "${ME}: ${BUILD_DIRECTORY} already exists, replace it? (y/n) --> " response; then
	    # Shell does not let us distinguish EOF from I/O errors.
	    got_EOF=1
	fi
	echo ""		# finish the line since our user did not type a newline' for us.
	if [[ $got_EOF ]]; then
	    echo >&2 "${ME}: Got EOF (End of File).  We won't write anything."
	    response=EOF
	fi
	if [[ $response != y* ]]; then
	    echo >&2 "${ME}: Operation aborted; nothing written."
	    trap '' EXIT
	    exit $Exit_Status_Bad_Args
	fi
    fi
    ( cd ${BUILD_DIRECTORY} && rm -rf * )
fi
if ! (( cleanse )) && ! (( quiet )); then
    echo " (writing new files, but not deleting old stuff)"
fi

# Create output directory structure.
#
mkdir -p ${BUILD_DIRECTORY}
mkdir -p ${GENERATED_FILES_DIRECTORY}
mkdir -p ${GENERATED_FILES_DIRECTORY}/instructionFormats
mkdir -p ${SCRATCH_DIRECTORY}
mkdir -p ${CLASSES_DIRECTORY}

(( quiet )) || echo -n "(directories created) "

# Create control files and scripts.
#
PERM=+r+w

function make_config_summary () {
    local s="$1"
    rm -f $s
    echo "configuration name: ${CONFIGURATION_NAME}" > $s
    echo "preprocessor definitions:"                 >>${s}
    echo "${PREPROCESSOR_DEFINITIONS}"   >> ${s}
    chmod ${PERM} ${s}
}

make_config_summary ${CONFIGURATION_SUMMARY}

(( cleanse )) && touch ${CLEANSE_STATUS}

f=$SOURCE_LIST
rm -f			$f
emitSourceList	      > $f
chmod ${PERM}		$f

f=${BUILD_DIRECTORY}/jbuild
rm -f			$f
emitController	      > $f
chmod +x${PERM}		$f

f=${BUILD_DIRECTORY}/jbuild.expand
rm -f			$f
emitExpander	      > $f
chmod +x${PERM}		$f

f=${BUILD_DIRECTORY}/jbuild.copy
rm -f			$f
emitCopier	      > $f
chmod +x${PERM}		$f

f=${BUILD_DIRECTORY}/jbuild.compile
rm -f			$f
emitCompiler	      > $f
chmod +x${PERM}		$f

f=${BUILD_DIRECTORY}/jbuild.linkImage
rm -f			$f
emitImageLinker       > $f  
chmod +x${PERM}         $f

f=${BUILD_DIRECTORY}/jbuild.linkBooter
rm -f			$f
emitBooterLinker      > $f
chmod +x${PERM}         $f

f=${BUILD_DIRECTORY}/jbuild.tool
rm -f			$f
emitToolCompiler      > $f
chmod +x${PERM}         $f

f=${BUILD_DIRECTORY}/jbuild.toolPrep
rm -f			$f
emitToolPreprocessor  > $f
chmod +x$PERM           $f

f=${BUILD_DIRECTORY}/jbuild.plugin
rm -f			$f
emitPluginBuilder     > $f
chmod +x$PERM		$f

# write the environment specific configuration files
#

# read the host environment file
. ${RVM_HOST_CONFIG}
export CURRENT_CONFIG_FILE=${RVM_HOST_CONFIG}

f=${BUILD_DIRECTORY}/Make.rules.host
rm -f		$f
emitMakefile	> $f
chmod -x${PERM}	$f

f=${BUILD_DIRECTORY}/environment.host
rm -f			$f
emitEnvironmentBash >	$f
chmod -x${PERM}		$f

# read the target environment file
. ${RVM_TARGET_CONFIG}
export CURRENT_CONFIG_FILE=${RVM_TARGET_CONFIG}

f=${BUILD_DIRECTORY}/Make.rules.target
rm -f $f
emitMakefile > $f
chmod -x${PERM} $f

f=${BUILD_DIRECTORY}/environment.target
rm -f $f
emitEnvironmentBash > $f
chmod -x${PERM}	$f

# write the GNU Classpath security properties file
#
f=${BUILD_DIRECTORY}/security/JikesRVM.security
rm -f $f
mkdir -p $(dirname $f)
echo "security.provider.1=gnu.java.security.provider.Gnu" > $f
chmod -x${PERM} $f

(( quiet )) || echo -n "(control files and scripts installed) "

if (( ! quiet )); then
    if [ -t 0 ]; then # keyboard is live (ie. this is not an automated build)
	echo ""
	echo "${ME}: ${CONFIGURATION_NAME} configuration is ready"
	echo "${ME}: To build it, type:"
	echo "${ME}:    cd ${BUILD_DIRECTORY}"
	echo "${ME}:    ./jbuild"
    else
	echo "done."
    fi
fi
trap '' EXIT
