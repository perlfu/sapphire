%      $Id$    

\newcommand{\vmInterfacePackageURL}{{\RVMJavadocURL}/memoryManagers/vmInterface/package-frame.html}
\newcommand{\BaseFreeListURL}{{\RVMJavadocURL}/BaseFreeList.html}
\newcommand{\MarkSweepCollectorURL}{{\RVMJavadocURL}/MarkSweepCollector.html}
\newcommand{\BumpPointerURL}{{\RVMJavadocURL}/BumpPointer.html}
\newcommand{\SharedQueueURL}{{\RVMJavadocURL}/SharedQueue.html}
\newcommand{\LocalSSBURL}{{\RVMJavadocURL}/LocalSSB.html}
\newcommand{\BasePlanURL}{{\RVMJavadocURL}/BasePlan.html}
\newcommand{\StopTheWorldGCURL}{{\RVMJavadocURL}/StopTheWorldGC.html}
\newcommand{\GenerationalURL}{{\RVMJavadocURL}/Generational.html}
\newcommand{\VMResourceURL}{{\RVMJavadocURL}/VMResource.html}

This section provides information on the implementation of JMTk, the
memory management component of Jikes\trademark RVM runtime system.

From Jikes\trademark RVM 2.2.0 onwards, JMTk (Java Memory management
Toolkit) replaced the `watson collectors' and GCTk.  JMTk is intended
to be a portable toolkit, with Jikes\trademark RVM-specific code
factored out as far as possible.

\subsection{Directory Structure and Packages} \label{sssec:directories}

JMTk classes are contained in the
\texttt{\$RVM\_ROOT/rvm/src/vm/memoryManagers/JMTk} directory.

In keeping with the goal of modularity and portability, as far as
possible Jikes\trademark RVM-specific code is factored out.  Such
VM-specific code resides in a separate package,
(\xlink{{\texttt{com.ibm.JikesRVM.memoryManagers.vmInterface}}{\vmInterfacePackageURL}}),
and can be found in the \texttt{vmInterface} sub-directory.  All other
code is part of the
\xlink{{\texttt{com.ibm.JikesRVM.memoryManagers.JMTk}}{\JMTkPackageURL}}
package.

The \texttt{plan} sub-directory contains classes that define
\emph{memory management plans}.  A plan specifies a particular
configuration of JMTk components which together define the memory
management strategy for a particular build of Jike\trademark RVM.  The
\texttt{policy} sub-directory contains classes implementing various
memory management policies (such as \xlink{{mark-sweep
    collection}{\MarkSweepCollectorURL}}, \xlink{{free-list
    allocation}{\BaseFreeListURL}}, \xlink{{bump-pointer
    allocation}{\BumpPointerURL}}, etc.).  The \texttt{utility}
sub-directory contains classes implementing generic utilities (such as
\xlink{{load-balancing parallel queues}{\SharedQueueURL}},
\xlink{{sequential store buffers}{\LocalSSBURL}}, etc.).

\subsection{Choosing a Garbage Collector} \label{ssec:choosinggc}

Depending on your purposes, you may choose to build Jikes RVM with one
of the following plans:
\begin{itemize}
\item \texttt{SemiSpace} (copying),
\item \texttt{MarkSweep} (non-copying),
\item \texttt{GenCopy} (classic copying generational),
\item \texttt{GenMS} (generational with mark-sweep mature space), or
\item \texttt{CopyMS} (non-generational copy/mark-sweep hybrid)
\end{itemize}
The relative performance of these collectors is highly dependant on
the application.  \texttt{GenMS} is probably a good starting point as
it has good performance in a wide range of situations.

All of the memory managers support finalization.  Moreover, a
collection can proceed even when some threads are executing in native
code. When a collection starts, threads in native code are blocked
from returning to Java code for the duration of that collection.

\subsection{Plans} \label{sssec:plans}
\index{garbage collection}
\index{stop-the-world garbage collection}

All plans must inherit from
\xlink{{\texttt{BasePlan}}{\BumpPointerURL}}, and all plans in
this release are ``stop the world'' collectors, so they all inherit
from \xlink{{\texttt{StopTheWorldGC}}{\StopTheWorldGCRL}}, which
implements basic stop the world GC functionality.  The two
generational collectors both inherit from
\xlink{{\texttt{Generational}}{\GenerationalURL}}, which includes
common nursery and write barrier implementations.

All JMTk plans support parallel allocation and collection.  To
minimize synchronization overheads, unsynchronized \emph{thread-local}
actions are distinguished from \emph{global} actions, which must only
be performed by a single thread.  Global state is held in each plan's
class variables, while instance variables reflect thread-local state,
each \texttt{Plan} instance bound to a
\xlink{{\texttt{VM\_Processor}}{\VMProcessorURL}} instance.

The basic functions of each plan include:
\begin{itemize}
\item Identifying a virtual memory layout (using
  \xlink{{\texttt{VMResource}}{\VMResourceURL}} to, for example, bind
  semi-spaces or the nursery to particular address ranges).
\item Providing allocation by binding suitable allocators to different
  \texttt{VMResource}s.
\item Invoking collection when necessary through the use of a
  \emph{polling} mechanism.
\item Applying the appropriate collection policies to objects
  encountered during the collection process (objects may be subject to
  different collection regimens depending on where they reside in
  memory).
\item Implementing read and write barriers if necessary.
\end{itemize}

It is not difficult to add your own memory management plan (allocator
and collector) to JMTk, especially if it uses the same ``stop the
world'' parallel collection strategy used by all the collectors in
this release.  A good way to start is to compare some of the different
plans and understand the significance of the differences.

The basic steps are:

\index{jconfigure script}
\index{VM\_Allocator class}
\begin{enumerate}
\item Create a new directory within the plan subdirectory, such as
  ``NewGC''.
\item Add a new configuration in {\tt \$RVM\_ROOT/rvm/config/build}
  which includes your new directory in the build.  Name it
  appropriately, such as ``BaseBaseNewGC''.
\item Modify {\tt \$RVM\_ROOT/rvm/bin/jconfigure} to handle the new
  collector sub-directory.
\item Copy some existing \texttt{Plan.java} file into your new
  directory, and modify it, choosing one that has similar properties,
  such as copying or non-copying.
\end{enumerate}

\subsection{Policy} \label{sssec:policy}
\subsection{Utility} \label{sssec:utility}
\subsection{VMInterface} \label{sssec:vminterface}

\end{description}

