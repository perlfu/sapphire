\begin{center}  
{\bf Jikes\trademark RVM Frequently Asked Questions}
\end{center}

\subsection{General}

For most general Jikes RVM questions and answers, see
\xlink{{\tt \QandAURL}}{\QandAURL}.

\subsubsection{What is Jikes RVM?} 

The short answer:
The Jikes Research Virtual Machine (Jikes RVM) is a software project
designed to provide the academic and research communities with a
flexible testbed that makes it possible to quickly prototype new
virtual machine technologies and experiment with different design
choices.  Jikes RVM executes Java\JavaTMFootnote\ programs useful for research on
fundamental virtual machine design issues.
It runs on the AIX\AIXTMFootnote/PowerPC\PowerPCTMFootnote,
Linux\LinuxRegisteredTMFootnote{}/PowerPC and Linux/IA-32, 
and exhibits industry-strength performance for many benchmark programs
on these platforms.  Jikes RVM includes the latest VM
technologies for dynamic compilation, adaptive optimization, garbage
collection, thread scheduling, and synchronization.

\subsubsection{Who is using Jikes RVM}
A list of current Jikes RVM researchers is available at
\xlink{{\tt \RVMUserListURL}}{\RVMUserListURL}.  If you would like to 
be added to the web page, let us know.

\subsubsection{Can I use Jikes RVM when teaching a class?}

Yes, this is fine under the
\xlink{Common Public License}{\CPLURL}.  In fact,  professors
have already done at both the graduate and undergraduate levels.
Teaching material and links to courses taught using Jikes RVM are
available at
\xlink{{\tt \RVMTeachingResourcesURL}}{\RVMTeachingResourcesURL}.

\subsubsection{Who can I contact with questions?}

Use the mailing lists available at 
\xlink{{\tt \RVMDownloadURL}}{\RVMDownloadURL}

\subsubsection{Which mailing list(s) should I subscribe to?}

We currently have the following four mailing lists:

\begin{description}
\item[jikesrvm-researchers]
    General discussion of Jikes RVM design, implementation, issues, and
    plans.
\item[jikesrvm-regression]
   Automatic mail messages and subsequent discussion regarding nightly
   regression runs.
\item[jikesrvm-announce]
  Infrequent announcements and news items.
\item[jikesrvm-core]
  Discussion of day-to-day development and design among Jikes RVM  core team
  members.
\end{description}


\subsubsection{How can I contribute to RVM?}
Bug reports or feature requests can be submitted directly at
\xlink{{\tt \RVMBugURL}}{\RVMBugURL}.  
Information about contributing bug fixes or extensions to the system
can be found at
\xlink{{\tt \RVMContribURL}}{\RVMContribURL}.   

\JavaTMFooter

\AIXPPCJikesTMFooter

\subsection{Getting RVM and Documentation}

\subsubsection{How do I get RVM?}

You can download the RVM source from DeveloperWorks at \xlink{{\tt
\RVMDownloadURL}}{\RVMDownloadURL}.  The RVM source is also available
through a public \xlink{CVS server}{\RVMCVSURL}.

\subsubsection{Is there a list of known bugs?}

See the bug tracking system available on DeveloperWorks at 
\xlink{{\tt \RVMBugURL}}{\RVMBugURL}.

The bug tracking lists {\em defects}, representing bugs in the system, and
{\em feature requests}, which are TODO items to improve the system.

\subsubsection{Is there documentation on-line?}

Yes.  See the RVM Home page at
\xlink{{\tt \RVMHomeURL}}{\RVMHomeURL}.

\subsubsection{Can I get the Quicksilver Quasi-Static System?}

No. This project is no longer active or supported.

\subsubsection{Can I get DejaVu?}

No. This project is not supported. 

\subsubsection{What happened to {\tt jdp}?}

The jdp debugger has been deprecated.  See
Section~\ref{section:debugging} for more details.

\subsection{Building RVM}


\subsubsection{What's the right value to use for
RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR?} 
\label{singleProcessorQuestion}

Jikes RVM can be built to support either $m$-to-$n$ or $m$-to-$1$
threading.  In $m$-to-$n$ threading
(RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR equals 0), the virtual machine
multiplexes $m$ Java 
onto $n$ virtual processors (operating system pthreads).
In $m$-to-$1$ threading (RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR equals 1),
all $m$ Java threads run on a single virtual processor.  Jikes RVM 
can only exploit multiple CPUs on a hardware SMP machine if 
built with RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR equal to 0.

Unfortunately, $m$-to-$n$ threading is not supported on all platforms due to
mismatches between Jikes RVM  and the host pthread implementation.  
The key issue is that because Jikes RVM multiplexes Java threads
(each with their own stack) onto operating system threads, the
C libraries it is linked with must not use the value of a thread's
stackpointer/framepointer to access pthread-local storage.  The
preferred values for RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR are as
follows: 
\begin{itemize}
\item {\tt AIX/PowerPC}: 0 (SMP is supported)
\item {\tt Linux/PowerPC}:  1 (SMP is not supported)
\item {\tt Linux 2.2/IA32}: 1 (SMP is not supported)
\item {\tt Linux 2.4/IA32}: 0 (SMP is supported), but with the
additional restriction that you must link with a version of glibc that
was compiled to use the GS segment register to access pthread-specific
state.  Depending on your Linux distribution, this may not be the
default for glibc. See a discussion in the archives for
jikesrvm-researchers from November of 2001. If your version of glibc
is not compiled this way, Jikes RVM  will usually fail by 'hanging' when
it is run.
\end{itemize}                

\subsubsection{Which jikes should I use?}
At Watson, we're currently using \xlink{{\tt jikes}}{\jikesURL} v1.18
to compile the RVM source on both Linux and
AIX\AIXTMFootnote. Previously we were using version 1.13. Version 1.14
through 1.17 have been reported to not entirely work with Jikes
RVM. For versions of Jikes RVM before 2.2.0, you must use jikes 1.13.

\subsubsection{Has anybody thought about incremental boot image writing?}

Incremental boot image building is not a trivial problem.  One big
issue is: if we change the implementation of one class in the boot image,
what other parts of the VM image must be invalidated?  One example: which
methods must be recompiled to reflect the new implementation?  We have no
mechanism in place to trace these kinds of dependencies.  There are other
examples, too.  In summary: incremental boot image writing would be nice,
but it's not easy to support, and it hasn't been at the top of our
priorities.

\subsubsection{Can I monitor progress during jbuild?}

Yes.  Use {\tt jbuild -trace} to see detailed progress.  Use {\tt
jbuild -help} to see a list of sub-options you can give to the {\tt
-trace} flag.

\subsubsection{How can I include my own classes in the boot image?}

The {\tt jconfigure} script defines which classes go in the boot image, by
spitting out the file {\tt \$RVM\_BUILD/RVM.primordials}.  By default, any
class with the {\tt VM\_} prefix in a defined directory set, goes in the
boot image.

You may choose to add more classes to the primordial list.  One way to do
this is to edit {\tt jconfigure}; look at the function {\tt
emitImageLinker}.  You will see that the script already puts certain other
non-VM classes in the primordial list (eg. {\tt java.lang.Object}).

\AIXTMFooter

\subsection{Runtime implementation}

\subsubsection{Does RVM have an interpreter?}

No.  RVM relies on two compilers, and compiles all methods to native code.

\subsubsection{Does RVM support JNI?}

Most JNI functionality is supported. A few functions are not. 
There are a few functions that are only supported on AIX\AIXTMFootnote
and some other functions that are only supported on Linux/IA32.

\subsubsection{Does RVM support user-defined class loaders?}
Yes, with the caveat that we do not verify linking constraints.

\subsubsection{Does RVM support the Java security model?} 

We believe we support it to the extent that the 
\xlink{GNU Classpath}{\classpathURL}  
libraries support it.

\subsubsection{Does RVM support serialization?}

We believe we support it to the extent that the 
\xlink{GNU Classpath}{\classpathURL}  
libraries support it. We have noticed that sometimes it doesn't
work exactly the same as in the Sun class library.

\subsubsection{Does RVM enforce the Java Memory Model?}

No. Depending on the architecture, various features of the memory model
are not implemented according to the current spec, to the best of our
understanding.

Known issues include:
\begin{itemize}
\item on PowerPC\PowerPCTMFootnote, the system does not enforce
sequential consistency for 
volatile variables
\item the system does not enforce atomicity of memory accesses for
doubleword values
\item by default, the optimizing compiler does not respect the "reads
kill" property.  However, there is a command-line option to enforce the
property, which constrains the optimizations.
\end{itemize}

\subsubsection{How do RVM's threads, Posix threads, and kernel
threads relate to each other?}

RVM implements an $m$-to-$n$ threading model, where $m$ is the number of 
Java threads and $n$ is the number of Posix threads (ie., pthreads).  RVM
does not know or care whether the Posix threads are implemented as kernel
threads or user-level level threads.  You can specify $n$, the number of
Posix threads to use, on the command line with {\tt -X:processors=n}.
You should normally set $n$ to be the number of physical processors on
your machine.  

In the source code, a 
\xlink{{\tt VM\_Thread}}{\VMThreadURL} 
is the base class for each Java
thread, and a 
\xlink{{\tt VM\_Processor}}{\VMProcessorURL} 
is the base class representing each
Posix thread.  

On some platforms, only $m$-to-1 threading is supported.  See 
question~\ref{singleProcessorQuestion}.

\subsubsection{What is the list of operations that may cause a GC?}

Any operation that allocates memory or causes memory to be allocated may
force a GC.  Some cases to look out for include:
\begin{itemize}
\item any instruction that throws an exception,
\item any call that may cause a stack overflow,
\item any monitorenter on a contended lock,
\item string concatenation, and
\item any thread-switch point may allow another thread to force GC.
\end{itemize}

\subsubsection{How can I implement a new GC algorithm?}

See the memory management section of the userguide.

\subsubsection{How does RVM enter native code?}

See the discussion in section~\ref{section:jni}. 

\subsubsection{What happens to thread switching while a thread is
executing native code?}
See the discussion in section~\ref{section:jni}. 

\subsubsection{How do the various locking and synchronization mechanisms
relate to each other?}

There are at least six ways to enforce mutual exclusion in the
RVM runtime.  For normal library code and most VM code, monitorenter and
monitorexit should suffice.  The lower-level primitives provide 
building blocks for implementing monitorenter and exit. Some VM systems,
such as thread scheduling and GC, resort to lower-level primitives for
situations where normal Java object locking is inconvenient or illegal.
\begin{description}
\item [VM\_Magic.prepare and VM\_Magic.attempt]
The RVM compiler translates these 
\xlink{VM\_Magic}{\VMMagicURL} 
calls into low-level
hardware-supported atomic sequences.  These low-level primitives are the 
building blocks for all other mutual exclusion mechanisms. 

The prepare call fetches the
contents of a memory location and begins a conditional critical section.
The attempt call ends the conditional critical section, and returns true
if and only there were no intervening writes to the guarded memory
location.

On PowerPC, the compilers implement prepare and attempt using the lwarx
and stwcx instructions.  On IA32, the compilers rely on CMPXCHG with the
LOCK prefix to implement attempt; prepare is a normal load instruction.
\item [\xlink{VM\_Synchronization}{\VMSynchronizationURL}]
This class implements some useful common low-level synchronization
sequences, such as fetch-and-add and test-and-set.  The VM\_Synchronization
primitives, in turn, are implemented using VM\_Magic.prepare and attempt.
\item [
\xlink{VM\_ProcessorLock}{\VMProcessorLockURL}
]
This lock is used to enforce mutual exclusion between {\tt VM\_Processors}
(pthreads.)  It provides a non-blocking attempt to require the lock
({\tt tryLock()}) as well as a blocking spin-lock ({\tt lock()}).
\item [
\xlink{VM\_Lock}{\VMLockURL}
]
This class provides the normal synchronization operations on Java objects
between Java threads.  The implementation is a variant of Thin Locks.
\item [monitorenter and monitorexit]
Synchronized statements in Java source code are compiled to monitorenter
and exit in the Java bytecode.  The RVM compilers implement these
bytecodes by inserting calls to \xlink{{\tt VM\_Lock}}{\VMLockURL} routines; 
the optimizing
compiler inlines the common cases.
\item [\xlink{VM\_GCLocks}{\VMGCLocksURL}]
This class simply encapsulates a number of VM\_Synchronization locks 
used for various purposes by the RVM GC system.

\end{description}

\subsubsection{Does RVM conform to Sun's JDK Host Porting Interface?}

No. There is nothing in RVM that remotely resembles HPI.

\JavaTMFooter

\AIXPPCTMFooter

\subsection{Libraries}

\subsubsection{Why don't you use the GNU Classpath libraries?}
As of version 2.2.1 we do.  

\subsubsection{Does RVM run awt?}

We believe we support it to the extent that the 
\xlink{GNU Classpath}{\classpathURL}  
libraries support it. 

\subsubsection{Can I run some standard library on RVM that is not included
in GNU classpath?}

You can try.  Set your classpath to pick up the library you desire.

\subsection{Optimizing Compiler}

\subsubsection{How can I force all dynamically compiled methods to be
compiled with the optimizing compiler?}
Use the command line argument {\tt -X:aos:initial\_compiler=opt} to the
adaptive system.  If you want to disable profile-driven recompilation,
you also need to give the command line argument 
{\tt -X:aos:enable\_recompilation=false}. 

\subsubsection{What is a PEI?}
PEI is our acronym for potentially excepting instruction.  This applies to
any instruction in the IR that may throw an exception.

\subsubsection{What is AOS?}
AOS stands for adaptive optimization system.

\subsubsection{Is there a difference between a GC safe point and a thread
switch point?}

Yes.  Every thread switch point is a GC safe point, but every GC safe point 
need not be a thread switch point.

A thread switch point is an instruction where the RVM thread scheduler may
intervene and cause a different Java\JavaTMFootnote\ thread (VM\_Thread) to
run on the current 
pthread (VM\_Processor), even if no exception is thrown.  
Thread switch points include yield points inserted in prologues, epilogues, 
and back edges, monitorenter and exits.

A GC safe point is any instruction where the compiler must generate a GC map, 
including every thread switch point.  In particular, every 
PEI is a GC point.

\subsubsection{How do I find the def of a register in SSA form?}

Use 
\xlink{{\tt OPT\_Register.getFirstDef()}}{\OPTRegisterURL}.

If this returns {\tt null}, then either a) the register is dead and it's definition has been eliminated, 
or b) the def-use chains are not up-to-date.

The def-use chains are not normally kept up-to-date incrementally.  To
recompute the def-use chains, call 
\xlink{{\tt OPT\_DefUse.computeDU(ir)}}{\OPTDefUseURL}. 
Most optimization passes over SSA form call this method at 
the beginning of the compiler phase.

\subsubsection{What is Heap Array SSA form?}

See the \xlink{SAS 2000 paper}{\SASPaperURL}, as well as comments in
\xlink{{\tt OPT\_SSA.java}}{\OPTSSAURL}.

\subsubsection{Is ABCD included?}

Version 2.0.0 through 2.2.0 of Jikes RVM included a derivative of the
prototype ABCD implementation used for the \xlink{PLDI 2000
paper}{\ABCDPaperURL}.  However, ABCD was {\em not} enabled by default.
The implementation was incorrect, as it checked only upper
bounds and not lower bounds. 

\subsubsection{Is escape analysis included?}

The interprocedural flow-sensitive escape analysis in the 
\xlink{OOSPLA 99 paper}{\EscapeAnalysisPaperURL} is not currently included.

However, the distribution includes a less-powerful flow-insensitive
escape analysis.  See  
\xlink{{\tt OPT\_SimpleEscape.java}}{\OPTSimpleEscapeURL}.

\subsubsection{How do I insert my new compiler pass in the optimizing
compiler driver?}

See section~\ref{sec:optdriver} of the userguide, which describes how to
add phases to class 
\xlink{{\tt OPT\_OptimizationPlanner}}{\OPTOptimizationPlannerURL}.

\subsubsection{What if I want my pass to do inter-procedural analysis?}

The normal RVM does not have a convenient entrypoint for IPA.  As Java is
a dynamic language, the RVM continually compiles methods as they are
invoked.  Each method is compiled individually.

You can use the {\tt OptTestHarness} driver to define a set of classes. 
This driver program loads a set of classes or methods defined on the
command line.  You can then add an entrypoint in {\tt OptTestHarness.java}
that calls your IPA after loading all the relevant classes.

If you come up with a general mechanism for this, please consider
contributing it back.

\subsubsection{What is the OptTestHarness?}

The OptTestHarness (see section \ref{opttestharness}) is a driver
program to run the optimizing compiler even on a BaseBase boot image.
This driver is useful for optimizing compiler development, since you
can use the driver to selectively compile individual methods with
certain options.

\subsection{Regression Tests}

\subsubsection{Where can I order or download the test programs 
SPECjvm98\trademark and SPECjbb2000\trademark?}

Information for ordering the SPEC benchmark suites can be found at
\xlink{http://www.spec.org}{\SPECURL}.
As you'll see from the site, there is a non-trivial charge for getting the
suites, although universities do get a discount.
However, because the license is institution-wide, you may want to check with
other researchers at your institution to see if they already have a license.

\JavaTMFooter
