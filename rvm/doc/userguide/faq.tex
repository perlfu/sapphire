\begin{center}  
{\bf RVM Frequently Asked Questions}
\end{center}

\subsection{General}

For most general Jikes RVM questions and answers, see
\xlink{{\tt \QandAURL}}{\QandAURL}.

\subsubsection{What is RVM?} 

The short answer:
The Jikes Research Virtual Machine (RVM) is a software project
designed to provide the academic and research communities with a
flexible testbed that makes it possible to quickly prototype new
virtual machine technologies and experiment with different design
choices. It executes Java\JavaTMFootnote programs useful for research on
fundamental virtual machine design issues.
It runs on the AIX\AIXTMFootnote/PowerPC\PowerPCTMFootnote,
Linux\copyright/PowerPC and Linux/IA-32, 
and exhibits industry-strength performance for many benchmark programs
on the first two of these platforms.  The RVM includes the latest VM
technologies for dynamic compilation, adaptive optimization, garbage
collection, thread scheduling, and synchronization.

\subsubsection{Who is using RVM?}
A list of current RVM researchers is available at
\xlink{{\tt \RVMUserListURL}}{\RVMUserListURL}.  If you would like to 
be added to the web page, let us know.

\subsubsection{Can I use RVM when teaching a class?}

Yes, this is fine under the
\xlink{Common Public License}{\CPLURL}

\subsubsection{Who can I contact with questions?}

Use the mailing lists available at 
\xlink{{\tt \RVMDownloadURL}}{\RVMDownloadURL}

\subsubsection{Which mailing list(s) should I subscribe to?}

We currently have the following four mailing lists:

\begin{description}
\item[jikesrvm-researchers]
    General discussion of Jikes RVM design, implementation, issues, and
    plans.
\item[jikesrvm-regression]
   Automatic mail messages and subsequent discussion regarding nightly
   regression runs.
\item[jikesrvm-announce]
  Infrequent announcements and news items.
\item[jikesrvm-core]
  Discussion of day-to-day development and design among JikesRVM core team
  members.
\end{description}


\subsubsection{How can I contribute to RVM?}
Bug reports or feature requests can be submitted directly at
\xlink{{\tt \RVMBugURL}}{\RVMBugURL}.  We have not worked out a formal
process for code contributions just yet, but hope to have it in place
soon.  We expect to follow the 
model of other successful open-source projects.  For now, if you'd like to
contribute code, let us know.

{\em Word to the wise potential contributor:} we cannot accept any
contributions that infringe on anyone's intellectual property rights or
copyrights.

\JavaTMFooter

\AIXTMFooter

\PowerPCTMFooter

\JikesTMFooter

\subsection{Getting RVM and Documentation}

\subsubsection{How do I get RVM?}

You need to download two bundles: the RVM source, and the RVM standard library
jar file.  Each of these is available for download from DeveloperWorks at
\xlink{{\tt \RVMDownloadURL}}{\RVMDownloadURL}.  
The RVM source is also available through a 
public 
\xlink{CVS server}{\RVMCVSURL}.

You can also download the source to the libraries under
a separate 
\xlink{license}{\RVMLibSourceLicenseURL}.

\subsubsection{Is there a list of known bugs?}

See the bug tracking system available on DeveloperWorks at 
\xlink{{\tt \RVMBugURL}}{\RVMBugURL}.

The bug tracking lists {\em defects}, representing bugs in the system, and
{\em features}, which are TODO items to improve the system.

\subsubsection{Is there documentation on-line?}

Yes.  See the RVM Home page at
\xlink{{\tt \RVMHomeURL}}{\RVMHomeURL}.

\subsubsection{Can I get the Quicksilver Quasi-Static System?}

No. This project is no longer active or supported.

\subsubsection{Can I get DejaVu?}

Not yet.  The \xlink{DejaVu}{\DejavuURL} team hopes to 
release some code shortly.

\subsection{Building RVM}


\subsubsection{What's the right value to use for
RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR?} 

JikesRVM can be built to support either $m$-to-$n$ or $m$-to-$1$
threading.  In $m$-to-$n$ threading
(RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR equals 0), $m$ Java threads are
multiplexed on to $n$ virtual processors (operating system pthreads).
In $m$-$1$ threading (RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR equals 1),
all $m$ Java threads are run on a single virtual processor.  JikesRVM
can only exploit multiple CPUs on a hardware SMP machine if it is
built with RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR equal to 0.

Unfortunately, this is not supported on all platforms due to
mismatches between JikesRVM and the host pthread implementation.  
The key issue is that because JikesRVM is multiplexing Java threads
(each with their own stack) onto operating system threads, the
C libraries it is linked with must not use the value of a thread's
stackpointer/framepointer to access pthread-local storage.  The
preferred values for RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR are as
follows: 
\begin{itemize}
\item {\tt AIX/PowerPC}: 0 (SMP is supported)
\item {\tt Linux/PowerPC}:  1 (SMP is not supported)
\item {\tt Linux 2.2/IA32}: 1 (SMP is not supported)
\item {\tt Linux 2.4/IA32}: 0 (SMP is supported), but with the
additional restriction that you must link with a version of glibc that
was compiled to use the GS segment register to access pthread-specific
state.  Depending on your Linux distribution, this may not be the
default for glibc. See a discussion in the archives for
jikesrvm-researchers from November of 2001. If your version of glibc
is not compiled this way, JikesRVM will usually fail by 'hanging' when
it is run.
\end{itemize}                

\subsubsection{Which jikes should I use?}
At Watson, we're currently using 
\xlink{{\tt jikes}}{\jikesURL} v1.13 to compile the RVM source on
both Linux and AIX\AIXTMFootnote.  We've had reports from users that
v1.14 has problems 
on Linux.  In order to build the {\tt rvmrt.jar} library, we applied 
patch 62
to the jikes build to fix a jikes scoping problem.


\subsubsection{Has anybody thought about incremental boot image writing?}

Incremental boot image building is not a trivial problem.  One big
issue is: if we change the implementation of one class in the boot image,
what other parts of the VM image must be invalidated?  One example: which
methods must be recompiled to reflect the new implementation?  We have no
mechanism in place to trace these kinds of dependencies.  There are other
examples, too.  In summary: incremental boot image writing would be nice,
but it's not easy to support, and it hasn't been at the top of our
priorities.

\subsubsection{Can I recompile the RVM classes without rebuilding the boot
image?}

Yes.  Use {\tt jbuild -nolink}. This will copy, preprocess, and compile
the RVM source files, but will not re-link the boot image.  This is
extremely useful for development, when the modified classes do not go in
the boot image.

\subsubsection{Can I monitor progress during jbuild?}

Yes.  Use {\tt jbuild -trace} to see detailed progress. 

\subsubsection{How can I include my own classes in the boot image?}

The {\tt jconfigure} script defines which classes go in the boot image, by
spitting out the file {\$RVM\_BUILD/RVM.primordials}.  By default, any
class with the {\tt VM\_} prefix in a defined directory set, goes in the
boot image.

You may choose to add more classes to the primordial list.  One way to do
this is to edit {\tt jconfigure}; look at the function {\tt
emitImageLinker}.  You will see that the script already puts certain other
non-VM classes in the primordial list (eg. {\tt java.lang.Object}).

\AIXTMFooter

\subsection{Runtime implementation}

\subsubsection{Does RVM have an interpreter?}

No.  RVM relies on two compilers, and compiles all methods to native code.

\subsubsection{Does RVM support JNI?}

Most JNI functionality is supported. A few functions are not. 
Some functions are supported on AIX\AIXTMFootnote,
but not Linux.

\subsubsection{Does RVM support user-defined class loaders?}

No. Some class loader functionality is hacked around, delegating all
function to the system class loader.  

%% We can't put footnotes in section headings, so we specialize
\html{\subsubsection{Does RVM support the Java\trademark 2
security model?}} 

\texonly{\subsubsection{Does RVM support the Java
security model?}} 

No. 

\subsubsection{Does RVM support serialization?}

Sort of.  RVM provides enough serialization support to run some codes.  
However, serialization of classes in our class library may not match
serialization as implemented in the Sun class library.

\subsubsection{Does RVM enforce the Java Memory Model?}

No. Depending on the architecture, various features of the memory model
are not implemented according to the current spec, to the best of our
understanding.

Known issues include:
\begin{itemize}
\item on PowerPC\PowerPCTMFootnote, the system does not enforce
sequential consistency for 
volatile variables
\item the system does not enforce atomicity of memory accesses for
doubleword values
\item by default, the optimizing compiler does not respect the "reads
kill" property.  However, there is a command-line option to enforce the
property, which constrains the optimizations.
\end{itemize}


\subsubsection{Does RVM support zip files?}

Sort of.  RVM includes enough zip support to read compressed jar files.
For complete java.util.zip functionality, you are recommended to find 
a pure Java implementation of java.util.zip.  We have successfully used
\xlink{JazzLib}{\jazzlibURL}. 

\subsubsection{Why doesn't the RVM source use packages?}

This is a historical artifact.  In the early days of the project, we did
not want to be constrained by a package structure to a particular
directory structure.  With the current build process, this is not an
issue, and we may incrementally add package structure to the
implementation over time.

\subsubsection{How do RVM's threads, Posix threads, and kernel
threads relate to each other?}

RVM implements an $m$-to-$n$ threading model, where $m$ is the number of 
Java threads and $n$ is the number of Posix threads (ie., pthreads).  RVM
does not know or care whether the Posix threads are implemented as kernel
threads or user-level level threads.  You can specify $n$, the number of
Posix threads to use, on the command line with {\tt -X:processors=n}.
You should normally set $n$ to be the number of physical processors on
your machine.  

In the source code, a 
\xlink{{\tt VM\_Thread}}{\VMThreadURL} 
is the base class for each Java
thread, and a 
\xlink{{\tt VM\_Processor}}{\VMProcessorURL} 
is the base class representing each
Posix thread.  

\subsubsection{What are the semantics of VM\_Uninterruptible?}

The actual semantics of uninterruptibility are: if a class 
extends 
\xlink{{\tt VM\_Uninterruptible}}{\VMUninterruptibleURL}
, then the compiler will not
generate yield points in methods of the class.  So, there will be no
timer-driven thread switches caused by SIGALARMs in these methods.
Additionally, the compiler will {\em not} check for stack overflow in the
method prologue.  So, an uninterruptible method will never cause a stack
overflow trap.  

You should exercise extreme caution when modifying uninterruptible code.  It
is generally not legal (although not enforced) to throw an exception or 
cause GC from an uninterruptible method.  Uninterruptible code should not
call interruptible code. Furthermore, any uninterruptible method should
not need more stack space than specified in VM\_StackFrameLayoutConstants
for the stack ``guard'' area.

It is perhaps unfortunate that the uninterruptible attribute is currently
specified on a class level.  In some cases, we have declared an entire
class uninterruptible, even though only a few methods of the class are
really not safe to interrupt.  We would like to someday use a finer-grain
mechanism by which to annotate individual methods as uninterruptible.

\subsubsection{What is the list of operations that may cause a GC?}

Any operation that allocates memory or causes memory to be allocated may
force a GC.  Some cases to look out for include:
\begin{itemize}
\item any instruction that throws an exception,
\item any call that may cause a stack overflow,
\item any monitorenter on a contended lock,
\item string concatenation, and
\item any thread-switch point may allow another thread to force GC.
\end{itemize}

\subsubsection{How can I implement a new GC algorithm?}

See the memory management section of the userguide.

\subsubsection{How does RVM enter native code?}

There are two mechanisms whereby RVM may transition from Java to native
code.

The first mechanism is when RVM calls a method through a VM {\tt syscall}
method.  These native methods are non-blocking system calls or C library 
services.  To implement a syscall, the RVM compilers generate a call
sequence consistent with the platform's underlying calling convention.
A {\tt syscall} is not a GC-safe point, so {\tt syscalls} may modify the
Java heap (eg. memcpy).

The second mechanism is JNI.  Naturally, the user writes JNI code 
using the JNI interface.  RVM implements a call to JNI with a special JNI
compiler that generates a stub routine stack frame that manages the
transition between Java and native code.  The thread system implements 
recovery mechanisms to deal with JNI methods that block or otherwise fail
to return to Java promptly.  A JNI call is a GC-safe point, since JNI code
cannot freely modify the Java heap.

\subsubsection{What happens to thread switching while a thread is
executing native code?}

There are two ways to execute native code: {\tt syscalls} and JNI.
A Java thread that calls native code by either mechanism will never
be preempted by RVM.  As far as RVM is concerned, a Java thread that
enters native code 'owns' the underlying {\tt VM\_Processor} (pthread)
until it returns to Java.  Of course the OS may preempt the underlying
pthread; this falls beyond RVM's control.

Some activities (eg. GC) require all threads currently running Java to halt.  
So what happens when one Java thread forces a GC while another Java thread is
executing native code?

If the native code is a {\tt syscall}, then the VM stalls until the native
code returns.  Thus, all {\tt syscalls} should be non-blocking
operations that return fairly soon.  Note that a {\tt syscall} is 
{\em not} a GC-safe point.

If the native code is JNI (outside RVM control), then the thread system
will wait for a while, eventually declare the underlying pthread "out to
lunch", and continue execution with the remaining pthreads.  Note that 
JNI code is a GC safe point; non-malicious correct native code cannot
perturb the Java heap without notifying the RVM through a JNI method
invocation.  Hopefully the userguide will soon describe this in more
detail.

See section~\ref{sec:threads} for more details on the thread system.

\subsubsection{How do the various locking and synchronization mechanisms
relate to each other?}

There are at least six ways to enforce mutual exclusion in the
RVM runtime.  For normal library code and most VM code, monitorenter and
monitorexit should suffice.  The lower-level primitives provide 
building blocks for implementing monitorenter and exit. Some VM systems,
such as thread scheduling and GC, resort to lower-level primitives for
situations where normal Java object locking is inconvenient or illegal.
\begin{description}
\item [VM\_Magic.prepare and VM\_Magic.attempt]
The RVM compiler translates these 
\xlink{VM\_Magic}{\VMMagicURL} 
calls into low-level
hardware-supported atomic sequences.  These low-level primitives are the 
building blocks for all other mutual exclusion mechanisms. 

The prepare call fetches the
contents of a memory location and begins a conditional critical section.
The attempt call ends the conditional critical section, and returns true
if and only there were no intervening writes to the guarded memory
location.

On PowerPC, the compilers implement prepare and attempt using the lwarx
and stwcx instructions.  On IA32, the compilers rely on CMPXCHG with the
LOCK prefix.
\item [\xlink{VM\_Synchronization}{\VMSynchronizationURL}]
This class implements some useful common low-level synchronization
sequences, such as fetch-and-add and test-and-set.  The VM\_Synchronization
primitives, in turn, are implemented using VM\_Magic.prepare and attempt.
\item [
\xlink{VM\_ProcessorLock}{\VMProcessorLockURL}
]
This lock is used to enforce mutual exclusion between {\tt VM\_Processors}
(pthreads.)  It provides a non-blocking attempt to require the lock
({\tt tryLock()}) as well as a blocking spin-lock ({\tt lock()}).
\item [
\xlink{VM\_Lock}{\VMLockURL}
]
This class provides the normal synchronization operations on Java objects
between Java threads.  The implementation is a variant of Thin Locks.
\item [monitorenter and monitorexit]
Synchronized statements in Java source code are compiled to monitorenter
and exit in the Java bytecode.  The RVM compilers implement these
bytecodes by inserting calls to \xlink{{\tt VM\_Lock}}{\VMLockURL} routines; 
the optimizing
compiler inlines the common cases.
\item [\xlink{VM\_GCLocks}{\VMGCLocksURL}]
This class simply encapsulates a number of VM\_Synchronization locks 
used for various purposes by the RVM GC system.

\end{description}

\subsubsection{What causes VM\_JNIEnvironment.setNames() to run?}
This function, like many others in the RVM, is called during the RVM boot
sequence.

\subsubsection{Does RVM conform to Sun's JDK Host Porting Interface?}

No. There is nothing in RVM that remotely resembles HPI.

\JavaTMFooter

\AIXTMFooter

\PowerPCTMFooter

\subsection{Libraries}

\subsubsection{Does RVM run awt?}

Not currently.  We've tried this recently; RVM does not currently provide
all the JNI support needed for awt.  We have not looked into how difficult
it would be to provide the missing JNI support.

\subsubsection{Can I run some standard library on RVM that is not included
in rvmrt.jar?}

You can try.  Set your classpath to pick up the library you desire.

\subsection{Optimizing Compiler}

\subsubsection{What is a PEI?}
PEI is our acronym for potentially excepting instruction.  This applies to
any instruction in the IR that may throw an exception.

\subsubsection{What is AOS?}
AOS stands for adaptive optimization system.

\subsubsection{Is there a difference between a GC safe point and a thread
switch point?}

Yes.  Every thread switch point is a GC safe point, but every GC safe point 
need not be a thread switch point.

A thread switch point is an instruction where the RVM thread scheduler may
intervene and cause a different Java\JavaTMFootnote thread (VM\_Thread) to
run on the current 
pthread (VM\_Processor), even if no exception is thrown.  
Thread switch points include yield points inserted in prologues, epilogues, 
and back edges, monitorenter and exits.

A GC safe point is any instruction where the compiler must generate a GC map, 
including every thread switch point.  In particular, every 
PEI is a GC point.

\subsubsection{How do I find the def of a register in SSA form?}

Use 
\xlink{{\tt OPT\_Register.getFirstDef()}}{\OPTRegisterURL}.

If this returns {\tt null}, then either a) the register is dead and it's definition has been eliminated, or b) the def-use chains are not up-to-date.

The def-use chains are not normally kept up-to-date incrementally.  To
recompute the def-use chains, call 
\xlink{{\tt OPT\_DefUse.computeDU(ir)}}{\OPTDefUseURL}. 
Most optimization passes over SSA form call this method at 
the beginning of the compiler phase.

\subsubsection{What is Heap Array SSA form?}

See the \xlink{SAS 2000 paper}{\SASPaperURL}, as well as comments in
\xlink{{\tt OPT\_SSA.java}}{\OPTSSAURL}.

\subsubsection{Is ABCD included?}

The open-source distribution includes a derivative of the prototype ABCD 
implementation used for the 
\xlink{PLDI 2000 paper}{\ABCDPaperURL}.
However, ABCD is {\em not} enabled by default.  The current implementation
is incorrect, as it checks only upper bounds and not lower bounds.
There is a command-line option to turn on the current implementation.

\subsubsection{Is escape analysis included?}

The interprocedural flow-sensitive escape analysis in the 
\xlink{OOSPLA 99 paper}{\EscapeAnalysisPaperURL} is not currently included.

However, the distribution includes a less-powerful flow-insensitive
escape analysis.  See  
\xlink{{\tt OPT\_SimpleEscape.java}}{\OPTSimpleEscapeURL}.

\subsubsection{How do I insert my new compiler pass in the optimizing
compiler driver?}

See section~\ref{sec:optdriver} of the userguide, which describes how to
add phases to class 
\xlink{{\tt OPT\_OptimizationPlanner}}{\OPTOptimizationPlannerURL}.

\subsubsection{What if I want my pass to do inter-procedural analysis?}

The normal RVM does not have a convenient entrypoint for IPA.  As Java is
a dynamic language, the RVM continually compiles classes as they are
loaded.  Each method is compiled individually.

You can use the {\tt OptTestHarness} driver to define a set of classes. 
This driver program loads a set of classes or methods defined on the
command line.  You can then add an entrypoint in {\tt OptTestHarness.java}
that calls your IPA after loading all the relevant classes.

If you come up with a general mechanism for this, please consider
contributing it back.

\subsubsection{What is the OptTestHarness?}

The OptTestHarness (see section \ref{opttestharness}) is a driver
program to run the optimizing compiler even on a BaseBase boot image.
This driver is useful for optimizing compiler development, since you
can use the driver to selectively compile individual methods with
certain options.

\subsection{Regression Tests}
\subsubsection{Where can I order or download the test programs 
SPECjvm98\trademark and SPECjbb2000\trademark?}



Information for ordering the SPEC benchmark suites can be found at
\xlink{http://www.spec.org}{\SPECURL}.
As you'll see from the site, there is a non-trivial charge for getting the
suites, although universities do get a discount.
However, because the license is institution-wide, you may want to check with
other researchers at your institution to see if they already have a license.

\JavaTMFooter
