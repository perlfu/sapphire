\begin{center}
{\bf RVM Frequently Asked Questions}
\end{center}

\subsection{General}

\subsubsection{What is RVM?}

The Jikes Research Virtual Machine (RVM) is a software project designed to 
execute a subset of the Java Virtual Machine specification.  It provides a
flexible testbed that makes it possible to quickly prototype new
virtual machine technologies and experiment with different design
choices.  It runs on the AIX/PowerPC, Linux/PowerPC and Linux/IA-32,
and exhibits industry-strength performance for many benchmark programs
on the first two of these platforms.  The RVM includes the latest VM
technologies for dynamic compilation, adaptive optimization, garbage
collection, thread scheduling, and synchronization.

\subsubsection{How is RVM different from other virtual machines?}

A unique characteristic of the RVM is that it is implemented in the
Java programming language, unlike other virtual machines that are
implemented in "native code" (typically, C or C++).  A Java
implementation provides ease of portability, and a uniform memory
space for virtual machine objects and application objects.  Though
there have been a few prior examples of virtual machines implemented
in Java, all those cases dependend on the presence of a second
underlying Java virtual machine and incurred large (100x-1000x)
performance slowdowns as a result.  
The RVM is unique in that it is
the the first self-bootstrapped virtual machine written entirely in
Java i.e., its Java code runs on itself, without requiring a second
virtual machine.

\subsubsection{Is the RVM appropriate for all programmers?}

No, the RVM is primarily for researchers.  The RVM is inadequate
for programmers who need a complete Java platform, since it has
incomplete functionality.  The RVM does not support many libraries
(e.g., AWT, Swing, J2EE), user-defined class loaders, security
manager, bytecode verification, and many other features that need to
be present in a production virtual machine.

\subsubsection{Was RVM once called \jp? What's the difference?}

Yes. There is no difference.  The RVM is the open-source release of
code developed in the \jp project.

Call a pepper by any other name, and does it
not still burn your mouth?


\subsubsection{Isn't this a Java Virtual Machine?}
No, the RVM is not a JVM. The RVM supports only a subset of the
Java Virtual Machine specification. This functionality is sufficient
to run benchmarks programs such as SPECjvm98, but is insufficient to
allow the RVM to run enterprise Java applications or typical client
applets. That's why it's called the RVM and not a JVM.

\subsubsection{So this is a "stripped down" JVM?}
No, it's not that either. The RVM code was independently developed
from the ground-up by a team in IBM Research.  It was written as a
test-bed for evaluating new virtual machine technologies. It was not
written to be a complete JVM.


\subsubsection{Why open-source?}
IBM is committed to open source and open standards.  We would like
to work with and contribute to open source communities.  By
open-sourcing RVM, we hope to accelerate progress in developing
next-generation virtual machine technologies at universities.

\subsubsection{Is IBM going to turn this into a JVM?}
No, there is already several JVMs in wide circulation that pass
all Sun conformance tests - including several available from IBM as
part of larger technology bundles. IBM will not be devoting resources
to evolving the RVM code into a full JVM. It would take a significant
effort and simply duplicate what is already available. As said
earlier, the RVM allows the academic and research communities to
investigate fundamental virtual machine technologies like dynamic
compilation, adaptive optimization, garbage collection, thread
scheduling, and synchronization.

\subsubsection{Who is using RVM?}
\remark{TODO. add url}

\subsection{Getting RVM and Documentation}

\subsubsection{How do I get RVM?}

You need to download two bundles: the RVM source, and the RVM standard library
jar file.  Each of these is available for download from DeveloperWorks at
\remark{TODO! insert URL}.  
The RVM source is also available through a public CVS server 
\remark{TODO.  URL}. 

You can also download the source to the libraries \remark{TODO URL} under
a separate license. \remark{TODO URL}

\subsubsection{Is there a list of known bugs?}

See the bug tracking system available on DeveloperWorks at 
\remark{TODO URL}.

The bug tracking lists {\em defects}, representing bugs in the system, and
{\em features}, which are TODO items to improve the system.

\subsubsection{Is there documentation on-line?}

Yes.  See
\remark{TODO URL}


\subsubsection{Can I get the Quicksilver Quasi-Static System?}

No. This project is no longer active or supported.

\subsection{Licenses}

The RVM implementation is licensed open-source under the Common Public
License. \remark{TODO URL} There are separate, more restrictive licenses 
for the binary and 
source to the Java standard libraries for RVM.  See the DeveloperWorks
web pages for more details. \remark{TODO URL}

\subsection{Building RVM}

\subsubsection{Which jikes should I use?}
\remark{TODO URL}
At Watson, we're currently using jikes v1.13 to compile the RVM source on
both Linux and AIX.  We've had reports from users that v1.14 has problems
on Linux.  In order to build the rvmrt.jar library, we applied patch 62 to
the jikes build to fix a jikes scoping problem.


\subsubsection{Has anybody thought about incremental boot image writing?}

Incremental boot image building is not a trivial problem.  One big
issue is: if we change the implementation of one class in the boot image,
what other parts of the VM image must be invalidated?  One example: which
methods must be recompiled to reflect the new implementation?  We have no
mechanism in place to trace these kinds of dependencies.  There are other
examples, too.  In summary: incremental boot image writing would be nice,
but it's not easy to support, and it hasn't been at the top of our
priorities.

\subsection{Runtime implementation}

\subsubsection{Does RVM have an interpreter?}

No.  RVM relies on two compilers, and compiles all methods to native code.

\subsubsection{Does RVM support JNI?}

Most JNI functionality is supported.  Some functions are supported on AIX
but not Linux.

\subsubsection{Does RVM support user-defined class loaders?}

No. Some class loader functionality is hacked around, delegating all
function to the system class loader.  

\subsubsection{Does RVM support the Java 2 security model?}

No. 

\subsubsection{Does RVM support serialization?}

Sort of.  RVM provides enough serialization support to run some codes.  
However, serialization of classes in our class library may not match
serialization as implemented in the Sun class library.

\subsubsection{Does RVM enforce the Java Memory Model?}

No. Depending on the architecture, various features of the memory model
are not implemented according to the current spec, to the best of our
understanding.

Known issues include:
\begin{itemize}
\item on PowerPC, the system does not enforce sequential consistency for
volatile variables
\item the system does not enforce atomicity of memory accesses for
doubleword values
\item by default, the optimizing compiler does not respect the "reads
kill" property.  However, there is a command-line option to enforce the
property, which constrains the optimizations.
\end{itemize}


\subsubsection{Does RVM support zip files?}

Sort of.  RVM includes enough zip support to read compressed jar files.
For complete java.util.zip functionality, you are recommended to find 
a pure Java implementation of java.util.zip.  We have successfully used
JazzLib. \remark{add URL here}

\subsubsection{Why doesn't the RVM source use packages?}

This is a historical artifact.  In the early days of the project, we did
not want to be constrained by a package structure to a particular
directory structure.  With the current build process, this is not an
issue, and we may incrementally add package structure to the
implementation over time.

\subsubsection{How do RVM's threads, Posix threads, and kernel
threads relate to each other?}

RVM implements an $m$-to-$n$ threading model, where $m$ is the number of 
Java threads and $n$ is the number of Posix threads (ie., pthreads).  RVM
does not know or care whether the Posix threads are implemented as kernel
threads or user-level level threads.  You can specify $n$, the number of
Posix threads to use, on the command line with {\tt -X:processors=n}.
You should normally set $n$ to be the number of physical processors on
your machine.  Note that in the current (2.0.0) release, only $n=1$ is
supported on Linux.

In the source code, a {\tt VM\_Thread} is the base class for each Java
thread, and a {\tt VM\_Processor} is the base class representing each
Posix thread.  

\subsubsection{What are the semantics of VM\_Uninterruptible?}

The actual semantics of uninterruptibility are: if a class 
extends {\tt VM\_Uninterruptible}, then the compiler will not
generate yield points in methods of the class.  So, there will be no
timer-driven thread switches caused by SIGALARMs in these methods.
Additionally, the compiler will {\em not} check for stack overflow in the
method prologue.  So, an uninterruptible method will never cause a stack
overflow trap.  

You should exercise extreme caution when modifying uninterruptible code.  It
is generally not legal (although not enforced) to throw an exception or 
cause GC from an uninterruptible method.  Uninterruptible code should not
call interruptible code. Furthermore, any uninterruptible method should
not need more stack space than specified in VM\_StackFrameLayoutConstants
for the stack ``guard'' area.

It is perhaps unfortunate that the uninterruptible attibute is currently
specified on a class level.  In some cases, we have declared an entire
class uninterruptible, even though only a few methods of the class are
really not safe to interrupt.  We would like to someday use a finer-grain
mechanism by which to annotate individual methods as uninterruptible.

\subsubsection{What is the list of operations that may cause a GC?}

Any operation that allocates memory or causes memory to be allocated may
force a GC.  Some cases to look out for include:
\begin{itemize}
\item any instruction that throws an exception,
\item any call that may cause a stack overflow,
\item any monitorenter on a contended lock,
\item string concatenation, and
\item any thread-switch point may allow another thread to force GC.
\end{itemize}

\subsubsection{How does RVM enter native code?}

There are two mechanisms whereby RVM may transition from Java to native
code.

The first mechanism is when RVM calls a method through a VM {\tt syscall}
method.  These native methods are non-blocking system calls or C library 
services.  To implement a syscall, the RVM compilers generate a call
sequence consistent with the platform's underlying calling convention.
A {\tt syscall} is not a GC-safe point, so {\tt syscalls} may modify the
Java heap (eg. memcpy).

The second mechanism is JNI.  Naturally, the user writes JNI code 
using the JNI interface.  RVM implements a call to JNI with a special JNI
compiler that generates a stub routine stack frame that manages the
transition between Java and native code.  The thread system implements 
recovery mechanisms to deal with JNI methods that block or otherwise fail
to return to Java promptly.  A JNI call is a GC-safe point, since JNI code
cannot freely modify the Java heap.

\subsubsection{What happens to thread switching while a thread is
executing native code?}

\remark{TODO: hopefully someone will write a userguide section describing
the thread system.}

There are two ways to execute native code: {\tt syscalls} and JNI.
A Java thread that calls native code by either mechanism will never
be preempted by RVM.  As far as RVM is concerned, a Java thread that
enters native code 'owns' the underlying {\tt VM\_Processor} (pthread)
until it returns to Java.  Of course the OS may preempt the underlying
pthread; this falls beyond RVM's control.

Some activities (eg. GC) require all threads currently running Java to halt.  
So what happens when one Java thread forces a GC while another Java thread is
executing native code?

If the native code is a {\tt syscall}, then the VM stalls until the native
code returns.  Thus, all {\tt syscalls} should be non-blocking
operations that return fairly soon.  Note that a {\tt syscall} is 
{\em not} a GC-safe point.

If the native code is JNI (outside RVM control), then the thread system
will wait for a while, eventually declare the underlying pthread "out to
lunch", and continue execution with the remaining pthreads.  Note that 
JNI code is a GC safe point; non-malicious correct native code cannot
perturb the Java heap without notifying the RVM through a JNI method
invocation.  Hopefully the userguide will soon describe this in more
detail.

\subsubsection{How do the various locking and synchronization mechanisms
relate to each other?}

There are at least six ways to enforce mutual exclusion in the
RVM runtime.  For normal library code and most VM code, monitorenter and
monitorexit should suffice.  The lower-level primitives provide 
building blocks for implementing monitorenter and exit. Some VM systems,
such as thread scheduling and GC, resort to lower-level primitives for
situations where normal Java object locking is inconvenient or illegal.
\begin{description}
\item [VM\_Magic.prepare and VM\_Magic.attempt]
The RVM compiler translates these calls into low-level
hardware-supported atomic sequences.  These low-level primitives are the 
building blocks for all other mutual exclusion mechanisms. 

The prepare call fetches the
contents of a memory location and begins a conditional critical section.
The attempt call ends the conditional critical section, and returns true
if and only there were no intervening writes to the guarded memory
location.

On PowerPC, the compilers implement prepare and attempt using the lwarx
and stwcx instructions.  On IA32, the compilers rely on CMPXCHG with the
LOCK prefix.
\item [VM\_Synchronization]
This class implements some useful common low-level synchronization
sequences, such as fetch-and-add and test-and-set.  The VM\_Sychronization
primities, in turn, are implemented using VM\_Magic.prepare and attempt.
\item [VM\_ProcessorLock]
This lock is used to enforce mutual exclusion between {\tt VM\_Processors}
(pthreads.)  It provides a non-blocking attempt to require the lock
({\tt tryLock()}) as well as a blocking spin-lock ({\tt lock()}).
\remark{TODO: add pointer to URL}
\item [VM\_Lock]
This class provides the normal synchronization operations on Java objects
between Java threads.  The implementation is a variant of Thin Locks.
\remark{TODO: add pointer to URL}
\item [monitorenter and monitorexit]
Synchronized statements in Java source code are compiled to monitorenter
and exit in the Java bytecode.  The RVM compilers implement these
bytecodes by inserting calls to {\tt VM\_Lock} routines; the optimizing
compiler inlines the common cases.
\item [VM\_GCLocks]
This class simply encapsulates a number of VM\_Synchronization locks 
used for various purposes by the RVM GC system.

\end{description}

\subsubsection{What causes VM\_JNIEnvironment.setNames() to run?}
This function, like many others in the RVM, is called during the RVM boot
sequence.

\subsubsection{Does RVM conform to Sun's JDK Host Porting Interface?}

No. There is nothing in RVM that remotely resembles HPI.

\subsection{Libraries}

\subsubsection{Does RVM run awt?}

Not currently.  We've tried this recently; RVM does not currently provide
all the JNI support needed for awt.  We have not looked into how difficult
it would be to provide the missing JNI support.

\subsubsection{Can I run some standard library on RVM that is not included
in rvmrt.jar?}

You can try.  Set your classpath to pick up the library you desire.

\subsection{Optimizing Compiler}

\subsubsection{What is a PEI?}
PEI is our acronym for potentially excepting instruction.  This applies to
any instruction in the IR that may throw an exception.


\subsubsection{Is there a difference between a GC safe point and a thread
switch point?}

Yes.  Every thread switch point is a GC safe point, but every GC safe point 
need not be a thread switch point.

A thread switch point is an instruction where the RVM thread scheduler may
intervene and cause a different Java thread (VM\_Thread) to run on the current
pthread (VM\_Processor), even if no exception is thrown.  
Thread switch points include yield points inserted in prologues, epilogues, 
and back edges, monitorenter and exits.

A GC safe point is any instruction where the compiler must generate a GC map, 
including every thread switch point.  In particular, every 
PEI is a GC point.

\subsubsection{How do I find the def of a register in SSA form?}

Use OPT\_Register.getFirstDef().

If this returns {\tt null}, then either a) the register is dead and it's definition has been eliminated, or b) the def-use chains are not up-to-date.

The def-use chains are not normally kept up-to-date incrementally.  To
recompute the def-use chains, call OPT\_DefUse.computeDU(ir). 
Most optimization passes over SSA form call this method at 
the beginning of the compiler phase.

\subsubsection{What is Heap Array SSA form?}

See the SAS 2000 paper. \remark{ADD URL}

\subsubsection{Is ABCD included?}

The open-source distribution includes a derivative of the prototype ABCD 
implementation used for the PLDI 2000 paper.
However, ABCD is {\em not} enabled by default.  The current implementation
is incorrect, as it checks only upper bounds and not lower bounds.
There is a command-line option to turn on the current implementation.

\subsubsection{What is the OptTestHarness?}

The OptTestHarness is a driver program to run the optimizing compiler even
on a BaseBase boot image.  This driver is useful for optimizing compiler
development, since you can use the driver to selectively compile
individual methods with certain options. 
\remark{TODO add a section on this to the userguide and reference it}
