\newcommand{\rvmRoot} {\texttt{\$RVM\_ROOT}}

{\bf XXX} The GCspy support in the \jrvm{} CVS head does not work, as
of this writing (April 9, 2004) .  There appears to be a version
mismatch between the released version of GCspy (0.9) and the version
required by the code that was merged into \jrvm{}.  We plan to
rectify this before the 2.3.2 release.  \textbf{XXX}.

\subsection{The GCspy Heap Visualisation Framework}

GCspy is a visualisation framework that allows developers to observe
the behaviour of the heap and related data structures.  For details of
the GCspy model see \textit{GCspy: An adaptable heap visualisation framework}
by Tony Printezis and Richard Jones, OOPSLA'02.  (This paper is
available from the GCspy download site, listed below.)  The framework
comprises two components that communicate across a socket: a
client-side visualiser (written in Java) and a server incorporated
into the virtual machine of the system being visualised.

GCspy is designed to be independent of the target system.  Instead, it
requires the GC developer to describe their system in terms of four
GCspy abstractions, spaces, streams and tiles.   \textit{\textbf{XXX} What is
the fourth abstraction? \textbf{XXX}} This description in
transmitted to the visualiser when it connects to the server. 

A space is an abstraction of a component of the system; it may
represent a memory region, a free-list, a remembered-set or whatever.
Each space is divided into a number of blocks which are represented by
the visualiser as tiles.  Each space will have a number of attributes
--- streams --- such as the amount of space used, the number of
objects it contains, the length of a free-list and so on. 

In order to instrument a \jrvm{} collector with GCspy, it is necessary to:
\begin{enumerate}
   \item provide a \texttt{startGCSpyServer} method in \texttt{Plan.java} to initialise the GCspy server with the port on which to communicate and a list of event names, instantiate drivers for each space and then start the server;
   \item gather data from each space for the tiles of each stream (e.g.\ before and after each collection);
   \item  provide a driver for each space. 
\end{enumerate} 

Space drivers handle communication between collectors and the GCspy
infrastructure by mapping information collected by the memory manager
to the space's streams.  Typically, a driver will:

\begin{itemize}
   \item Create a number of streams.
   \item Label the tiles of its space (e.g.\ with their address range).
   \item Update the tile statistics as the memory manager passes it information.
   \item Send the tile data along with any summary or control information to the visualiser. 
\end{itemize}

The SemiSpace plan gives an example of how to instrument a collector.
It provides GCspy spaces, streams and drivers for the semi-spaces, the
immortal space and the large object space, and also illustrates how
performance may be traded for the gathering of more detailed
information.

\subsection{Installation}


\subsubsection{System Requirements}

In order to run GCspy, your \jrvm{} build must interact properly with pthreads.
See the \jrvm{} mailing lists for a discussion of this.  
\textit{\textbf{XXX}
I believe this is another way of saying that GCSpy will only work on a
system where \texttt{RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR} is 0.  I intend
to verify that fact and remove this note before the 2.3.2 release goes
out.  --Steve Augart \textbf{XXX} }

The discussion below assumes that you will place all the
GCspy code and required libraries in \rvmRoot.  If you wish to change
this, you'll need to modify these instructions and the {\tt
  \rvmRoot/rvm/config/build/gcspy/GCSpy} config file appropriately. 

\paragraph{Downloads}

\begin{enumerate}


\newcommand{\GCspyURL}{http://www.experimentalstuff.com/Technologies/GCspy/}
   \item Download the GCspy files from \xlink{\texttt{\GCspyURL}}{\GCspyURL}
      You want the C infrastructure (not the C++ one) and the Java visualiser. 
The C infrastructure provides a GCspy server to \jrvm{}.

\newcommand{\JAIURL}{http://java.sun.com/products/java-media/jai}
  \item Download the Java Advanced Imaging (JAI) API from
    \xlink{\texttt{\JAIURL}}{\JAIURL}.  You want the download named
    ``Linux CLASSPATH Install''.   You will pull down a file named
    \texttt{jai-1\_1\_2-lib-linux-i586.tar.gz} 

   \item  Unpack the GCSpy and JAI sources into \rvmRoot. You should
     then have directories named  {\tt \rvmRoot/gcspy0.9 and
       \rvmRoot/jai-1\_1\_2}.  

\end{enumerate}

\paragraph{Building GCspy itself}

   Edit the file \rvmRoot/gcspy0.9/src/java/GNUmakefile and set the
   value of \texttt{JDK} appropriately for your system.

   Copy the JAI \texttt{.jar} files into gcspy's \texttt{classes}
   directory:
\begin{verbatim}
    $ cp $RVM_ROOT/jai-1_1_2/lib/*.jar $RVM_ROOT/gcspy0.9/src/java/classes
\end{verbatim}

   Make the GCspy visualiser and server:

\begin{verbatim}
    $ cd $RVM_ROOT/gcspy0.9/src/
    $ make install c java
\end{verbatim}

\paragraph{Building \jrvm{} to use GCspy}

\begin{itemize}
  \item  Set up your environment appropriately.  In addition to the
    usual \texttt{RVM\_}\textit{*} environment variables, we assume:
   
\begin{verbatim}
    $ export GCSPY_ROOT=$RVM_ROOT/gcspy0.9
    $ export GCSPY_CLASSES=$GCSPY_ROOT/src/java/classes
\end{verbatim}

  \item First, build an image, using the
    \texttt{BaseBaseSemiSpaceGCSpy} configuration: 
\begin{verbatim}
    $ jconfigure BaseBaseSemiSpaceGCSpy
    $ cd $RVM_BUILD
    $ ./jbuild
\end{verbatim}
\end{itemize}

\paragraph{Running \jrvm{} with GCspy}

\begin{itemize}
   \item  Next, start \jrvm{}, first adding the GCSpy server library to your {\tt LD\_LIBRARY\_PATH}:
\begin{verbatim}
    $ export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$GCSPY_ROOT/src/c/lib
    $ rvm -Xms20m -X:gc:gcspyPort=3000 -X:gc:gcspyWait=true  &
\end{verbatim}

   \item Then, start the GCSpy visualiser:

\begin{verbatim}
    $ cd $GCSPY_CLASSES
    $ java gcspy.Main -server localhost 3000
\end{verbatim}

      and click the "Connect" button in the bottom right-hand corner
      of the visualiser.  (Alternatively, you can give the server and
      port arguments in the Connect dialogue box.)  

%      The visualiser itself has not been tested on \jrvm{}.
\end{itemize}

\subsection{Command line arguments}

Additional GCSpy-related arguments to the \texttt{rvm} command:

\begin{itemize}

\item {\tt -X:gc:gcspyPort=\Mmeta{port}} \\
    The number of the port on which to connect to the visualiser.  The
    default is port \texttt{0}, which signifies no connection. 

\item {\tt -X:gc:gcspyWait=\Mlbr{} \mbox{\texttt{true}} \Mor{} \mbox{\texttt{false}} \Mrbr} \\
    Whether \jrvm{} should wait for a visualiser to connect.

\item {\tt -X:gc:gcspyTilesize=\Mmeta{size}} \\
    How many KB are represented by one tile.  The default value is 128.

\end{itemize}

