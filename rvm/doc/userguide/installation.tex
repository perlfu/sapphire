 This section gives instructions on how to install and run Jikes RVM.
If your system meets certain prerequisites, the install process is
quite simple; if not, you may need to do some preparatory work.  We
present the simple case first.  We then present details for installing
on other platforms, and finally discuss further installation steps for
running Eclipse on Jikes RVM.

\subsection{Installing on RedHat Linux 7.3 and 8.x for Intel x86}

RedHat Linux for Intel IA32 has emerged as the 
primary platform for Jikes RVM. 
If you have either a developer or full install of RedHat
Linux 7.3 or later, your system has almost everything you need
to run Jikes RVM.  The following instructions describe how to install
and build Jikes RVM for this platform:
\begin{enumerate}

\item Download and install a Java Virtual Machine if you have not
already done so.  We currently recommend the Blackdown VM v1.4.1. 
For versions of Jikes RVM prior to 2.2.2, we recommend
the Blackdown VM, v1.3.1. You can download these VMs from 
from \xlink{{\tt \BlackdownURL}} {\BlackdownURL}. 
\footnote{We have seen problems using the IBM 1.3.1 and 1.4.0
DK to build the Jikes RVM bootimage. Also, please note that RedHat 8.x
does have a `java' command, but that does not invoke a JVM and will
not suffice for building Jikes RVM.}

\item Download and install {\tt ksh} if you have not already done so.
Obtain the latest rpm file for pdksh; you can get this from
\xlink{rpmfind}{http://rpmfind.net}. 

\item Download and install the Jikes (Java source to bytecode)
compiler, if you have not already 
done so (it is not included in standard RedHat installs).  You can
obtain Jikes from \xlink{the Jikes developerWorks site}{\jikesURL}.
Use the pre-built rpm file for jikes-1.18 or higher.

\item Download Jikes RVM from developerWorks and unpack it.  We shall
hereinafter call the location of the RVM distribution RVM\_ROOT/rvm.

\item Download version \classpathversion\ of the GNU Classpath
libraries from 
\xlink{{\tt \classpathftp}}{\classpathftp}. 
Unpack the tar file and rename the
directory to classpath (instead of classpath-\classpathversion). Don't
configure or install the package; the Jikes RVM build process will
handle this automatically.  Note, you can skip this step and have the
Jikes RVM build process download classpath for you automatically,
however this requires that you have a number of RPMs installed
on your machine that aren't part of the default Red Hat install.
Unless you regularly build the GNU classpath libraries from their CVS
tree, we recommend that you download a classpath release tar ball
instead. When editing the configuration file (next step), you will set
the {\tt CLASSPATH\_ROOT} variable to be the directory that contains the
classpath directory you just created.  

\item Edit a configuration file so that it fits your machine.  One of
the i686-pc-linux files in RVM\_ROOT/rvm/config will probably be
more-or-less right to begin with.  On Linux, most standard commands
(and Jikes) are in /usr/bin.  Hereinafter, we will call your edited
file RVM\_ROOT/rvm/config/i686-pc-linux-gnu.mine

\item Setup your environment with definitions required by Jikes RVM.
There are four of these that you must use; in addition,
RVM\_ROOT/rvm/bin should be in your path.
\begin{description}

\item[RVM\_ROOT] is the location of the Jikes RVM distribution.  It
must be RVM\_ROOT as given above.

\item[RVM\_HOST\_CONFIG] is the configuration file of the machine
building Jikes RVM.  It must be
RVM\_ROOT/rvm/config/i686-pc-linux-gnu.mine.

\item[RVM\_TARGET\_CONFIG] is the configuration of the machine running
Jikes RVM.  It must be RVM\_ROOT/rvm/config/i686-pc-linux-gnu.mine.

\item[RVM\_BUILD] is the location where Jikes RVM is to be built.  It
can be anywhere.
\end{description}

\item Setup a build directory with `jconfigure BaseBaseSemiSpace,' or
use some other configuration if you prefer. See Section~\ref{configs}
for information about the various configurations.

\item Build Jikes RVM: go to RVM\_BUILD and type `./jbuild'

\end{enumerate}

\newcommand{\gccURL}{ftp://ftp.gnu.org/gnu/gcc}
\newcommand{\glibcURL}{ftp://ftp.gnu.org/gnu/glibc}
\newcommand{\makeURL}{ftp://ftp.gnu.org/gnu/make}
\newcommand{\tarURL}{ftp://ftp.gnu.org/gnu/tar}
\newcommand{\autoconfURL}{ftp://ftp.gnu.org/gnu/autoconf}
\newcommand{\automakeURL}{ftp://ftp.gnu.org/gnu/automake}
\newcommand{\kshURL}{http://www.cs.mun.ca/~michael/pdksh}
\newcommand{\linuxPPCJDKURL}{http://www.ibm.com/java/jdk/linux/index.html}
\newcommand{\linuxKernelURL}{http://www.kernel.org}

\subsection{The Hard Way}

 For any platform that is not RedHat Linux 7.3 or newer for Intel
IA32, installation can be more complicated.  We present a list of system
prerequisites, and then a series of install steps that assumes you
have those.

\subsubsection{System Prerequisites}

\begin{table}[h]
\begin{center}
\begin{tabular}{|l|l|l|} \hline\hline
{\em software} & {\em version} & {\em site} \\ \hline
\multicolumn{3}{|c|}{\em All platforms}                     \\ \hline
GNU make       & 3.79+    & \xlink{\tt \makeURL}{\makeURL}         \\ 
GNU tar        & 1.13+    & \xlink{\tt \tarURL}{\tarURL}           \\ 
automake       & 1.6.3+   & \xlink{\tt \automakeURL}{\automakeURL} \\
autoconf       & 2.53+    & \xlink{\tt \autoconfURL}{\autoconfURL} \\
gcc            & 2.95+    & \xlink{\tt \gccURL}{\gccURL}           \\
unzip          & 5.50+    & \xlink{\tt \unzipURL}{\unzipURL}       \\
Jikes          & 1.18+    & \xlink{\tt \jikesURL}{\jikesURL}       \\
ksh            & {\em any}& \xlink{\tt \kshURL}{\kshURL}	   \\ \hline
\multicolumn{3}{|c|}{\em Linux/IA32}                      \\ \hline
kernel         & 2.4+ ({\em See below}) & \xlink{\tt \linuxKernelURL}{\linuxKernelURL} \\
JDK            & Blackdown 1.3.1 or 1.4.1 & \xlink{\tt \BlackdownURL}{\BlackdownURL} \\
glibc          & 2.2+ ({\em See below}) & \xlink{\tt \glibcURL}{\glibcURL} \\ \hline
\multicolumn{3}{|c|}{\em AIX/PowerPC}                     \\ \hline
AIX            & 4.3+     &                          \\
JDK            & IBM DK 1.3.0 or 1.4.0 & \xlink{\tt \AIXJdkURL}{\AIXJdkURL} \\ \hline
\multicolumn{3}{|c|}{\em Linux/PowerPC}                      \\ \hline
JDK            & IBM DK 1.3.0    & \xlink{\tt \linuxPPCJDKURL}{\linuxPPCJDKURL} \\
\hline\hline 
\end{tabular}
\begin{itemize}
\item {\tt automake} and {\tt autoconf} are only required to build the
GNU classpath libaries from classpath CVS. If you instead download a
tagged pre-built GNU Classpath release as recommended, then you don't need
these.
\item {\tt glibc} for Linux/IA32 must use the GS register for
thread-local state.  See the build instructions for glibc for details;
if that scares you, use a recent RedHat Linux distribution.
\item It is possible to use 2.2 Linux kernels with multiprocessor
support disabled in Jikes RVM.  We do not recommend this; if you
insist, look in {\tt jconfigure} for details.
\end{itemize}
\end{center}
\caption{System prerequisites for Jikes RVM}
\label{prereqs}
\end{table}

\AIXPPCJikesTMFooter

\JavaTMFooter

\subsubsection{Installation Overview}

To install and build the Jikes\trademark RVM, two items are required
\begin{itemize}
\item The Jikes RVM source distribution.  This is available as a
compressed tar file {\tt \RVMTarFile}.  You can also work with the
contents of this repository with CVS from the 
\xlink{public repository}{\RVMCVSURL}.

\item The 
\xlink{Classpath}{\classpathURL} libraries. 
\end{itemize}

Each item is distributed under a different license.  The license for
the first item is provided in Appendix~\ref{appendix:licenses}.  The
GNU Classpath license is available at \xlink{{\tt
\classpathURL}}{\classpathURL}. 

The first item is available  from the Jikes RVM
\xlink{download}{\RVMDownloadURL} page. The second item is available at
\xlink{{\tt \classpathURL}}{\classpathURL}.
You can either explicitly download the appropriate version of the GNU
Classpath libraries and set {\tt CLASSPATH\_ROOT} in your config file or let
the Jikes RVM build process download the right version for you
automatically. If you do not regularly build the classpath libraries
from their CVS tree, then you probably should download the appropriate
classpath release manually and set {\tt CLASSPATH\_ROOT}. 

Once these files have been downloaded, you will set up 
a working directory holding the Jikes RVM source files, standard
library jar, and tools needed to build Jikes RVM. 

Jikes RVM can be configured in various ways. Multiple versions of the system,
corresponding to different configurations, can be generated from 
one working directory. See Section~\ref{configs} for information about the 
various 
configurations.
\index{configurations}
The Jikes RVM  {\em boot image} and other files generated during the 
configuration process
\index{boot image}
are stored in a {\em build directory}, which is logically separate from 
the working directory. 
\index{build directory}

To install Jikes RVM  you must do the following:
\begin{enumerate}
\item Set up a working directory.
\item Set various environment variables.
\item Edit Jikes RVM environment scripts.
\item Choose a configuration and run the configuration script to write
the appropriate directory and configuration specific files to the
build directory.
\item Build an executable version of Jikes RVM.
\end{enumerate}

The remainder of this section describes the process in greater detail.

\JikesTMFooter

\subsubsection{Installation Steps}

\begin{enumerate}
\item {\bf Set up a working directory.}

First extract the Jikes\trademark RVM source distribution into a
directory such as  
{\tt \$HOME/rvmRoot}.
\begin{verbatim}
% cd $HOME
% mkdir rvmRoot
% cd rvmRoot
% zcat jikesrvm-[version].tar.gz | tar xvf - 
\end{verbatim}

\index{environment variables}
\index{RVM\_ROOT}
\index{RVM\_BUILD}
\index{PATH}
\item {\bf Set up environment variables.}

You need to set up the following shell environment variables:

\begin{description}
\item [{\tt RVM\_ROOT}] the directory that contains the extracted
distribution 
\item [{\tt RVM\_BUILD}] the directory where you would like the build
process to generate an executable Jikes RVM configuration

\item [{\tt RVM\_HOST\_CONFIG}] the configuration file used to specify
the software environment on which the system is generated; i.e., where the
boot image is generated.

\item [{\tt RVM\_TARGET\_CONFIG}] the configuration file used to specify
the software environment where the system support is generated; i.e., where
the ``booter'' and ``C runtime'' will be generated.

\item[{\tt PATH}] your path should contain {\tt \$RVM\_ROOT/rvm/bin} in
order to pick up various scripts and utilities
\end{description}

We recommend you set up these variables in your shell configuration
file.  For example, for {\tt csh}, you might insert the
following into your {\tt .cshrc} file:

\begin{verbatim}
setenv RVM_ROOT $HOME/rvmRoot       # <--define your working directory 
setenv RVM_BUILD $HOME/rvmBuild     # <--define your current build directory 
setenv PATH $RVM_ROOT/rvm/bin:$PATH
setenv RVM_HOST_CONFIG $RVM_ROOT/rvm/config/powerpc-ibm-aix4.3.3.0
setenv RVM_TARGET_CONFIG $RVM_ROOT/rvm/config/powerpc-ibm-aix4.3.3.0
\end{verbatim}

{\em Note:} You should define each of these environment variables as an
{\em absolute} path.  The builder template expansion process will crash
and burn if you use a {\tt ..} in these paths.

For a Linux-Intel environment, the exports
would be replaced with the following:

\begin{verbatim}
setenv RVM_HOST_CONFIG $RVM_ROOT/rvm/config/i686-pc-linux-gnu
setenv RVM_TARGET_CONFIG $RVM_ROOT/rvm/config/i686-pc-linux-gnu
\end{verbatim}

These two variables point to the same file when the type of system  
doing the build is the same as where  you are going 
the execute the Jikes RVM. To cross build a system
e.g., build on AIX\AIXTMFootnote/PowerPC\PowerPCTMFootnote\ for a
Linux/IA32 platform, see the section on Cross 
Platform Building.

\item {\bf Edit configuration scripts.}

You must edit a script in the {\tt \$RVM\_ROOT/rvm/config}  directory to set 
up variables used by the installation process.  
If someone else at your site has already installed Jikes RVM, they have
probably already done this step for you.  Consult your local Jikes RVM guru.

You must edit the file(s) that define the host and target configuration
environments in the {\tt \$RVM\_ROOT/rvm/config} directory.  
You do not need to {\em source} these variables in your working shell; 
variables in this file will be picked up by the installation scripts.  

The host and target configuration files have two sections.  In the
first section, you specify the operating system, architecture, and
whether or not the platform will support SMP-builds of Jikes RVM. 
For operating system, define one of RVM\_FOR\_LINUX or RVM\_FOR\_AIX
to be 1.  For architecture define either
RVM\_FOR\_IA32 or RVM\_FOR\_POWERPC to be 1.  For SMP status, set
RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR to 0 (SMP supported) or 1 (SMP not
supported).  The following are the typical settings for
RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR 
\begin{description}
\item {\tt AIX/PowerPC} 0 
\item {\tt Linux/PowerPC} 1 
\item {\tt Linux/IA32} 0\footnote{You must use 1 here if you do not
have 2.4 kernel and glibc compiled to use the GS segment register to
access pthread-specific state.  We do not recommend such a setup.}
\end{description}                
The second section in the configuration file is used to define how to
find tools that Jikes RVM needs. You must set the following variables:
\begin{description}
\item {\tt HOST\_JAVA\_HOME} the base directory for JDK JVM. If you
have a nonstandard JDK, you may have to define a number of variables
that are normally defined in terms of {\tt HOST\_JAVA\_HOME}.
\item {\tt CLASSPATH\_ROOT} the parent directory of the classpath src
release, if you have decided to manually download the classpath
libraries. 
\item {\tt GNU\_MAKE} the GNU {\tt make} executable
\item {\tt JIKES} the Jikes\trademark compiler executable ({\tt jikes}).
\item {\tt CC} how to invoke the C compiler.
\item {\tt CPLUS} how to invoke the C++ compiler.
\item {\tt LDSHARED} how to link a shared C++ library.
\item {\em various basic Unix utilities} e.g., {\tt grep}, {\tt xargs}, etc.
\end{description}

Someday we should consider setting up an autoconf to automate this
step.  Contributions are welcome!

\index{configurations}
\index{jconfigure script}
\item {\bf Choose configuration and populate your build directory.}
You will use the {\tt jconfigure} script (in {\tt \$RVM\_ROOT/rvm/bin}) to
populate your build ({\tt \$RVM\_BUILD}) directory with files.  You must
first choose a Jikes RVM configuration.

For quick turnaround time while modifying Jikes RVM, you will usually
want to use the baseline compiler to build the Jikes RVM bootimage.
A typical configuration that builds very quickly (but performs poorly)
is {\tt BaseBaseSemiSpace}: a non-adaptive system that uses the
baseline compiler everywhere, with the semispace copying collector. 

To obtain reasonable performance from Jikes RVM, you will need to use
the optimizing compiler to build the bootimage.  This takes longer,
but generates a Jikes RVM image with reasonable runtime performance.
We recommend either the {\tt FullAdaptiveSemiSpace} or {\tt
FastAdaptiveSemiSpace} images depending on whether or not you want
VM assertion checking enabled. (A discussion 
of Jikes RVM configurations appears in Section~\ref{configs}.)

Depending on your purposes you may want to choose another
configuration that uses a different memory manager (See
Section~\ref{ssec:choosinggc}.).

Run the {\tt jconfigure} script to set up the {\tt \$RVM\_BUILD}
directory for the configuration you desire.  This step creates
build scripts for your configuration and otherwise formats your
{\tt \$RVM\_BUILD} directory.
The {\tt jconfigure} script takes one argument, the name of the
configuration desired: 

\begin{verbatim}
% jconfigure <configuration>
\end{verbatim}

For example, to configure a build 
directory for the {\tt OptOptSemiSpace} configuration, type
the following command:

\begin{verbatim}
% jconfigure OptOptSemiSpace
\end{verbatim}

\index{jbuild script}
\index{boot image}
\index{RVM\_BUILD}
\item {\bf Build an executable version of Jikes RVM.}  

Use the {\tt jbuild} script, located in the {\tt \$RVM\_BUILD} directory,
to build an executable system.  This script copies source files into
{\tt \$RVM\_BUILD/RVM.classes}, preprocesses these files, generates
some code with template expansions, builds an executable C program to
start the Jikes RVM, and writes the Jikes RVM boot image.  The boot
image is the binary image of a ready-to-go instance of the Jikes RVM.

The {\tt jbuild} script must be run from the {\tt \$RVM\_BUILD}
directory. It prints a copious report of its operation which you may
save for future reference by redirecting standard out and err.

\begin{verbatim}
% cd $RVM_BUILD
% jbuild
\end{verbatim}


After the {\tt jbuild} script has completed successfully you should be able 
to run Jikes RVM.  (See Section~\ref{section:running}.)

Note: The jbuild process may produce warning messages; these should not
affect system viability.

\end{enumerate}

\AIXPPCJikesTMFooter

\subsection{Jikes RVM Configurations}\label{configs}
\index{configuration names}

This section describes the Jikes\trademark RVM build configurations.
The various 
build configurations are defined by files in {\tt
\$RVM\_ROOT/rvm/config/build}.

Most standard Jikes RVM configuration files loosely follow the
following naming scheme 
\begin{verbatim}
       <boot image compiler> <runtime compiler> <garbage collector>
\end{verbatim}

\index{boot image compiler}
\index{runtime compiler}
where
\begin{itemize}
\item the {\em boot image compiler} is the compiler used to compile
the Jikes RVM boot image. 
\item the {\em runtime compiler} is the ``compiler'' used to compile
the classes loaded at runtime.  
\item the {\em garbage collector} is the garbage collection scheme used.
\end{itemize}

The types of compilers --- the baseline compiler and 
the optimizing compiler --- are designated by the names {\em Base}
and {\em Opt} respectively.  In these configurations,
methods of classes loaded at runtime are compiled once by the specified
compiler when they are first called.
This differs from the adaptive configurations,
discussed in Section~\ref{adaptive-configs}.

The following garbage collection suffixes are available:

\begin{description}
\item[NoGC] no garbage collection is performed
\item[SemiSpace] a copying semi-space collector
\item[MarkSweep] a mark-and-sweep (non copying) collector
\item[GenCopy] a classic copying generational collector with a copying
  higher generation
\item[GenMS] a copying generational collector with a non-copying
  mark-and-sweep mature space
\item[CopyMS] a hybrid non-generational collector with a copying space
  (into which all allocation goes), and a non-copying space into which
  survivors go
\item[WatsonSemispace] the original ``watson'' copying semi-space collector 
\item[WatsonMarkSweep] the original ``watson'' mark-and-sweep collector
\end{description}

For example, to specify a compiler with a baseline-compiled boot image
that will compile classes loaded at runtime using the optimizing compiler and that uses
a non-generational semi-space copying garbage collector, use the name 
{\em BaseOptSemiSpace}.

Some files augment the standard configurations as follows:
\begin{itemize}
\item The word 
{\em Full} at the beginning of the configuration name identifies a 
configuration
such that all the Jikes RVM classes are included in the boot image 
and are compiled by the optimizing compiler. 
(By default only
a small subset of these classes are included in the boot image.)
\item The word
{\em Fast} at the beginning of the configuration name identifies a Full
configuration where all assertion checking has been turned off. 
\end{itemize}
A boot image with
either of these modifications will likely to run faster than without
(the opt compiler will be opt compiled), but take longer to build.  

\subsubsection{Adaptive Configurations} \label{adaptive-configs}
\index{adaptive configurations}
In the non-adaptive configurations, the system compiles each
method once, by the specified
compiler (baseline or optimizing) when the method is first called.  
Another option is to build one configuration, 
an {\em adaptive} configuration,
where the runtime compiler is either
\begin{itemize}
\item specified on the command line (base or opt), or
\item selected automatically as the application runs.
\end{itemize}

The first choice allows an adaptive configuration to provide the same
functionality as a non-adaptive configuration.  A single adaptive
image can support either runtime compiler when directed on the
command-line as follows:
\begin{verbatim}
  rvm -X:aos:primary_strategy=baseonly
            or
  rvm -X:aos:primary_strategy=optonly
\end{verbatim}

The second choice initially compiles all methods with the
baseline compiler and then automatically selects hot methods for
recompilation by the opt compiler at an appropriate optimization
level. Further details are provided in Section~\ref{section:aosdetails}.

The adaptive configurations follow the following naming scheme
\begin{verbatim}
           [boot image compiler] Adaptive  <garbage collector>
\end{verbatim}

For example, to configure a build 
directory for an adaptive configuration, where the optimizing compiler is 
used to compile the boot image (but is not included in the boot image
and assertions are turned on), and the semi-space garbage collector is
used, use the following command:

\begin{verbatim}
% jconfigure OptAdaptiveSemiSpace
\end{verbatim}

Section~\ref{section:running} describes how this image can be used in
the manner mentioned above.

To view a list of configurations see 
{\tt \$RVM\_ROOT/rvm/config/build}.  Follow the examples in this
directory to define your own configurations with different options.  See
the {\tt jconfigure} file for a list of all options the builder
understands.

\JikesTMFooter

\subsection{Cross Platform Building}

The Jikes\trademark RVM build process consists of two major phases:
the building of a 
{\em boot image}, and the building of a {\em boot loader}.
The boot image is built using a Java\trademark program executed within a host
JVM and is therefore platform-neutral.  By contrast, the boot loader
is written in C, and must be compiled on the target platform.

Because building the boot image can be time-consuming,
you may prefer to build the boot image
on a faster machine than the target platform.  To cross build, simply
set your 
RVM\_HOST\_CONFIG and RVM\_TARGET\_CONFIG environment variables to
be different files.

For example, to build a BaseBaseSemiSpace system for AIX\AIXTMFootnote\
{\em on a Linux host}:
\begin{verbatim}
% setenv RVM_ROOT $HOME/rvmRoot
% setenv RVM_BUILD $HOME/rvmBuild
% setenv PATH $RVM_ROOT/rvm/bin:$PATH
% setenv RVM_TARGET_CONFIG=$RVM_ROOT/rvm/config/powerpc-ibm-aix4.3.3.0
% setenv RVM_HOST_CONFIG=$RVM_ROOT/rvm/config/i686-pc-linux-gnu
% jconfigure BaseBaseSemiSpace
% cd $RVM_BUILD
% jbuild
\end{verbatim}

This phase of the build process will complete with the words ``{\tt
  please run me on AIX}''.


The build process is then completed by building just the boot loader {\em
  on an AIX host}:

\begin{verbatim}
% setenv RVM_ROOT $HOME/rvmRoot
% setenv RVM_BUILD $HOME/rvmBuild
% setenv PATH $RVM_ROOT/rvm/bin:$PATH
% jbuild -booter
\end{verbatim}

After the {\tt jbuild -booter} script has completed successfully you should be able 
to run Jikes RVM. 

The building of the boot loader must occur in the same directory as
the rest of the build.  This can either be done transparently via a
network file system, or by copying the build directory from the first
host to the target.  Of course {\tt RVM\_ROOT}, {\tt RVM\_BUILD }
and {\tt PATH} need not be explicitly set each time: they could have
been set in your {\tt .cshrc}.

More advanced users can experiment with the {\tt RVM\_BUILD\_COPY}
environment variable.  If this is set, then the {\tt
  jbuild.linkBooter} phase of the build process is replaced by the
execution of {\tt `\$RVM\_BUILD\_COPY`}.  This opens up a lot of
possibilities, including: copying the build directory to a target
machine and executing {\tt jbuild.linkBooter} remotely on the target
via {\tt rsh} or {\tt ssh}, etc.  By setting {\tt RVM\_BUILD\_COPY}
appropriately on the host platform, cross-platform building can become
a stream-lined process.

\JikesAIXTMFooter

\JavaTMFooter

\subsection{Building Documentation}

The {\tt \RVMTarFile} file contains a postscript version of this userguide
in {\tt \$RVM\_ROOT/rvm/doc}.  Additionally, the 
\xlink{developerWorks web page}{\RVMHomeURL} keeps an online version of
the userguide and javadoc API, corresponding to the latest HEAD of the CVS
repository.

If you would like to recover the userguide or javadoc for an older release
of RVM, you can rebuild the documentation locally.  See the Makefile in
{\tt \$RVM\_ROOT/rvm/doc/userguide} for rules on how to build the
HTML userguide using
\xlink{{\tt hyperlatex}}{\HyperlatexURL}.  To build the javadoc pages, use
the {\tt jdoc.sh} script in {\tt \$RVM\_ROOT/rvm/bin}; this script takes as
its one command-line argument the directory to output the javadoc HTML.

