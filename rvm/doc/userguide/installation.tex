So you've gotten the RVM distribution.  Now what?  This section gives
instructions on how to install and run RVM for the new RVM user.

\subsection{System Prerequisites}
To build on any platform you will need the following:
\begin{itemize}
\item GNU make. You can download this from
\xlink{{\tt \gnuMakeURL}} {\gnuMakeURL}.

\item The Jikes\trademark Java\trademark compiler 
You can download this from
\xlink{{\tt \jikesURL}} {\jikesURL}.
You can use any of the pre-compiled binaries, or build it yourself from the
source. We recommend version 1.13; users have reported difficulties with 
version 1.14.  We have not yet tried version 1.15.

\item GNU tar is needed to extract the distribution tar file.  
You can download this from
\xlink{{\tt \gnuTarURL}} {\gnuTarURL}.
We have experienced problems with the AIX\AIXTMFootnote tar program
truncating file names. 

\end{itemize}

%% footnotes not allowed in section headings, so we specialize
\htmlonly{\subsubsection{AIX\trademark/PowerPC\trademark}}
\texonly {\subsubsection{AIX\trademark/PowerPC\trademark}}

In addition to the software mentioned above, to install, build, and
run RVM on a AIX/PowerPC environment, 
you will need 
\begin{itemize}
\item a PowerPC processor
\item AIX 4.3 or later, and
\item (recommended) 512MB of memory.
\item the IBM AIX Developer Kit for Java version 1.3.0.  You can
download this from \xlink{{\tt \AIXJdkURL}} {\AIXJdkURL}. 
\end{itemize}

\subsubsection{Linux/IA32}
In addition to the software mentioned above, to install, build, and
run RVM on a Linux Intel environment, you will need 
\begin{itemize}
\item an Intel Architecture 32 bit processor
\item Linux  (we have run on RedHat 6.0 and 7.0)
\item The system has run in 386MB; we have not established a lower bound.
\item the IBM Developer Kit (at least version 2.1.3).  You can
download this from 
\xlink{{\tt \LinuxJdkURL}} {\LinuxJdkURL}.  We did have problems on
bleeding edge 2.4 kernels running on SMP machines with versions of the IBM
Developer Kit built prior to May 2001.  We are currently using IBM
build cx130-20010502; later builds should work as well.
\item {\tt ksh}. This must be installed in {\tt /bin/ksh}.
\end{itemize}

\subsubsection{Win32 and Cygwin/IA32}
Currently this option for running RVM is barely if at all functional.
It is not currently being maintained or tested. You are encouraged to 
skip this section and don't even think about running RVM on Win32 with 
cygwin.

If you're still reading, you are probably an enterprising hacker that is
interested in getting this configuration up an running.  More power to
you! We'd like to hear your progress.

In addition to the software mentioned above, to install, build, and
run RVM on a Win32/Cygwin Intel environment, you will need 
\begin{itemize}
\item an Intel Architecture 32 bit processor
\item a Win32 operating system (we have only tried it on Windows 2000).
\item Cygwin. You can download this from 
\xlink{{\tt \CygwinURL}} {\CygwinURL}. (I used dll version 1.1.8).
\item The system has run in 256MB on Windows 2000; we have not established
a lower bound.
\item the IBM Developer Kit (at least version 2.1.3).  You can download this from
\xlink{{\tt \WinJdkURL}} {\WinJdkURL}.
\item {\tt ksh}.  One alternative is {\tt pdksh} from 
\xlink{{\tt \pdkshURL}} {\pdkshURL}.
\end{itemize}

Some issues with this platform include:

\begin{itemize}
\item We haven't managed to successfully install a handler for hardware traps,
so the first hardware exception (e.g., a {\tt NullPointerException}) will cause
an ugly core dump.
\item Spaces in directory names aren't handled by jconfigure and the
other scripts.  Use cygwin's mount command to avoid them (in
particular the config file assumes that
C:$\backslash$Program~Files$\backslash$IBM is mounted as /IBM).
\end{itemize}

\JikesTMFooter

\JavaTMFooter

\AIXTMFooter

\PowerPCTMFooter

\subsection{Installation Overview}

In order to install and build RVM, you will need to acquire the following
items from the 
\xlink{RVM Download Page}{\RVMDownloadURL}.
\begin{itemize}
\item the RVM source distribution.  This is available as a compressed tar
file {\tt \RVMTarFile}.  You can also work with the contents of this repository with CVS from the
\xlink{public repository}{\RVMCVSURL}.
\item the RVM standard libraries.  This is a file {\tt \LibTarFile}
available from the download page. 
\end{itemize}

After downloading these files, you will set up 
a working directory holding the RVM source files, standard library jar, and 
tools needed to build RVM. 

RVM can be configured in various ways. Multiple versions of RVM,
corresponding to different configurations, can be generated from 
one working directory. See Section~\ref{configs} for information about the 
various 
configurations.
\index{configurations}
The RVM  {\em boot image} and other files generated during the 
configuration process
\index{boot image}
are stored in a {\em build directory} which is logically separate from 
the working directory. 
\index{build directory}

In order to install RVM  you must:
\begin{enumerate}
\item Set up a working directory.
\item Set various environment variables.
\item Edit RVM environment scripts.
\item Choose a configuration and run the configuration script to write
the appropriate directory and configuration specific files to the
build directory.
\item Build an executable version of RVM.
\end{enumerate}

The remainder of this section describes the process in greater detail.

\subsection{Installation Steps}

\begin{enumerate}
\item {\bf Set up a working directory.}

First extract the RVM source distribution into a directory such as 
{\tt \$HOME/rvmRoot}.
\begin{verbatim}
% cd $HOME
% mkdir rvmRoot
% cd rvmRoot
% zcat jikesrvm-[version].tar.gz | tar xvf - 
\end{verbatim}

Next extract the RVM standard libraries.  The following installs the
standard library file {\tt rvmrt.jar} in {\tt \$RVM\_ROOT/support/lib}.
\begin{verbatim}
% cd $HOME/rvmRoot
% zcat jlibraries-[version].tar.gz | tar xvf - 
\end{verbatim}

\index{environment variables}
\index{RVM\_ROOT}
\index{RVM\_BUILD}
\index{PATH}
\item {\bf Set up environment variables.}

You need to set up the following shell environment variables:

\begin{description}
\item [{\tt RVM\_ROOT}] the directory that contains the extracted
distribution 
\item [{\tt RVM\_BUILD}] the directory where you would like the build
process to generate an executable RVM configuration

\item [{\tt RVM\_HOST\_CONFIG}] the configuration file used to specify
the software environment on which the system is generated; i.e., where the
boot image is generated.

\item [{\tt RVM\_TARGET\_CONFIG}] the configuration file used to specify
the software environment where the system support is generated; i.e., where
the ``booter'' and ``C runtime'' will be generated.

\item[{\tt PATH}] your path should contain {\tt \$RVM\_ROOT/rvm/bin} in
order to pick up various scripts and utilities
\end{description}

We recommend you set up these variables in your shell configuration
file.  For example, for {\tt csh}, you might insert the
following into your {\tt .cshrc} file:

\begin{verbatim}
setenv RVM_ROOT $HOME/rvmRoot       # <--define your working directory 
setenv RVM_BUILD $HOME/rvmBuild     # <--define your current build directory 
setenv PATH $RVM_ROOT/rvm/bin:$PATH
setenv RVM_HOST_CONFIG $RVM_ROOT/rvm/config/powerpc-ibm-aix4.3.3.0
setenv RVM_TARGET_CONFIG $RVM_ROOT/rvm/config/powerpc-ibm-aix4.3.3.0
\end{verbatim}

{\em Note:} You should define each of these environment variables as an
{\em absolute} path.  The builder template expansion process will crash
and burn if you use a {\tt ..} in these paths.

For a Linux-Intel environment, the exports
would be replaced with the following:

\begin{verbatim}
setenv RVM_HOST_CONFIG $RVM_ROOT/rvm/config/i686-pc-linux-gnu
setenv RVM_TARGET_CONFIG $RVM_ROOT/rvm/config/i686-pc-linux-gnu
\end{verbatim}

For a Cygwin-Intel environment, the  exports
would be replaced with the following:

\begin{verbatim}
setenv RVM_HOST_CONFIG $RVM_ROOT/rvm/config/i686-pc-cygwin
setenv RVM_TARGET_CONFIG $RVM_ROOT/rvm/config/i686-pc-cygwin
\end{verbatim}

These two variables point to the same file when the type of system  
doing the build is the same as where  you are going 
the execute the RVM. To cross build a system
e.g., build on AIX\AIXTMFootnote/PowerPC\PowerPCTMFootnote for a
Linux/IA32 platform, see the section on Cross 
Platform Building.

\item {\bf Edit configuration scripts.}

You must edit a script in the {\tt \$RVM\_ROOT/rvm/config}  directory to set 
up variables used by the installation process.  
If someone else at your site has already installed RVM, they have
probably already done this step for you.  Consult your local RVM guru.

You must edit the file(s) that define the host and target configuration
environments in the {\tt \$RVM\_ROOT/rvm/config} directory.  
You do not need to {\em source} these variables in your working shell; 
variables in this file will be picked up by the installation scripts.  

The host and target configuration files have two sections.  In the
first section, you specify the operating system, architecture, and
whether or not the platform will support SMP-builds of JikesRVM. 
For operating system, define one of RVM\_FOR\_LINUX, RVM\_FOR\_AIX, or
RVM\_FOR\_CYGWIN to be 1.  For architecture define either
RVM\_FOR\_IA32 or RVM\_FOR\_POWERPC to be 1.  For SMP status, set
RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR to 0 (SMP supported) or 1 (SMP not
supported).  The following are the typical settings for
RVM\_FOR\_SINGLE\_VIRTUAL\_PROCESSOR 
\begin{description}
\item {\tt AIX/PowerPC} 0 
\item {\tt Linux/PowerPC} 1 
\item {\tt Linux/IA32} 1 with a 2.2 kernel; 
0 with a 2.4 kernel and glibc compiled to use the GS
segment register to access pthread-specific state.
\end{description}                
The second section in the configuration file is used to define how to
find tools that RVM needs. You must set the following variables:
\begin{description}
\item {\tt HOST\_JAVA\_HOME} the base directory for JDK JVM
\item {\tt HOST\_JAVA} the executable command for the JDK JVM
\item {\tt HOST\_JAVAC} the {\tt javac} executable for the JDK  
\item {\tt HOST\_JAR} the {\tt jar} executable for the JDK  
\item {\tt HOST\_REPOSITORIES} the {\tt rt.jar} archive for the JDK  
\item {\tt HOST\_TOOLS} the {\tt tools.jar} archive for the JDK  
\item {\tt GNU\_MAKE} the GNU {\tt make} executable
\item {\tt JIKES} the Jikes\trademark compiler executable ({\tt jikes}).
\item {\tt CC} how to invoke the C compiler.
\item {\tt CPLUS} how to invoke the C++ compiler.
\item {\tt LDSHARED} how to link a shared C++ library.
\item {\em various basic Unix utilities} e.g., {\tt grep}, {\tt xargs}, etc.
\end{description}
The remaining variables in the config file are not required for basic RVM
builds.

Someday we should consider setting up an autoconf to automate this
step.

\index{configurations}
\index{jconfigure script}
\item {\bf Choose configuration and populate your build directory.}

You will use the {\tt jconfigure} script (in {\tt \$RVM\_ROOT/rvm/bin}) to
populate your build ({\tt \$RVM\_BUILD}) directory with files.  You must
first choose a RVM configuration.

For novice users, two configurations are recommended.  (A discussion
of RVM configurations appears in Section~\ref{configs}.)

\begin{itemize}
\item {\tt BaseBaseSemispace}: a non-adaptive system that uses the
baseline compiler everywhere, with the semispace copying collector
\item {\tt OptOptSemispace}: a non-adaptive system that uses the
optimizing compiler everywhere, with the semispace copying collector
\end{itemize}

Depending on your purposes (See Section~\ref{ssec:choosinggc}.) you
may want to choose another configuration, e.g.,
\begin{itemize}
\item {\tt OptOptMarkSweep}: a non-adaptive system that uses the
optimizing  compiler everywhere, with the mark-sweep (noncopying) collector
\end{itemize}

Run the {\tt jconfigure} script to set up the {\tt \$RVM\_BUILD}
directory for the configuration you desire.  This step creates
build scripts for your configuration and otherwise formats your
{\tt \$RVM\_BUILD} directory.
The {\tt jconfigure} script takes one argument, the name of the
configuration desired: 

\begin{verbatim}
% jconfigure <configuration>
\end{verbatim}

For example, to configure a build 
directory for the {\tt OptOptSemispace} configuration, type
the following command:

\begin{verbatim}
% jconfigure OptOptSemispace
\end{verbatim}

\index{jbuild script}
\index{boot image}
\index{RVM\_BUILD}
\item {\bf Build an executable version of RVM.}  

Use the {\tt jbuild} script, located in the {\tt \$RVM\_BUILD} directory,
to build an executable system.  This script copies source files into
{\tt \$RVM\_BUILD/RVM.classes}, preprocesses these files, generates
some code with template expansions, builds an executable C program to
start the RVM, and writes the RVM boot image.  The boot image is the
binary image of a ready-to-go instance of the RVM.

The {\tt jbuild} script must be run from the {\tt \$RVM\_BUILD}
directory. It prints a copious report of its operation which you may
save for future reference by redirecting standard out and err.

\begin{verbatim}
% cd $RVM_BUILD
% jbuild
\end{verbatim}


After the {\tt jbuild} script has completed successfully you should be able 
to run RVM.  (See Section~\ref{section:running}.)

Note: The jbuild process may produce warning messages; these should not
affect system viability.

\end{enumerate}

\JikesTMFooter

\AIXTMFooter

\PowerPCTMFooter

\subsection{RVM Configurations}\label{configs}
\index{configuration names}

This section describes the RVM build configurations.  The various RVM
build configurations are defined by files in {\tt
\$RVM\_ROOT/rvm/config/build}.

Most standard RVM configuration files loosely follow the following naming scheme
\begin{verbatim}
       <boot image compiler> <runtime compiler> <garbage collector>
\end{verbatim}

\index{boot image compiler}
\index{runtime compiler}
where
\begin{itemize}
\item the {\em boot image compiler} is the compiler used to compile the RVM boot image.
\item the {\em runtime compiler} is the ``compiler'' used to compile
the classes loaded at runtime.  
\item the {\em garbage collector} is the garbage collection scheme used.
\end{itemize}

The types of compilers -- the baseline compiler and 
the optimizing compiler -- are designated by the names {\em Base}
and {\em Opt} respectively.  In these configurations,
all classes loaded at runtime are compiled once, by the specified
compiler.  This is different than the adaptive configurations,
discussed in Section~\ref{adaptive-configs}.

A garbage collector may have any of the following types:

\begin{description}
\item[NoGC] no garbage collection is performed
\item[Semispace] a copying semi-space collector
\item[MarkSweep] a mark-and-sweep (non copying) collector
\item[CopyGenVariable] a copying generational collector with a
variable-size nursery
\item[CopyGenFixed] a copying generational collector with a
fixed-size nursery
\item[HybridGC] a hybrid collector, semi-space for the nursery and
mark-and-sweep for the mature space
\item[Concurrent] a concurrent reference counting collector
\end{description}

For example, to specify a compiler with a baseline-compiled boot image
that will 
compile classes loaded at runtime using the optimizing compiler and that uses
a non-generational semi-space copying garbage collector use the name 
{\em BaseOptSemispace}.

Some files augment the standard configurations as follows:
\begin{itemize}
\item The word 
{\em Full} at the beginning of the configuration name identifies a 
configuration
such that all the RVM classes are included in the boot image (by default
a small subset of the RVM classes are included in the boot image). 
\item The word
{\em Fast} at the beginning of the configuration name identifies a Full
configuration where all assertion checking has been turned off. 
\end{itemize}
A boot image with
either of these modifications is likely to run faster than without
(the opt compiler will be opt compiled),
but take longer to build.  

\subsubsection{Adaptive Configurations} \label{adaptive-configs}
\index{adaptive configurations}
In the non-adaptive configurations, all classes
loaded at runtime are compiled once by the specified
compiler: base or opt.  Another option is to build one configuration,
an adaptive configuration,
where the runtime compiler is either
\begin{itemize}
\item specified on the command line (base or opt), or
\item selected automatically as the application runs
\end{itemize}

The first choice allows an adaptive configuration to provide the same
functionality as a non-adaptive configuration.  One image is built,
and the runtime compiler can be specified at the command line as
follows:
\begin{verbatim}
  rvm -X:aos:primary_strategy=baseonly
            or
  rvm -X:aos:primary_strategy=optonly
\end{verbatim}

The second choice initially compiles all methods with the
baseline compiler and then automatically selects hot methods for
recompilation by the opt compiler at an appropriate optimization
level. Further details are provided in Section~\ref{section:aosdetails}.

The adaptive configurations follow the following naming scheme
\begin{verbatim}
           [boot image compiler] Adaptive  <garbage collector>
\end{verbatim}

For example, to configure a build 
directory for an adaptive configuration, where the Opt compiler is 
used to compile the boot image (but is not included in the boot image
and assertions are turned on), and the semi-space garbage collector is
used, use the following command:

\begin{verbatim}
% jconfigure OptAdaptiveSemispace
\end{verbatim}

Section~\ref{section:running} describes how this image can be used in
the manner mentioned above.

To view a list of configurations see 
{\tt \$RVM\_ROOT/rvm/config/build}.  Follow the examples in this
directory to define your own configurations with different options.  See
the {\tt jconfigure} file for a list of all options the builder
understands.

\subsection{Cross Platform Building}

The RVM build process consists of two major phases: the building of a
RVM {\em boot image}, and the building of a RVM {\em boot loader}.
The boot image is built using a Java\trademark executed within a host
JVM and is therefore platform-neutral.  By contrast, the boot loader
is written in C, and must be compiled on the target platform.

Because the building of the boot image can be a relatively lengthy
process, it can be advantageous to perform that task somewhere other
than the target platform.  To cross build, simply set your
RVM\_HOST\_CONFIG and RVM\_TARGET\_CONFIG environment variables to
be different files.

For example, to build a BaseBaseSemispace system for AIX\AIXTMFootnote
{\em on a Linux host}:
\begin{verbatim}
% setenv RVM_ROOT $HOME/rvmRoot
% setenv RVM_BUILD $HOME/rvmBuild
% setenv PATH $RVM_ROOT/rvm/bin:$PATH
% setenv RVM_TARGET_CONFIG=$RVM_ROOT/rvm/config/powerpc-ibm-aix4.3.3.0
% setenv RVM_HOST_CONFIG=$RVM_ROOT/rvm/config/i686-pc-linux-gnu
% jconfigure BaseBaseSemispace
% cd $RVM_BUILD
% jbuild
\end{verbatim}

This phase of the build process will complete with the words ``{\tt
  please run me on AIX}''.


The build process is then completed by building just the boot loader {\em
  on an AIX host}:

\begin{verbatim}
% setenv RVM_ROOT $HOME/rvmRoot
% setenv RVM_BUILD $HOME/rvmBuild
% setenv PATH $RVM_ROOT/rvm/bin:$PATH
% jbuild -booter
\end{verbatim}

After the {\tt jbuild -booter} script has completed successfully you should be able 
to run RVM. 

The building of the boot loader must occur in the same directory as
the rest of the build.  This can either be done transparently via a
network file system, or by copying the build directory from the first
host to the target.  Of course {\tt RVM\_ROOT}, {\tt RVM\_BUILD }
and {\tt PATH} need not be explicitly set each time: they could have
been set in your {\tt .cshrc}.

More advanced users can experiment with the {\tt RVM\_BUILD\_COPY}
environment variable.  If this is set, then the {\tt
  jbuild.linkBooter} phase of the build process is replaced by the
execution of {\tt `\$RVM\_BUILD\_COPY`}.  This opens up a lot of
possibilities, including: copying the build directory to a target
machine and executing {\tt jbuild.linkBooter} remotely on the target
via {\tt rsh} or {\tt ssh}, etc.  By setting {\tt RVM\_BUILD\_COPY}
appropriately on the host platform, cross-platform building can become
a stream-lined process.

\JikesTMFooter

\JavaTMFooter

\AIXTMFooter

\subsection{Building the libraries}

Most RVM users will not need to rebuild the libraries; thus the default
process described above provides a ``binary'' {\tt rvmrt.jar}.  However,
the library source for the RVM is available at
\xlink{{\tt \RVMDownloadURL}}{\RVMDownloadURL}.  
Please consult the 
\xlink{license}{\RVMLibSourceLicenseURL} for restrictions.  

Should you decide to modify the library, you will need to rebuild the 
{\tt rvmrt.jar}.  The script to do this is
{\tt \$RVM\_ROOT/rvm/bin/jBuildLibs}.  Running this script will compile the
library sources in {\tt \$RVM\_ROOT/support/lib}, and build a new {\tt
rvmrt.jar} in {\tt \$RVM\_BUILD}.

You will find that some versions (including 1.13) of 
\xlink{{\tt Jikes\trademark}}{ \jikesURL } fail to compile the
libraries, dying with myriad errors.  You need to apply Jikes 
patch 62 to
the Jikes build to fix a problem with variable shadowing by inner classes. 
We have
successfully applied this patch to Jikes version 1.13 on both
AIX\AIXTMFootnote and Linux/IA32.

The {\tt jBuildLibs} script will prompt you, asking whether to install 
the new {\tt rvmrt.jar} in {\tt \$RVM\_ROOT/support/lib}.  
If you answer {\tt 'y'}, future invocations of {\tt jbuild} will pick up
the new library build.  However, note that by installing it, you will
{\em overwrite} the original version of {\tt rvmrt.jar}, losing it.  Be
careful!

\JikesTMFooter

\AIXTMFooter

\subsection{Building documentation}

The {\tt \RVMTarFile} file contains a postscript version of this userguide
in {\tt \$RVM\_ROOT/rvm/doc}.  Additionally, the 
\xlink{developerWorks web page}{\RVMHomeURL} keeps an on-line version of
the userguide and javadoc API, corresponding to the latest HEAD of the CVS
repository.

If you would like to recover the userguide or javadoc for an older release
of RVM, you can rebuild the documentation locally.  See the Makefile in
{\tt \$RVM\_ROOT/rvm/doc/userguide} for rules on how to build the
HTML userguide using
\xlink{{\tt hyperlatex}}{\HyperlatexURL}.  To build the javadoc pages, use
the {\tt jdoc.sh} script in {\tt \$RVM\_ROOT/rvm/bin}; this script takes as
its one command-line argument the directory to output the javadoc HTML.

