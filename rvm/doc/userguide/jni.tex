\index{JNI}%
\index{native code}

This section describes how Jikes RVM interfaces to native code. There
are three major aspects of this support:
\begin{description}
\item[JNI Functions] This is the mechanism for transitioning from
native code into Java code.  Jikes RVM implements all but 3 of the
functions defined by the 1.1 JNI specification. Jikes RVM implements
some of the additional functions added by the 1.2 JNI
specification.
\item[Native methods] This is the mechanism for transitioning from
Java code to native code. In addition to the normal mechanism used to
invoke a native method, Jikes RVM also supports a more restricted
syscall mechanism that is used internally by low-level VM code to
invoke native code. 
\item[Integration with $m$-to-$n$ threading] Attempting to get Jikes RVM's
cooperative $m$-to-$n$ threading model to work nicely (at all) with native
code is a major challenge. We have gone through several major
redesigns of the JNI support code and RVM thread system in the
process. This is still a work in progress.
\end{description}
Each of these aspects is discussed in more detail in the following
sections. 

\subsection{JNI Functions}
All but three of the functions defined by the 1.1 JNI specification are
implemented by Jikes RVM.\@ The missing functions are {\tt DefineClass},
{\tt RegisterNatives}, and {\tt UnregisterNatives}.  Almost all of the
additional functions added by the 1.2 JNI specification are not
implemented.  Contributions of the missing functionality (and
associated tests) would be greatly appreciated. 

The functions are defined in the class {\tt VM\_JNIFunctions}. Methods
of this class are compiled with special prologues/epilogues that
translate from native calling conventions to Java calling conventions
and handle other details of the transition related to $m$-to-$n$
threading.  Currently the optimizing compiler 
does not support these specialized prologue/epilogue sequences so all
methods in this class are baseline compiled.  The prologue/epilogue
sequences are actually generated by the platform-specific {\tt
VM\_JNICompiler}. 

\subsection{Invoking Native Methods}
There are two mechanisms whereby RVM may transition from Java code to native
code.

\index{syscall}%
The first mechanism is when RVM calls a method of the class {\tt VM\_SysCall}.
The native methods thus invoked are defined in one of the
C and C++ files of the {\tt JikesRVM} executable. 
These native methods are non-blocking system calls or C library 
services.  To implement a syscall, the RVM compilers generate a call
sequence consistent with the platform's underlying calling convention.
A {\tt syscall} is not a GC-safe point, so {\tt syscall}s may modify the
Java heap (eg. {\tt memcpy()}). For more details on the mechanics of adding a
new \texttt{syscall} to the system, see the header comments of 
\xlink{{\tt VM\_SysCall.java}}{\VMSysCallURL}.

The second mechanism is JNI.\@  Naturally, the user writes JNI code
using the JNI interface.  RVM implements a call to a native method by
using the platform-specific {\tt VM\_JNICompiler} to generate a stub
routine that manages the transition between Java bytecode and native
code.  A JNI call is a GC-safe point, since JNI code cannot freely
modify the Java heap. 

\subsection{Interactions with $m$-to-$n$ Threading}
\link{See the \SectionName{Thread System} subsection}[ (subsection~\Ref,
page~\Pageref)]{sec:threads} for more details on the thread system
and $m$-to-$n$ threading in Jikes RVM.\@ 

There are two ways to execute native code: {\tt syscall}s and JNI.\@
A Java thread that calls native code by either mechanism will never
be preempted by \jrvm{}.\@  As far as \jrvm{} is concerned, a Java thread that
enters native code has exclusive access to the underlying {\tt
VM\_Processor} (pthread) until it returns to Java.  Of course the OS may preempt the underlying
pthread; this falls beyond \jrvm{}'s control.

Some activities (eg. GC) require all threads currently running Java code to halt.  
So what happens when one Java thread forces a GC while another Java thread is
executing native code?

If the native code is a {\tt syscall}, then the VM stalls until the native
code returns.  Thus, all {\tt syscall}s should be non-blocking
operations that return fairly soon.  Note that a {\tt syscall} is 
{\em not} a GC-safe point.

On Linux/x86, Jikes RVM ``hijacks'' certain blocking system calls and
reflects them back into the VM.\@  The VM then uses nonblocking
equivalents. This handles many of the common cases of blocking native
code without requiring the full complexity of the timer-based
preemption mechanism that we used to use on AIX.\@  A complete
solution would consist of implementing both mechanisms on both
platforms.  We hope to do this in the future.

\subsection{Implementation Details}
Supporting the combination of blocking native code and $m$-to-$n$
threading is inherently complicated.  Unfortunately the Jikes RVM
implementation is further complicated by the fact that too much of the
control logic for transitions between C and Java code is embedded in
the low-level, platform-specific {VM\_JNICompiler} classes.  As a
result, the code is hard to maintain and the JNI implementations
on different platforms tend to diverge. 

We have some ideas for a redesign that would enable more of the
control logic to be embodied in shared Java code, but there are a few
minor issues to be worked out.  Hopefully this will happen eventually.
