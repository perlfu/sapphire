This section provides information on ``magic'' which is an escape
hatch that Jikes\trademark RVM provides to implement
functionality that is not 
possible in pure Java\trademark.  For example, the Jikes RVM garbage
collectors and 
runtime system must, on occasion, access memory or perform unsafe
casts.  Users are {\it strongly} discourage from using magic in their code
except where absolutely necessary.  

There are currently two types of magic which are described in the remainder of this
section.  The first is a collection of magical methods
that are static methods of the class {\tt VM\_Magic}.  The second is the magical class
{\tt VM\_Address} used in parts of the runtime and garbage collector.

\subsection{VM\_Magic}
\index{magic methods}
\index{VM\_Magic}
\index{semantic inlining}
Certain methods in the class \xlink{{\tt VM\_Magic}}{\VMMagicURL}
are treated differently by the compiler. Because these methods access
raw memory or other machine state, perform unsafe casts, 
or are operating system calls, they cannot be implemented in Java
code.  A Jikes\trademark RVM implementor must be {\em extremely
careful} when writing 
code that uses {\tt VM\_Magic} to circumvent the Java type
system.  The use of {\tt VM\_Magic.objectAsAddress} to perform various
forms of pointer arithmetic is especially hazardous, since it can
result in pointers being ``lost'' during garbage collection. 
All such uses of magic must either occur in uninterruptible
code ({\it i.e.} in a method of a class that {\em directly} implements 
the \xlink{{\tt VM\_Uninterruptible}}{\VMUninterruptibleURL} class) 
or be guarded by calls to {\tt VM.disableGC} and {\tt VM.enableGC}.  
The optimizing compiler performs aggressive inlining and code motion 
and not explictly marking such dangerous regions in one of these two manners 
will lead to disaster.

Since magic is inexpressible in Java, it is unsurprising that the bodies 
of {\tt VM\_Magic} methods are undefined.  Instead, for each of these methods, 
the Java instructions to generate the code is stored in 
\xlink{{\tt OPT\_GenerateMagic}}{\OPTGenerateMagicURL} and 
\xlink{{\tt OPT\_GenerateMachineSpecificMagic}}{\OPTGenerateMachineSpecificMagicURL} (to generate HIR) and 
\xlink{{\tt VM\_MagicCompiler}}{\VMMagicCompilerURL} (to generate assembly code)\footnote{The optimizing
compiler always uses the set of instructions that generate HIR; the
instructions that generate assembly code are only invoked by the
baseline compiler.}.  Whenever the compiler encounters a call to one of these
magic methods, it inlines appropriate code for the magic method into the caller method.

\JikesTMFooter

\subsection{VM\_Address}
\index{VM\_Address}
The type {\tt VM\_Address} is used to represent a machine-dependent address type.
In the past, the base type {\tt int} was used to represent addresses but this approach
had several shortcomings.  First, the lack of abstraction makes porting
nightmarish.  Equally important is that Java type {\tt int} is signed whereas address are 
more appropriately considered unsigned.  The difference is problematic since an
unsigned comparison on {\tt int} is inexpressible in Java.

To overcome these problems, instances of {\tt VM\_Address} are used to
represent addresses.  The class supports
the expected well-typed methods like adding an integer offset to an address to
obtain another address, computing the difference of two addresses, and
comparing addresses.  Other operations that make sense on {\tt int} but not on
addresses are  excluded like multiplication of addresses.  Two methods
deserve special attention: converting an address into an integer and the inverse.
These methods should be avoided where possible.

Without special intervention, using a Java object to represent an address would
be at best abysmally inefficient.  Instead, when the Jikes compiler encounters creation
of an address object, it will return the primitive value that represents an address
for that platform.  Currently, the address type maps to a 32-bit unsigned
integer.  Since an address is not really an object, the following must
be kept in mind:

\begin{enumerate}
\item{} Do not pass a {\tt VM\_Address} instance where an {\tt Object} is expected. This will
type-check but it not what you want.  A corollary is to avoid overloading a method on
both {\tt Object} or a {\tt VM\_Address}.
\item{} Do not synchronize on a {\tt VM\_Address} instance.
\item{} Due to a current shortcoming in the way {\tt VM\_Address} works, do not make an
array of {VM\_Address} values.  This restriction may be removed in the future.
\end{enumerate}


\JavaTMFooter
