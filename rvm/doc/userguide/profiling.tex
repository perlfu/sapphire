This section contains information on several ways in which
Jikes\trademark RVM can be used to profile an application and the VM
itself.  The first section describes how Jikes RVM supports
platform-specific hardware performance monitors (HPM). Currently HPM
support is only available for
PowerPC\PowerPCTMFootnote/AIX\AIXTMFootnote\ version 5, but can be
used in any configuration of Jikes RVM on that platform.  The next two
sections describe how adaptive configurations of Jikes RVM can be used
to gather profile data.  This support is available on all platforms,
but only in adaptive configurations.

\AIXPPCJikesTMFooter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using Hardware Performance Monitors}

Jikes RVM can be built to enable access to the PowerPC hardware
performance monitors (HPMs) using the {\tt bos.pmapi} interface 
included in AIX version 5. To build Jikes RVM to use
HPMs, you must define RVM\_HPM\_DIR to be the directory containing
the pmapi code (typically /usr/pmapi) and RVM\_WITH\_HPM to be 1.
See the config file \$RVM\_ROOT/rvm/config/powerpc-ibm-aix5.1.MC4U for
an example.

After a valid configuration is built, the HPM are accessed through 
command line options. 
The command line options that are available are enumerated with the 
{\tt help} option prefixed with {\tt -X:hpm:}.  This option
generates the following output:
%
\begin{verbatim}
Boolean Options (-X:hpm:<option>=true or -X:hpm:<option>=false) default is false
 Option       Description
 trace        trace HPM counter values at each thread switch.
 processor    print name of processor and number of counters.
 listAll      list all events associated with each counter.
 listSelected list selected events for each counter.

Value Options (-X:hpm:<option>=<value>)
 Option        Type    Description
 eventN        int     specify event for counter N where 1<=N<=UB and UB is processor specific
 filename      String  prefix for file names.  Concatenate virtual processor number.
 mode          int     specify mode: 1=GROUP, 2=PROCESS, 4=KERNEL, 8=USER, 16=COUNT, 32=PROCTREE
 trace_verbose int     write events for this PID to the console.  Used on a multiprocessor.
 verbose       int     print more information.
\end{verbatim}

At least one HPM event command line option must be set for HPM counter values to be gathered.  
When HPM counter values are gathered, aggregate values for each event 
are generated for each virtual processor, and each Java thread that executes.
For example, the aggregate HPM counter values for virtual processor 1
when Jikes RVM is run on the PowerPC POWER4 architecture with group 23 
specified generated the following output:

\begin{verbatim}
Dump HPM counter values for virtual processors
 Virtual Processor: 1
0: REAL_TIME           :4,398,503,873
1: PM_LSU_SRQ_S0_VALID :2,244,438,656
2: PM_LSU_SRQ_S0_ALLOC :71,532,205
3: PM_LSU0_BUSY        :2,470,379,577
4: PM_LSU1_BUSY        :1,882,422,375
5: PM_LSU_LRQ_S0_VALID :3,894,273,486
6: PM_LSU_LRQ_S0_ALLOC :153,366,828
7: PM_INST_CMPL        :13,890,418,177
\end{verbatim}

The {\tt -X:hpm:trace=true} command line option generates a trace file for each 
virtual processor. 
(The number of virtual processors is specified by the {\tt -X:processors} command line option.)
A trace file contains a trace record every time a Java thread switch occurs on the 
corresponding virtual processor.
The record contains the HPM counter values at the thread switch in addition to 
the identification of the Java thread.

The Jikes RVM callback mechanism allows the application's soure code 
to make callbacks that when executed will place a marker record in the trace file.
When the trace file is processed, the marker records allow the
programmer to focus on portions of the execution.
Jikes RVM uses this mechanism to open the trace files
when the it starts executing and close the files when it exits.
The AppStart, AppComplete, AppRunStart, and AppRunComplete monitors
are supported for application use.  
Support for other callbacks can be easily added following the current design.

A trace file reader is available in the \$RVM\_ROOT/rvm/src/tools/HPM\_traceFileReader
subdirectory.  Type {\tt make} on the command line to generate the class files and then 
type {\tt java TraceFileReader} to determine what command line options are available.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Profiling An Application}
One component of the adaptive optimization system is a low-overhead
time-based sampling mechanism.  This information can be used to drive
recompilation decisions
\T~\cite{jalapeno-adaptive-00}.
It can also be used to produce an aggregate
profile of the execution of an application.  
Here's how.

\begin{enumerate}
\item Create an adaptive configuration.  For the most accurate profile use
{\tt FastAdaptiveSemiSpace}.  See Section~\ref{section:installation}
\begin{verbatim}
% jconfigure FastAdaptiveSemiSpace
% cd $RVM_BUILD
% jbuild
\end{verbatim}

\item Run the application using the opt compiler as the runtime compiler and
instructing Jikes RVM to gather profile data.
\begin{verbatim}
% rvm -X:aos:primary_strategy=optonly -X:aos:gather_profile_data=true <classfile>
\end{verbatim}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Instrumented Event Counters}
\label{counting_events}
This section describes how the Jikes RVM optimizing compiler
can be used to 
insert counters in the optimized code to count the frequency of
specific events.  Infrastructure for counting events is in place that
hides many of the implementation details of the counters, so that
(hopefully) adding new code to count events should be easy.  All of
the instrumentation phases described below require an adaptive boot
image (any one should work).  Most of the code regarding
instrumentation lives in {\tt
\$RVM\_ROOT/rvm/src/vm/adaptive/runtimeMeasurements/instrumentation} and {\tt
adaptive/recompilation/instrumentation}.

Section~\ref{existing_phases} describes existing instrumentation
phases and how to run them, and Section~\ref{adding_phases}
describes the details of how a new phase can be added.

\subsubsection{Existing Instrumentation Phases}
\label{existing_phases}
There several existing instrumentation phases.  For now,
turning on each phase requires setting two flags, one for the AOS
system, and one for the opt compiler.  These counters are {\em not}
synchronized (as discussed in Section~\ref{adding_phases}), so they
should not be considered precise.
\begin{enumerate}
\item {\bf Method Invocation Counters} 

Inserts a counter in each method prologue.  Prints counters to stderr
at end.

Parameters: \\
{\tt
-X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_method\_counters\_opt=true}

\item {\bf Yieldpoint Counters}  

Inserts a counter after each yieldpoint instruction.  Maintains a
separate counter for backedge and prologue yieldpoints.

Parameters:\\
{\tt -X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_yieldpoint\_counters=true}




\item {\bf Instruction Counters}  

Inserts a counters on each instruction.  A separate count is
maintained for each opcode, and results are dumped to stderr at end of
run. The results look something like:

\begin{verbatim}
Printing Instruction Counters:
------------------------------
109.0 call
0.0 int_ifcmp
30415.0 getfield
20039.0 getstatic
63.0 putfield
20013.0 putstatic
Total: 302933
\end{verbatim}

This is useful for debugging or assessing the effectiveness
of an optimization because you can see a dynamic execution count, rather
than relying on timing.  

NOTE: Currently the counters are inserted at the end of HIR, so the
counts {\em will} capture the effect of HIR optimizations, and will
{\em not} capture optimization that occurs in LIR or later.  

\item {\bf Debugging Counters}  

This flag does not produce observable behavior by itself, but is
designed to allow debugging counters to be inserted easily in
opt-compiler to help debugging of opt-compiler transformations.
If you would like to know the dynamic frequency of a particular
event, simply turn on this flag, and you can easily count dynamic
frequencies of events by calling the method
\xlink{{\tt VM\_AOSDatabase.debuggingCounterData.
getCounterInstructionForEvent(String eventName);}}{\VMAOSDatabaseURL}.  This method
returns an 
\xlink{{\tt OPT\_Instruction}}{\OPTInstructionURL} 
that can be inserted into the
code.  The instruction will increment a counter associated with
the String name ``eventName'', and the counter will be printed at the
end of execution.

For an example, see 
\xlink{{\tt OPT\_Inliner.java}}{\OPTInlinerURL}.  
Look
for the code guarded by the flag {\tt COUNT\_FAILED\_METHOD\_GUARDS}.
 
Parameters:\\
{\tt -X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_debugging\_counters=true}

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Writing new instrumentation phases}
\label{adding_phases}
This subsection describes the event counting infrastructure.  It is
not a step-by-step for writing new phases, but instead is a
description of the main ideas of the counter infrastructure.
This description, in combination with the above examples, should be
enough to allow new users to write new instrumentation phases.

\paragraph{Counter Managers:}  Counters are created and inserted into
the code using the 
\xlink{{\tt
OPT\_InstrumentedEventCounterManager}}{\OPTInstrumentedEventCounterManagerURL} 
interface.
The purpose of the counter manager interface is to abstract away the
implementation details of the counters, making instrumentation
phases simpler and allowing the counter implementation to be changed
easily (new counter managers can be used without changing any of the
instrumentation phases).  Currently there exists only one counter
manager, 
\xlink{{\tt VM\_CounterArrayManager}}{\VMCounterArrayManagerURL}
, which implements unsynchronized
counters.
When instrumentation options
are turned on in the adaptive system, 
\xlink{{\tt VM\_Instrumentation.boot()}}{\VMInstrumentationURL}
creates an instance of a \xlink{{\tt VM\_CounterArrayManager}}{\VMCounterArrayManagerURL}.

\paragraph{Managed Data:} The class 
\xlink{{\tt VM\_ManagedCounterData}}{\VMManagedCounterDataURL} 
is used to
keep track of counter data that is managed using a counter
manager. This purpose of the data object is to maintain the mapping
between the counters themselves (which are indexed by number) and the
events that they represent.  For example, 
\xlink{{\tt VM\_StringEventCounterData}}{\VMStringEventCounterDataURL} 
is used record the fact that counter \#1
maps to the event named ``FooBar''.  

\ignore{ {\tt VM\_InstrumentedControlFlowEdgeData} is used during edge counting to
record the fact that counter \#1 maps to the ``fallthrough'' edge of
the branch instruction at bytecode offset \#5 at inline context
FooBar.  }

Depending on what you are counting, there may be one data object for
the whole program (such as 
\xlink{{\tt VM\_YieldpointCounterData}}{\VMYieldpointCounterDataURL} and
\xlink{{\tt
VM\_MethodInvocationCounterData}}{\VMMethodInvocationCounterDataURL}), 
or one per method.  There is also a
generic data object called 
\xlink{{\tt VM\_StringEventCounterData}}{\VMStringEventCounterDataURL} 
that
allows events to be give string names (see Debugging Counters above).

\paragraph{Instrumentation Phases:}  The instrumentation itself is
inserted by a compiler phase.  (see
\xlink{{\tt
OPT\_InsertInstructionCounters.java}}{\OPTInsertInstructionCountersURL},
\xlink{{\tt
OPT\_InsertYieldpointCounters.java}}{\OPTInsertYieldpointCountersURL},
\xlink{{\tt
OPT\_InsertMethodInvocationCounter.java}}{\OPTInsertMethodInvocationCounterURL} 
).  The instrumentation phase
inserts high level ``count event'' instructions (which are obtained by
asking the counter manager) into the code.  It also updates the
instrumented counter to remember which counters correspond to which
events.

\paragraph{Lower Instrumentation Phase:}  This 
\xlink{phase}{\OPTCompilerPhaseURL}
converts the high level ``count event'' instruction into the actual
counter code by using the counter manager.  It currently occurs at the
end of LIR, so instrumentation can not be inserted using this
mechanism after LIR.  This phase does not need to be modified if you
add a new phase, except that the {\tt shouldPerform()} method needs to
have your instrumentation listed, so this phase is run when your
instrumentation is turned on.


