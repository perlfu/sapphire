This section contains information on several ways in which
Jikes\trademark RVM can be used to profile an application and the VM
itself.  The first section describes how Jikes RVM supports
platform-specific hardware performance monitors (HPM). Currently HPM
support is only available for
PowerPC\PowerPCTMFootnote/AIX\AIXTMFootnote\ version 5, but can be
used in any configuration of Jikes RVM on that platform.  The next two
sections describe how adaptive configurations of Jikes RVM can be used
to gather profile data.  This support is available on all platforms,
but only in adaptive configurations.

\AIXPPCJikesTMFooter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Using Hardware Performance Monitors}

Jikes RVM can be built to enable access to the PowerPC hardware
performance monitors (HPM) using the {\tt bos.pmapi} interface 
included in AIX\AIXTMFootnote\ version 5. To build Jikes RVM to use
HPMs, you must define RVM\_HPM\_DIR to be the directory containing
the pmapi code (typically /usr/pmapi) and RVM\_WITH\_HPM to be 1.
See the config file \$RVM\_ROOT/rvm/config/powerpc-ibm-aix5.1.MC4U for
an example.

After a valid configuration is built, the HPM are accessed through 
command line options.  There are two options available:
%
\begin{itemize}
\item {\tt -X:hpm:event<k>=N} where {\tt k} is an integer (starting from 1) that identifies an
HPM counter, and {\tt N} is an integer that identifies, for the identified counter, 
the event that is counted.
The number of counters and the events associated with a specific counter are microprocessor specific.  
For example, the PowerPC 604e only has four counters where the PowerPC 630 and Power 4 have eight.
The PowerPC 604e reserves event number 2 on every counter to count the number of instructions 
completed whereas the PowerPC 630 reserves event number 3.
\item {\tt -X:hpm:mode=N} controls when events are counted: 
{\tt N} =  4 when user code is running, 
{\tt N} =  8 when kernel code is running, or 
{\tt N} = 12 when both user and kernel code is running.
\end{itemize}

At least one HPM event command line option must be set for HPM counter values to be gathered.  
HPM only works accurately when the number of virtual processors is one, {\tt -X:processors=1}.  
The output for a PowerPC 604e machine when the command line arguments are
%
\begin{verbatim}
% rvm -X:hpm:event1=6 -X:hpm:event2=6 -X:hpm:event3=2 -X:hpm:event4=1 -X:hpm:mode=12
\end{verbatim}
%
looks like:
\begin{verbatim}
*** Configuration :
Mode = kernel and user; Process tree = off; Thresholding = off 
Counter  1, event  6: PM_DTLB_MISS
Counter  2, event  6: PM_DC_MISS
Counter  3, event  2: PM_INST_CMPL
Counter  4, event  1: PM_CYC

*** Results :
PMC 1     PMC 2     PMC 3     PMC 4     
=====     =====     =====     =====     
4300056   8018925   1002604892  2412445847  
\end{verbatim}

\AIXPPCJikesTMFooter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Profiling An Application}
One component of the adaptive optimization system is a low-overhead
time-based sampling mechanism.  This information can be used to drive
recompilation decisions
\T~\cite{jalapeno-adaptive-00}.
It can also be used to produce an aggregate
profile of the execution of an application.  
Here's how.

\begin{enumerate}
\item Create an adaptive configuration.  For the most accurate profile use
{\tt FastAdaptiveSemiSpace}.  See Section~\ref{section:installation}
\begin{verbatim}
% jconfigure FastAdaptiveSemiSpace
% cd $RVM_BUILD
% jbuild
\end{verbatim}

\item Run the application using the opt compiler as the runtime compiler and
instructing Jikes RVM to gather profile data.
\begin{verbatim}
% rvm -X:aos:primary_strategy=optonly -X:aos:gather_profile_data=true <classfile>
\end{verbatim}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Instrumented Event Counters}
\label{counting_events}
This section describes how the Jikes RVM optimizing compiler
can be used to 
insert counters in the optimized code to count the frequency of
specific events.  Infrastructure for counting events is in place that
hides many of the implementation details of the counters, so that
(hopefully) adding new code to count events should be easy.  All of
the instrumentation phases described below require an adaptive boot
image (any one should work).  Most of the code regarding
instrumentation lives in {\tt
\$RVM\_ROOT/rvm/src/vm/adaptive/runtimeMeasurements/instrumentation} and {\tt
adaptive/recompilation/instrumentation}.

Section~\ref{existing_phases} describes existing instrumentation
phases and how to run them, and Section~\ref{adding_phases}
describes the details of how a new phase can be added.

\subsubsection{Existing Instrumentation Phases}
\label{existing_phases}
There several existing instrumentation phases.  For now,
turning on each phase requires setting two flags, one for the AOS
system, and one for the opt compiler.  These counters are {\em not}
synchronized (as discussed in Section~\ref{adding_phases}), so they
should not be considered precise.
\begin{enumerate}
\item {\bf Method Invocation Counters} 

Inserts a counter in each method prologue.  Prints counters to stderr
at end.

Parameters: \\
{\tt
-X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_method\_counters\_opt=true}

\item {\bf Yieldpoint Counters}  

Inserts a counter after each yieldpoint instruction.  Maintains a
separate counter for backedge and prologue yieldpoints.

Parameters:\\
{\tt -X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_yieldpoint\_counters=true}




\item {\bf Instruction Counters}  

Inserts a counters on each instruction.  A separate count is
maintained for each opcode, and results are dumped to stderr at end of
run. The results look something like:

\begin{verbatim}
Printing Instruction Counters:
------------------------------
109.0 call
0.0 int_ifcmp
30415.0 getfield
20039.0 getstatic
63.0 putfield
20013.0 putstatic
Total: 302933
\end{verbatim}

This is useful for debugging or assessing the effectiveness
of an optimization because you can see a dynamic execution count, rather
than relying on timing.  

NOTE: Currently the counters are inserted at the end of HIR, so the
counts {\em will} capture the effect of HIR optimizations, and will
{\em not} capture optimization that occurs in LIR or later.  

\item {\bf Debugging Counters}  

This flag does not produce observable behavior by itself, but is
designed to allow debugging counters to be inserted easily in
opt-compiler to help debugging of opt-compiler transformations.
If you would like to know the dynamic frequency of a particular
event, simply turn on this flag, and you can easily count dynamic
frequencies of events by calling the method
\xlink{{\tt VM\_AOSDatabase.debuggingCounterData.
getCounterInstructionForEvent(String eventName);}}{\VMAOSDatabaseURL}.  This method
returns an 
\xlink{{\tt OPT\_Instruction}}{\OPTInstructionURL} 
that can be inserted into the
code.  The instruction will increment a counter associated with
the String name ``eventName'', and the counter will be printed at the
end of execution.

For an example, see 
\xlink{{\tt OPT\_Inliner.java}}{\OPTInlinerURL}.  
Look
for the code guarded by the flag {\tt COUNT\_FAILED\_METHOD\_GUARDS}.
 
Parameters:\\
{\tt -X:aos:primary\_strategy=optonly \\
-X:aos:share:insert\_debugging\_counters=true}

\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Writing new instrumentation phases}
\label{adding_phases}
This subsection describes the event counting infrastructure.  It is
not a step-by-step for writing new phases, but instead is a
description of the main ideas of the counter infrastructure.
This description, in combination with the above examples, should be
enough to allow new users to write new instrumentation phases.

\paragraph{Counter Managers:}  Counters are created and inserted into
the code using the 
\xlink{{\tt
OPT\_InstrumentedEventCounterManager}}{\OPTInstrumentedEventCounterManagerURL} 
interface.
The purpose of the counter manager interface is to abstract away the
implementation details of the counters, making instrumentation
phases simpler and allowing the counter implementation to be changed
easily (new counter managers can be used without changing any of the
instrumentation phases).  Currently there exists only one counter
manager, 
\xlink{{\tt VM\_CounterArrayManager}}{\VMCounterArrayManagerURL}
, which implements unsynchronized
counters.
When instrumentation options
are turned on in the adaptive system, 
\xlink{{\tt VM\_Instrumentation.boot()}}{\VMInstrumentationURL}
creates an instance of a \xlink{{\tt VM\_CounterArrayManager}}{\VMCounterArrayManagerURL}.

\paragraph{Managed Data:} The class 
\xlink{{\tt VM\_ManagedCounterData}}{\VMManagedCounterDataURL} 
is used to
keep track of counter data that is managed using a counter
manager. This purpose of the data object is to maintain the mapping
between the counters themselves (which are indexed by number) and the
events that they represent.  For example, 
\xlink{{\tt VM\_StringEventCounterData}}{\VMStringEventCounterDataURL} 
is used record the fact that counter \#1
maps to the event named ``FooBar''.  

\ignore{ {\tt VM\_InstrumentedControlFlowEdgeData} is used during edge counting to
record the fact that counter \#1 maps to the ``fallthrough'' edge of
the branch instruction at bytecode offset \#5 at inline context
FooBar.  }

Depending on what you are counting, there may be one data object for
the whole program (such as 
\xlink{{\tt VM\_YieldpointCounterData}}{\VMYieldpointCounterDataURL} and
\xlink{{\tt
VM\_MethodInvocationCounterData}}{\VMMethodInvocationCounterDataURL}), 
or one per method.  There is also a
generic data object called 
\xlink{{\tt VM\_StringEventCounterData}}{\VMStringEventCounterDataURL} 
that
allows events to be give string names (see Debugging Counters above).

\paragraph{Instrumentation Phases:}  The instrumentation itself is
inserted by a compiler phase.  (see
\xlink{{\tt
OPT\_InsertInstructionCounters.java}}{\OPTInsertInstructionCountersURL},
\xlink{{\tt
OPT\_InsertYieldpointCounters.java}}{\OPTInsertYieldpointCountersURL},
\xlink{{\tt
OPT\_InsertMethodInvocationCounter.java}}{\OPTInsertMethodInvocationCounterURL} 
).  The instrumentation phase
inserts high level ``count event'' instructions (which are obtained by
asking the counter manager) into the code.  It also updates the
instrumented counter to remember which counters correspond to which
events.

\paragraph{Lower Instrumentation Phase:}  This 
\xlink{phase}{\OPTCompilerPhaseURL}
converts the high level ``count event'' instruction into the actual
counter code by using the counter manager.  It currently occurs at the
end of LIR, so instrumentation can not be inserted using this
mechanism after LIR.  This phase does not need to be modified if you
add a new phase, except that the {\tt shouldPerform()} method needs to
have your instrumentation listed, so this phase is run when your
instrumentation is turned on.


