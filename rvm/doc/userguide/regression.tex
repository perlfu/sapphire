 The Jikes\TMweb{} RVM distribution includes a harness for running
regression and performance tests, and several example applications
that use this harness.  It is located in the {\tt
\$RVM\_\-ROOT/rvm/regression} subtree in the distribution, and consists
of three parts:
\begin{itemize}
\item support for running sanity and performance tests, 
\item individual benchmark test subdirectories, and 
\item a driver for running nightly sanity tests.  
\end{itemize}
The support for running
sanity and performance tests comprises a set of scripts and makefiles
that define a common interface for running a variety of programs, and
for determining their performance and correctness.  The individual
tests are all located in {\tt{\$RVM\_\-ROOT/rvm/regression/tests}}, and
consist of makefiles, scripts, sample inputs and outputs; each
directory contains support for running an individual application in
the testing harness.  The support for night sanity runs is a layer on
top of actual sanity testing support to ease the task of running and
monitoring the tests periodically.  Each of the these portions is now
described in more detail.

\subsubsection{Testing Support}

The top-level driver for running sanity tests is called
{\tt{RunSanityTests}}; it is located in the {\tt
\$RVM\_\-ROOT/rvm/regression} directory 
and requires {\tt{bash}} and {{\tt make}} to run.  When it
is invoked, it will, by default, build a variety of boot images and
run several test programs with each boot image.  The behavior of
\texttt{RunSanityTests} is highly customizable: most of its behavior can be
controlled via command-line options, including what tests and boot
images to run, whether to do sanity or performance tests, and what to
do with test results. These options are described in more detail
below, and a summary can be obtained by invoking {\tt
\$RVM\_\-ROOT/rvm/regression/RunSanityTests -help}. 
We only distribute the full sources to a subset of the regression
tests. The file {\tt \$RVM\_\-ROOT/rvm/regression/Local.rules} is used
to find resources not distributed as part of the Jikes RVM
distribution.  You will need to set an environment variable 
\$BENCHMARK\_\-ROOT that is used by {\tt Local.rules} to point it to
other resources; {\tt Local.rules} contains URLs for finding many of
the regression tests that are not distributed with Jikes RVM.\@
You can also customize your regression testing by making control files
for \texttt{RunSanityTests} to ease running your preferred selection of boot
images, test programs, and options. 

\paragraph{{\tt{RunSanityTests}} Command-Line Options}

 {\tt{RunSanityTests}} allows one to specify a variety of options:
what tests to run, what boot images to build, how many processors to
use, where to put generated boot images and results, whether to run
sanity or performance tests, what optimization levels to use for opt
compiler tests, and options to pass to the Jikes RVM runtime.  These
command-line options are detailed below:

\begin{itemize}
\item{\tt{-test}} ``{\em{test names}}''
\item{\tt{-tests}} ``{\em{test names}}''
\item{\tt{-test-list}} {\em{filename}}

 These command line options control what tests to run.  The
{\tt{-test}} form expects the next command-line word to be a list
of tests (a list of multiple tests must be guarded by quotation marks
in most Unix shells); the {\tt{-test-list}} option takes a single
filename as the next argument, and that file must contain a list of
tests to run.  If the filename is an absolute path, that file is read,
if it is a relative path, it is assumed to be relative to
{\tt \$RVM\_\-ROOT/rvm/regression/config}.  In either case, the items in the
list of tests to run must be subdirectories of
{\tt \$RVM\_\-ROOT/rvm/regression/tests} (the directory that contains the
individual tests).

\item{\tt{-configuration}} ``{\em{configuration names}}''
\item{\tt{-configurations}} ``{\em{configuration names}}''
\item{\tt{-configuration-list}} {\em{file name}}

These command line options control what selection of boot images to
test.  The \texttt{-con\-fi\-gu\-ra\-tion} option expects the next command
line word to be a list of boot image configurations understood by
\texttt{jconfigure} (a list of multiple tests must be guarded by quotation
marks in most Unix\Rweb{} shells); the {\tt{-configuration-file}} option
expects that the next command line word be a filename, and that the
named file contain a list of boot image configuration names understood
by \texttt{jconfigure}.  If the filename is an absolute path, that file is
read, if it is a relative path, it is assumed to be relative to
{\tt \$RVM\_\-ROOT/rvm/regression/config}.

\item{\tt{-result}} {\em root directory}

 This command line option controls where output generated by the
sanity tests should be put.  Programs tend to generate output, and
running tests can cause compilation and other operations that generate
results.  To avoid cluttering up the directories containing the actual
tests, one can specify that the results be put elsewhere with this
option.  The directory specified is actually the root of a tree that
will be created to contain the results of the different tests and
configurations desired; the structure under {\em root
directory} will mimic the structure of the \texttt{regression/tests} directory. 

\item{\tt{-images}} {\em directory}

 This command line option controls where the boot images to be tested
are built. It expects the next command line word to name a directory
in which to place or find boot images. Each such boot image requires a
corresponding build directory, and these directories placed in the
directory specified with this option.  In case the {\tt -nobuild}
option is given, then the boot images are not built, but rather their
build directories must be found, already built, in the directory
specified with this option.

\item{\tt{-use-opt-levels}} ``{\em levels}''

 This command line option controls default optimization levels for
boot images that have been built with the optimizing compiler as the
runtime compiler but without the adaptive system (optimization control
under the adaptive system is more complex, and must be done by
supplying options using the {\tt -rc-args} flag).  This option expects
the next command line word to be a space-separated list of opt levels
({\it e.g.}\ ``\texttt{O0 O1 O2 O3}'', and the specified tests and boot images will be run once with
each specified opt level provided as a boot argument to the runtime
compiler.  This option also forces results to be placed in separate
directories for each optimization level specified.

\item{\tt{-numprocs}} {\em n}

 This command line option specifies how many processors ({\it i.e.}\ Jikes\TMweb{}
RVM virtual processors) are to be used for each test run.  For every
test that is run, the desired number of processors will be given to
Jikes RVM as a boot time command line option.  This option is ignored
for Jikes RVM boot images compiled without support for multiple
virtual processors.

\item{\tt{-nobuild}}

 This command line option instructs \texttt{RunSanityTests} not to build the
boot images to be tested; in this case, the boot images must have been
built already, and be somewhere where \texttt{RunSanityTests} can find them.
See the {\tt -images} option for how to tell \texttt{RunSanityTests} where to
find prebuilt images.

\item{\tt{-norun}}

 This command line option instructs \texttt{RunSanityTests} not to run
any tests.  This makes sense mostly when used to build boot images
that another invocation of \texttt{RunSanityTests} will use.

\item{\tt{-noclean}}

 This option controls whether a clean is performed immediately before
each test is run.  Giving this option means a clean is not performed.

\item{\tt{-wait}} {\em filename}

 This options is used to synchronize parallel \texttt{RunSanityTests} invocation
that are building and running the same set of boot images.  When this
option is given, the filename specified is created in a boot image
directory when the process of building the image completes.  And any
attempt to actually run a test will wait for this file to exist for
the boot image it will use.

\item{\tt{-performance}} {\em filename}

 This option tells \texttt{RunSanityTests} to run performance tests rather than
the default sanity tests.  This invokes each desired test in
performance mode and collects the performance results into the file
specified with this option.  In addition, {\tt{RunSanityTests}} also
produces a summary of the resultant performance data when it finishes
running all of the tests.

\item{\tt{-rc-args}} ``{\em rvm arguments}''

 This option specifies a set of arguments to Jikes RVM that are to be
passed to each invocation of rvm.  This option expects the next
command line word to be the list of options, so multiple options must
be enclosed in quotations.

\item{\tt{-config-args}} ``{\em rvm arguments}''

 This option specifies a set of arguments that are to be
passed to \texttt{jconfigure} for each creation of a boot image.  This option
expects the next command line word to be the list of options, so
multiple options must be enclosed in quotation marks.

\end{itemize}

\paragraph{\texttt{\textbf{Local.rules}} Configuration File}

The {\tt Local.rules} file is located in the 
{\tt \$RVM\_\-ROOT/\-re\-gres\-sion/} directory. 
It customizes the testing harness to your local
setup.  Essentially, it contains the information needed to find test
programs not provided as part of the Jikes RVM distribution, such as
SPECjvm\Rweb{}98 and SPECjbb\Rboth{}2000.  Each test harness
provided as part of Jikes RVM for which the benchmark itself is
not part of the distribution will have an entry in this file telling
the test harness where to find the program itself.  In order to use
the test harness for those benchmarks, you must obtain the benchmark
and install it at your site in the appropriate subdirectory of your
local {\tt \$BENCHMARK\_\-ROOT} directory. {\tt{Local.rules}} defines 
the following variables for a benchmark:
\begin{description}
\item[BENCH\_HOME] is the home directory where the benchmark is
located.  This is used for benchmarks for which a test harness but not
the benchmark itself is distributed with the Jikes RVM distribution. 
\item[BENCH\_JARS] defines a set of jar files to be included in the
classpath of compiles and runs of this benchmark.
\end{description}

\paragraph{Customized Control Files}

\texttt{RunSanityTests} can be given two kinds of control files to make
governing its behavior easier: lists of boot images and lists of
tests.  With the {\tt -con\-fi\-gu\-ra\-tion-list} option, you can provide a
file that lists the set of boot images to build.  This file is a plain
text file, with one boot image name per line; each boot image name
must be one that is understood by \texttt{jconfigure}.  With the {\tt
-test-list} options, you can provide a filename that the set of tests
to run.  Similar to the configuration list file, this file is plain
text, and has one test name per line.  Both types of file should be
placed in the {\tt \$RVM\_\-ROOT/rvm/regression/config} directory; when placed
there, you can refer to them with an unqualified file name on the
\texttt{RunSanityTests} command line.  You can use files from other places as
control files, but those require an absolute path ({\it i.e.}\ one beginning
with a ``{\tt /}'') on the command line.


\subsubsection{Individual Test Programs}

 The {\tt tests} subdirectory of the {\tt{\$RVM\_\-ROOT/rvm/regression}}
directory contains a set of test programs, one in each directory.
These directories do not contain the actual program, but rather the
scripts and makefiles required to run it in the test harness.  The one
essential file will be named \texttt{GNUmakefile} (newer directories)
or \texttt{Makefile} (older directories).  In both cases, that file is
a Makefile written with the \xlink{GNU make}{\gnuMakeURL} syntax.  The structure of these
files is as follows; the sections will be discussed below:  
\begin{enumerate}
\link{\item Include the environment rules from the current build directory}{make-include}
\link{\item Set the benchmark name}{make-set}
\link{\item Include local configuration information, if needed}{make-local}
\link{\item Define benchmark-specific parameters}{make-benchmark-specific-params}
\link{\item Include the test harness makefile}{make-test-harness}
\link{\item Define benchmark-specific rules}{make-benchmark-specific-rules}
\end{enumerate}

\begin{description}
\begin{Label}{make-include}
\item[Include the environment rules from the current build directory]
This is simply the include statement given below.  It is required so
that subsequent portions of the Makefile can find Jikes RVM itself
and information needed from the boot image directory.  This section
is always the one line shown below:
\begin{verbatim}
include         $(RVM_BUILD)/Make.rules.target
\end{verbatim}
\end{Label}

\begin{Label}{make-set}
\item[Set the benchmark name]
This is the name by which the benchmark
is identified in the local configuration file, and this name is also
used in some situations by {\tt{RunSanityTests}} for identifying
output.  It is also possible to specify inclusion of other benchmarks,
to pick up any local definitions they may have.  This section can
define the following make variables.
\begin{description}
\item[BENCH\_NAME] sets the name of this benchmark.  
\item[BENCH\_INCLUDE] is a list of benchmark names to include in this
one.  This means, for instance, that extra jar files specified for
these benchmarks will also be included in this one.
\end{description}
\end{Label}


\begin{Label}{make-local}
\item[Include local configuration information, if needed]
This is
where any information needed to customize the benchmark to your local
configuration is read.  It must occur after {\tt{BENCH\_NAME}} is set
because the information stored in the local configuration file is kept
in terms of benchmark names.  This section must always be the
following single line.
\begin{verbatim}
include         $(JAL_ROOT)/rvm/regression/Local.rules
\end{verbatim}
\end{Label}


\begin{Label}{make-benchmark-specific-params}
\item[Define benchmark-specific parameters]
  This defines essential
benchmark information such as the name of the class with which to
start up, how much heap memory to use, what classpath to use, and the
like.  There are many variables that the test harness understands, and
they can be grouped into three categories: general configuration,
sanity checking and benchmark invocation.

 The general setup options control source and class paths, the heap
sizes needed by the benchmark and any extra boot time arguments to
Jikes RVM.\@  These variables are as follows:
\begin{description}
\item[\varName{BENCH\_SOURCE\_PATH}] is a list of directories in which to find
Java\TMweb{} source files that are used by this benchmark.  This is not a
colon-separated classpath, but a normal whitespace-separated makefile
list.  
\item[\varName{BENCH\_CLASS\_PATH}] is a list of directories and jar files in
which to find Java class files that are used by this benchmark.  This
is not a colon-separated classpath, but a normal whitespace-separated
makefile list.  
\item[\varName{INITIAL\_HEAPSIZE}] is the maximum heap size in megabytes.
\item[\varName{HEAPSIZE}] is the maximum heap size in megabytes.
\item[\varName{BENCH\_RVM\_ARGS}] is extra boot time arguments to provide to
RVM.\@ 
\end{description}

 Sanity checking variables provide a way to specify how to compare the
result of running the program to see if it correct.  You can define an
expected output and also filters to remove extraneous program output
before comparison.  These variables are as follows:
\begin{description}
\item[\varName{EXPECTED}] is a file containing expected output of a program,
against which to diff to check whether the program generated the
correct result.
\item[\varName{AWK\_FILTER}] is a filter to apply to the output of the program
before diffing with EXPECTED.\@  This filter will be applied by GNU
awk. Defining both AWK\_FILTER and SED\_FILTER is not
allowed. 
\item[\varName{SED\_FILTER}] is a filter to apply to the output of the program
before diffing with EXPECTED.\@  This filter will be applied by GNU sed.
Defining both AWK\_FILTER and SED\_FILTER is not allowed. 
\end{description}

 The benchmark command line variables control the Java class to start
and any arguments to pass to it; there are two distinct sets of these
variables depending upon whether the benchmark is a stand-alone program
or a client-server one.  For stand-alone programs, the variables are as
follows: 
\begin{description}
\item[\varName{START\_CLASS}] is the name of the class to give when invoking
Jikes RVM
for this benchmark; this is a normal class name, not a descriptor, so
it expects dots rather than slashes for package names.
\item[\varName{START\_ARGS}] is a string of arguments to pass when invoking
Jikes RVM
for this benchmark.  These arguments are passed after the class name,
so they are arguments to the Java program itself, not boot time
arguments to Jikes RVM.\@
\end{description}

 The client-server programs require more variables since they must
start both client and server for a test.  In fact, there are three
sets of variables: one used to start the server, one used to start the
client, and one used to stop the server.  The client presumably will
stop by itself, but servers typically must be started and stopped
explicitly.  The variables are as follows:
\begin{description}
\item[\varName{SERVER\_NAME}] is the name of the main Java class to use when
starting the server program.
\item[\varName{SERVER\_ARGS}] is a string of the arguments to pass to the server
program when it is started.
\item[\varName{SENTINEL}] is output from the server program which indicates that
it is ok to start the client program.
\item[\varName{CLIENT\_NAME}] is the name of the main Java class to use when
starting the client program.
\item[\varName{CLIENT\_ARGS}] is a string of the arguments to pass to the client
program when it is started.
\item[\varName{STOP\_NAME}] is the name of the main Java class to use when
stopping the server program.
\item[\varName{STOP\_ARGS}] is a string of the arguments to pass to the program
that stops the server.
\end{description}
\end{Label}

\begin{Label}{make-test-harness}
\item[Include the test harness makefile]
  This section loads the rules
required to actually compile any Java files that need it, run the
program, check the output for correctness and assess performance.
This section must always have the following single line:
\begin{verbatim}
include         $(JAL_ROOT)/rvm/regression/Make.rules
\end{verbatim}
\end{Label}

\begin{Label}{make-benchmark-specific-rules}
\item[Define benchmark-specific rules]
  This section defines the rules
needed for the specific benchmark; these rules will utilize the rules
from the test harness.  The benchmark needs to define at least the
following rules:

\begin{description}

\item[sanity] This rule defines what happens when someone types {\tt
make sanity}.  Typically, it will have one dependence, which is the type
of sanity test to perform, of which there are currently the following
four.  All four rules run the program and capture the output; they
differ in how they check for correctness:
\begin{description}
\item[sanity-diff] uses the EXPECTED file to check correctness.  This
is only supported for stand-alone programs.
\item[sanity-compare] runs the same program with the JDK and compares
the results with those obtained from Jikes RVM.\@  This is only supported for
stand-alone programs. 
\item[sanity-check-rule] invokes the ``check'' make rule, which must be
defined by the test program makefile.  The ``check'' rule can assume
that the variable OUT denotes the output file.
\item[server-sanity-check-rules] is like ``check'' but for
client-server programs.  It invokes the ``client-check'' rule with the
client output and the ``server-check'' rule with the server output.
\end{description}

\item[do-gather-performance]  This optional rule is used in
performance mode.  It is given the output file of the program in OUT,
and is expected to write arbitrary text describing performance to the
file \varName{\$PERF\_LOG}.  One line of this output should be a summary and that
line must start with the phrase ``Bottom Line:''

\end{description}

For complex benchmarks, you may need other rules.  One common
situation is a program (such as the SPECjvm98 benchmarks)
that does not provide the ability to specify where to look for input
files; the files simply must be in the working directory.  In that
case, you will need rules to copy any needed input files into the
directory {\tt WORKING}, where the program is actually run.  See the SPECjvm98
benchmark makefiles for examples of this.  Another case we have
encountered is needing explicit dependencies telling the test harness
that some {\tt .class} files are located in a {\tt .jar} file.
\end{Label}

\end{description}

\subsubsection{Night Sanity Support}
 
One common use of regression tests is running them periodically to
keep track of system state over time; the Jikes RVM test harness
provides a {\tt{NightSanityDriver}} to simplify this process.  This
script is a wrapper around {\tt{RunSanityTests}} that takes a
configuration file of boot images and testing options, and uses that
to drive running sanity tests.  {\tt{NightSanityDriver}} takes two
command line arguments:
\begin{description}
\item[-common ``{\em{options}}''] is a list of options to apply to all
invocations of {\tt{RunSanityTests}}.  This is optional.
\item[-config {\em filename}] is a configuration file that specifies a
series of invocations of {\tt{RunSanityTests}}.  If this filename is
relative, it is assumed to be in {\tt \$RVM\_\-ROOT/rvm/regression/config}; if
it is absolute, it is used as it is given.  The format of this file is
discussed below.
\end{description}

 Given these arguments, {\tt{NightSanityDriver}} invokes
{\tt{RunSanityTests}} as instructed on each line of the config file,
appending the common options, if any.

\paragraph{The \texttt{\textbf{NightSanityDriver}} Configuration File}

 The config file for {\tt{NightSanityDriver}} specifies a series of
invocations of {\tt{RunSanityTests}}, one per line of the file.  Each
line starts with a boot image name, and the rest of the line is
options to pass to {\tt{RunSanityTests}}.  {\tt{RunSanityTests}} is
invoked to run just that boot image with the options specified.

\subsubsection{An Example: Night Sanity at Watson}

 To illustrate how the various control files for {\tt{RunSanityTests}}
and {\tt{NightSanityDriver}} can be used, we include a simplified
version of the night sanity configuration used at Watson.  All
configuration files discussed go in the
{\tt \$RVM\_\-ROOT/rvm/regression/config} directory. Since it is
too time consuming to test every possible variation of Jikes RVM on
every program, we have selected a representative sample to run every
night.  The first level is to define two sets of benchmark programs, a
full one and small one used for configurations considered less
critical.  Thus, we have the following two files:

\begin{description}
\item[\IndexTexttt{nightly-tests}] file
\begin{verbatim}
gctest
bytecodeTests
opttests
reflect
threads
utf8
memberNaming
jni
CaffeineMark
jBYTEmark
javalex 
xerces
xalan
soot
ipsixql
SPECjvm98 
SPECjbb2000 
\end{verbatim}
\item[\texttt{nightly-tests-short}] file
\begin{verbatim}
gctest
bytecodeTests
opttests
reflect
threads
CaffeineMark
jBYTEmark
javalex 
\end{verbatim}
\end{description}

 We then have a control file for {\tt{NightSanityDriver}} that runs a
selection of boot images using these two sets of regression tests.
Note that we use the nightly-tests-short list of tests for
configurations that exist mainly for debugging purposes
({\it e.g.}, \texttt{ExtremeAssertions}\textit{*}) or that one can
create but would not want to use in practice.
To ensure relatively complete coverage testing of the optimizing
compiler, we chose one optimizing configuration (FullOptMarkSweep) on
which to run with all the different optimization levels.

\begin{verbatim}
prototype                        -test-list nightly-tests-extended
prototype-opt                    -test-list nightly-tests
development                      -test-list nightly-tests-extended
production                       -test-list nightly-tests
BaseBaseCopyMS                   -test-list nightly-tests
BaseBaseMarkSweep                -test-list nightly-tests
BaseBaseSemiSpace                -test-list nightly-tests
BaseBaseGenCopy                  -test-list nightly-tests
BaseBaseCopyMSUP                 -test-list nightly-tests-short
FullAdaptiveMarkSweep            -test-list nightly-tests
FullAdaptiveCopyMS               -use-opt-levels "O0 O1 O2" -test-list nightly-tests-short
FastAdaptiveCopyMS                -test-list nightly-tests-short
ExtremeAssertionsOptAdaptiveCopyMS -test-list nightly-tests-short
\end{verbatim}

 To make all of this run every night, it is necessary merely to put a
{\tt Night\-San\-i\-ty\-Dri\-ver} invocation in a {\tt crontab}; we actually use a more
involved setup, which we distribute in the {\tt night-sanity-build} and
{\tt night-sanity-run scripts}.  These are somewhat specific to what we want
to test, but they will hopefully make a good model.

\subsection{Mauve tests}
Mauve is an open source test suite for class libraries.  The directory 
{\tt{\$RVM\_\-ROOT/\-rvm/\-re\-gres\-sion/\-tests/\-mauve}} contains a file
{\tt mauve-jikesrvm} that contains the current KEYS used to run Mauve tests
on Jikes RVM.\@ 

