This section describes how to run a Jikes\TMweb{}{} RVM  image built
from the previous section. 

%%%
% This section uses the EBNF commands defined in userguide.tex
%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Running \jrvm}

\cindex[jikes command]{\texttt{jikes} command}%
\cindex[rvm script]{\texttt{rvm} script}%
Jikes\TMweb{} RVM executes Java virtual machine byte code instructions from {\tt .class} files.  
It does {\em not} compile 
Java\TMweb{} source code. Therefore, you must compile all Java source
files into byte code using your favorite Java compiler.
Our favorite Java compiler is the IBM\Rweb{} Jikes compiler. 

For example, to run class {\tt foo} with source code in file {\tt foo.java}:
\begin{verbatim}
% jikes foo.java
% rvm foo 
\end{verbatim}

The general syntax is
\begin{example}
\tt{}   rvm \MZeroOrMore{rvm options\ldots} class \MZeroOrMore{args\ldots}
\end{example}

\index{command-line options}
You may choose from a myriad of options for the {\tt rvm} command-line.  
Options fall into two categories: {\em standard} and {\em
non-standard}.  Non-standard options are preceded by {\bf ``{\tt -X:}''}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Standard Command-Line Options}

We currently support a subset of the JDK 1.4 standard options.  Below
is a list of all options and their descriptions.  Unless otherwise noted each
option is supported in Jikes RVM.\@
\begin{description}
\item[{\tt \Mlbr{} -cp \Mor{} -classpath \Mrbr{} \Mmeta{directories and
zip/jar files separated by \Mlitch{:}}}]
set search path for application classes and resources

\item[{\tt -D\Mmeta{name}=\Mmeta{value}}] set a system property

\item[{\tt -verbose:\Mlsq{} class \Mor{} gc \Mor{} jni \Mrsq}]
enable verbose output

\item[{\tt -version}] print current VM version and terminate the run

\item[{\tt -showversion}] print current VM version and continue running

\item[{\tt -fullversion}] like ``{\tt -version}'', but with more information

\item[{\tt -?} or {\tt -help}] print help message

\item[{\tt -X}] print help on non-standard options

\item[{\tt -jar}] execute a jar file 

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Non-standard Command-Line Options}

The non-standard options are

\begin{description}
\item[{\tt -X}]
immediately print usage information on nonstandard options

\item[{\tt -X:verbose}]
during run, print out additional information for GC and hardware trap handling

\item[{\tt -X:verboseBoot=\Mmeta{number}}]
print out additional information while VM is booting, using verbosity
level \Mmeta{number}.

\item[{\tt -Xms\Mmeta{number}\Mmeta{unit}}]
set the initial heap size to \Mmeta{number}\Mmeta{unit}\footnotemark bytes

\item[{\tt -Xmx\Mmeta{number}\Mmeta{unit}}]
set the maximum heap size to \Mmeta{number}\Mmeta{unit} bytes

\footnotetext{A \Mmeta{unit} of memory size may be specified by any
one of the following: 
\begin{description}
%% Uncomment these lines later.  I'm about to commit the code.
% \item[\texttt{E}] Exabytes (Exbibytes)
% \item[\texttt{P}] Petabytes (Pebibytes)
\item[\texttt{T}] Terabytes (Tebibytes)
\item[\texttt{G}] Gigabytes (Gibibytes)
\item[\texttt{M}] Megabytes (Mebibytes)
\item[\texttt{pages}] Virtual memory pages of 4096 bytes
\item[\texttt{K}] Kilobytes (Kibibytes)
\item[\texttt{B}] Bytes
\end{description}

Historically, omitting the \Mmeta{unit} would cause the \texttt{-Xms}
and \texttt{-Xmx} options to assume units of megabytes.  As of this
writing (December 18, 2004), this may well change in the very near
future so that the absence of a unit means bytes, for compatibility
with the Sun and IBM JDKs and for consistency with the MMTk
(\texttt{-X:gc:}) options.  So, please always specify a unit.

As of October, 2004, parts of MMTk were still internally using a
32-bit integer to represent memory sizes, which means that even on a
64-bit platform you couldn't actually specify a five-gigabyte heap size,
yet.  This would be pretty easy to fix, and will be fixed as soon as
somebody wants to do it.

The \Mmeta{number} part of a memory size is not restricted to being an
integer.  You can use extended-precision floating point values and
hexadecimal values.  So, all three of the following arguments are
equivalent:
\texttt{-Xms0.5G} , \texttt{-Xms0x20000000B} , and \texttt{-Xms512M} .

This argument syntax can be used with all of the memory size
arguments that the GC subsystem has as well.
}

\item[{\tt -X:sysLogfile=\Mmeta{filename}}]
redirects messages that would go to standard error to \Mmeta{filename} instead.

\item[{\tt -X:i=\Mmeta{filename}}]
read Jikes RVM's \emph{boot image} from \Mmeta{filename}

\item[{\tt -X:vm\Mlsq{}:help\Mrsq{}}]
immediately print options supported by the core virtual machine

\item[{\tt -X:vm:\Mmeta{option}}]
pass \Mmeta{option} to the core virtual machine

\item[{\tt -X:gc\Mlsq{}:help\Mrsq}]
print options supported by the memory management system

\item[{\tt -X:gc:\Mmeta{option}}]
pass \Mmeta{option} to the memory management system

\item[{\tt -X:aos\Mlsq{}:help\Mrsq{}}]
print options supported by adaptive optimization system when in an
adaptive configuration

\item[{\tt -X:aos:\Mmeta{option}}]
pass \Mmeta{option} to the adaptive optimization system when in an adaptive configuration

\item[{\tt -X:irc\Mlsq{}:help\Mrsq{}}]
print options supported by the initial runtime compiler

\item[{\tt -X:irc:\Mmeta{option}}]
pass \Mmeta{option} to the initial runtime compiler

\item[{\tt -X:recomp\Mlsq{}:help\Mrsq{}}]
print options supported by the compilers used for recompilation

\item[{\tt -X:recomp:\Mmeta{option}}]
pass \Mmeta{option} to the compilers used for recompilation

\item[{\tt -X:base\Mlsq{}:help\Mrsq{}}]
print the options supported by the baseline compiler

\item[{\tt -X:base:\Mmeta{option}}]
pass \Mmeta{option} to the baseline compiler

\item[{\tt -X:opt\Mlsq{}:help\Mrsq{}}]
print the options supported by the optimizing compiler

\item[{\tt -X:opt:\Mmeta{option}}]
pass \Mmeta{option} to the optimizing compiler

\item[{\tt -X:prof:\Mmeta{option}}]
pass \Mmeta{option} to the profiling subsystem

\item[{\tt -X:vmClasses=\Mmeta{path}}]
load classes from \Mmeta{path}.  \Mmeta{path} is the file name or
file names of one or more {\tt .jar} files.  File names in
\Mmeta{path} are separated by colons (\Mlitch{:}).

\item[{\tt -X:cpuAffinity=\Mmeta{int}}]
\Mmeta{int} is the number of the physical CPU to which the first virtual processor will be bound.

\item[{\tt -X:processors=\Mlsq{} \Mmeta{int} \Mor{} \Mlitch{all} \Mrsq{}}]
number of processors to use on a multiprocessor

\end{description}

\link{Later in this user's guide \texonly{(see appendix~\Ref, page~\Pageref{})} there
are more details on command-line options}{appendix:nonadaptive:cmdline}, including the list of options supported by the baseline
compiler, optimizing compiler, and adaptive optimization system. 

\subsection{Regression Tests}
\label{sec:regression}
\input{regression}

% LocalWords:  args JDK cp gc jni VM showversion fullversion verboseBoot Xms vm
% LocalWords:  Xmx sysLogfile RVM's aos irc recomp vmClasses cpuAffinity
