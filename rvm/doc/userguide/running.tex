This section describes how to run a Jikes\TMweb{}{} RVM  image built
from the previous section. 

%%%
% This section uses the EBNF commands defined in userguide.tex
%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Running \jrvm}

\cindex[jikes command]{\texttt{jikes} command}%
\cindex[rvm script]{\texttt{rvm} script}%
Jikes\TMweb{} RVM executes Java virtual machine byte code instructions from {\tt .class} files.  
It does {\em not} compile 
Java\TMweb{} source code. Therefore, you must compile all Java source
files into byte code using your favorite Java compiler.
Our favorite Java compiler is the IBM\Rweb{} Jikes compiler. 

For example, to run class {\tt foo} with source code in file {\tt foo.java}:
\begin{verbatim}
% jikes foo.java
% rvm foo 
\end{verbatim}

The general syntax is
\begin{example}
\tt{}   rvm \MZeroOrMore{rvm options\ldots} class \MZeroOrMore{args\ldots}
\end{example}

\index{command-line options}%
You may choose from a myriad of options for the {\tt rvm} command-line.  
Options fall into two categories: {\em standard} and {\em
non-standard}.  Non-standard options are preceded by {\bf ``{\tt -X:}''}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Standard Command-Line Options}

We currently support a subset of the JDK 1.4 standard options.  Below
is a list of all options and their descriptions.  Unless otherwise noted each
option is supported in Jikes RVM.\@
\begin{description}
\item[{\tt \Mlbr{} -cp \Mor{} -classpath \Mrbr{} \Mmeta{directories and
zip/jar files separated by \Mlitch{:}}}]
set search path for application classes and resources

\item[{\tt -D\Mmeta{name}=\Mmeta{value}}] set a system property

\item[{\tt -verbose:\Mlsq{} class \Mor{} gc \Mor{} jni \Mrsq}]
enable verbose output

\item[{\tt -version}] print current VM version and terminate the run

\item[{\tt -showversion}] print current VM version and continue running

\item[{\tt -fullversion}] like ``{\tt -version}'', but with more information

\item[{\tt -?} or {\tt -help}] print help message

\item[{\tt -X}] print help on non-standard options

\item[{\tt -jar}] execute a jar file 

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Non-standard Command-Line Options}

The non-standard options are

\begin{description}
\item[{\tt -X}]
immediately print usage information on nonstandard options

\item[{\tt -X:verbose}]
during run, print out additional information for GC and hardware trap handling

\item[{\tt -X:verboseBoot=\Mmeta{number}}]
print out additional information while VM is booting, using verbosity
level \Mmeta{number}.

\item[{\tt -Xms\Mmeta{number}\Mlsq{}\Mmeta{unit}\Mrsq{}}]
set the initial heap size to \Mmeta{number}\Mmeta{unit} bytes.
 \link{The section on MMTk Command-Line Options \texonly{(see
     appendix~\Ref, page~\Pageref{})} explains the syntax for
     expressing memory sizes}{section:mmtkoptions}%
.

\item[{\tt -Xmx\Mmeta{number}\Mlsq{}\Mmeta{unit}\Mrsq{}}]
set the maximum heap size to \Mmeta{number}\Mmeta{unit} bytes.


\item[{\tt -X:sysLogfile=\Mmeta{filename}}]
redirects messages that would go to standard error to \Mmeta{filename} instead.

\item[{\tt -X:i=\Mmeta{filename}}]
read Jikes RVM's \emph{boot image} from \Mmeta{filename}

\item[{\tt -X:vm\Mlsq{}:help\Mrsq{}}]
immediately print options supported by the core virtual machine

\item[{\tt -X:vm:\Mmeta{option}}]
pass \Mmeta{option} to the core virtual machine

\item[{\tt -X:gc\Mlsq{}:help\Mrsq}]
print options supported by the memory management system

\item[{\tt -X:gc:\Mmeta{option}}]
pass \Mmeta{option} to the memory management system

\item[{\tt -X:aos\Mlsq{}:help\Mrsq{}}]
print options supported by adaptive optimization system when in an
adaptive configuration

\item[{\tt -X:aos:\Mmeta{option}}]
pass \Mmeta{option} to the adaptive optimization system when in an adaptive configuration

\item[{\tt -X:irc\Mlsq{}:help\Mrsq{}}]
print options supported by the initial runtime compiler

\item[{\tt -X:irc:\Mmeta{option}}]
pass \Mmeta{option} to the initial runtime compiler

\item[{\tt -X:recomp\Mlsq{}:help\Mrsq{}}]
print options supported by the compilers used for recompilation

\item[{\tt -X:recomp:\Mmeta{option}}]
pass \Mmeta{option} to the compilers used for recompilation

\item[{\tt -X:base\Mlsq{}:help\Mrsq{}}]
print the options supported by the baseline compiler

\item[{\tt -X:base:\Mmeta{option}}]
pass \Mmeta{option} to the baseline compiler

\item[{\tt -X:quick\Mlsq{}:help\Mrsq{}}]
print the options supported by the quick compiler

\item[{\tt -X:quick:\Mmeta{option}}]
pass \Mmeta{option} to the quick compiler

\item[{\tt -X:opt\Mlsq{}:help\Mrsq{}}]
print the options supported by the optimizing compiler

\item[{\tt -X:opt:\Mmeta{option}}]
pass \Mmeta{option} to the optimizing compiler

\item[{\tt -X:prof:\Mmeta{option}}]
pass \Mmeta{option} to the profiling subsystem

\item[{\tt -X:vmClasses=\Mmeta{path}}]
load classes from \Mmeta{path}.  \Mmeta{path} is the file name or
file names of one or more {\tt .jar} files.  File names in
\Mmeta{path} are separated by colons (\Mlitch{:}).

\item[{\tt -X:cpuAffinity=\Mmeta{int}}]
\Mmeta{int} is the number of the physical CPU to which the first virtual processor will be bound.

\item[{\tt -X:processors=\Mlsq{} \Mmeta{int} \Mor{} \Mlitch{all} \Mrsq{}}]
number of processors to use on a multiprocessor

\end{description}

\link{Later in this user's guide \texonly{(see appendix~\Ref, page~\Pageref{})} there
are more details on command-line options}{appendix:nonadaptive:cmdline}, including the list of options supported by the baseline
compiler, optimizing compiler, and adaptive optimization system. 

\subsection{Regression Tests}
\label{sec:regression}
\input{regression}

% LocalWords:  args JDK cp gc jni VM showversion fullversion verboseBoot Xms vm
% LocalWords:  Xmx sysLogfile RVM's aos irc recomp vmClasses cpuAffinity
