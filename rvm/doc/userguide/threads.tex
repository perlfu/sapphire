This section provides some explanation of how Java threads are
scheduled and synchronized by the RVM.

\index{threads}
\index{scheduling}
\index{locking}

All Java threads (application threads, garbage collector threads, {\em
etc.})  derive from \VMThreadURL.  These threads are multiplexed by
one or more virtual processors (see \VMProcessorURL).  Normally, the
number of RVM virtual processors to use is a command line argument
(e.g. {\tt -X:processors=4}) Generally, there should be one RVM
virtual processor for each CPU on an SMP.  Additional virtual
processors may be created to handle threads executing non Java code
through the Java JNI.  Multiple virtual processors require a working
pThread library, each virtual processor being bound to a pThread.  It
is possible to build a system that only uses one virtual processor by
setting the preprocessor directive {\tt
JVM\_WITH\_SINGLE\_VIRTUAL\_PROCESSOR} to 1.  This may give a minor
performance benefit on uniprocessors.

(Bugs with our Linux pThread library currently prohibit multiple
virtual processor builds on Linux.  Code to support such builds is in
place, but has not been tested.)

Threads that are not executing are either placed on thead queues
(deriving from \VMAbstractThreadQueueURL) or are proxied (see below).
Thread queues are either global or (virtual) processor local.  The
latter do not require synchronized access but global queues do.
Unfortunately, we did not see how to use Java monitors to provide
this synchronization.  (In part, because it is needed to implement
monitors, see below.)  Instead this low-level synchronization is
provided by {\VMProcessorLockURL}s.

Transferring execution from one thread (A) to another (B) is a complex
operation negotiated by the {\tt yield} and {\tt morph} methods of
\VMThreadURL and the {\tt dispatch} method of \VMProcessorURL.  {\tt
yield} places A on an indicated queue (releasing the lock on the
queue, if it is global).  {\tt morph} uses \VMMagicURL to capture the
state of the running thread and transfers control to {\tt dispatch}.
At this point, the virtual processor is executing in {\em phantom
mode}, it is using A's stack, but not in a way that will be visible to
A when it next gets executed.  {\tt dispatch} removes B from a queue
of executable threads and, using more \VMMagicURL, transfers control
to B's stack.  (To B, it looks as if {\em its} call to {\tt dispatch}
has just returned.)  To prevent a different processor from dispatching
A while it is still executing in phantom mode, {\tt yield} sets the
{\tt beingDispatched} field of A, which is only reset by the magic
that transfers control to B.

Currently, RVM has no priority mechanism, that is, all threads run
at the same priority.

Similarly, it has only the most rudimentary load balancing mechanism.
Each virtual processor has a (local) idle queue.  Normally, the
processor's \VMIdleThreadURL inhabits this queue.  When no other
thread is executable, this thread is executed.  This thread requests
work by setting the static {\tt idleProcessor} field to its virtual
processor.  (When {\tt dispatch} is looking for a runable thread it
checks that this field is null.  If not, and it has an spare runnable
thread, it places the spare thread on the idle processor's transfer
queue.)  The idle thread then spins for a short period of time waiting
for work to materialize.  If it does, the idle thread yields back to
the idle queue.  Otherwise, it give the remainder of its virtual
processor's time slice back to the operating system.

More sophisticated priority and load-balancing mechanisms are in
order.

RVM uses a light-weight locking scheme to implement Java monitors (see
\VMLockURL).  Twenty bits of the status word of the object header are
used for locking.  If the top bit is set, the bottom nineteen are an
index into an array of heavy-weight locks.  Otherwise, if the object
is locked, these bits contain the id of the thread that holds the lock
and a count of how many times it is held.  If a thread try's to lock
an object locked with a light-weight lock by another thread, it can
spin, yeald, or inflate the lock.  Spinning is probably a bad idea.
The number of times to yield before inflating is a matter open for
investigation (along with a number of locking issues, see \VMLockURL).
Heavy-weight locks contain an {\tt enteringQueue} for threads trying
to acquire the lock.

A similar mechanism is used to implement Java's wait/notification
mechanism.  Heavy-weight locks contain a {\tt waitingQueue} for
threads blocked at a Java {\tt wait}.  When a {\tt notify} is
received, a thread is taken from this queue and transferred to a ready
queue.
