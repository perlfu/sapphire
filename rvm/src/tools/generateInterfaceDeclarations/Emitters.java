/* -*-coding: iso-8859-1 -*-
 *
 * Copyright © IBM Corp 2001, 2002, 2003, 2004
 *
 * $Id$
 */
//$Id$

// package com.ibm.JikesRVM.GenerateInterfaceDeclarations;

import com.ibm.JikesRVM.classloader.VM_Field;
import com.ibm.JikesRVM.classloader.VM_Class;
import com.ibm.JikesRVM.classloader.VM_Atom;
import com.ibm.JikesRVM.classloader.VM_TypeReference;
import java.util.Arrays;
import java.lang.reflect.*;
import com.ibm.JikesRVM.VM_Address;

/**
 * Actually emit the C declarations required to access VM data structures from
 * C and C++.
 *
 * @author Derek Lieber
 * @modified Steven Augart 2/2004, 3/2004: self-hosting
 */


class Emitters extends Shared {

  private Class vmClass;

  public Emitters(Class vmClass) {
    this.vmClass = vmClass;
  }

  public void emitStuff(int bootImageAddress) 
    throws Exception
  {
    p("/*------ MACHINE GENERATED by ");
    p("GenerateInterfaceDeclarations.java: DO NOT EDIT");
    p("------*/\n\n");

    emitGNUClasspathVersion();

    pln("#if defined NEED_BOOT_RECORD_DECLARATIONS || defined NEED_VIRTUAL_MACHINE_DECLARATIONS");
    pln("#include <inttypes.h>");
    Field build32 = vmClass.getField("BuildFor32Addr");
    if (build32.getBoolean(null)) {
      pln("#define VM_Address uint32_t");
      pln("#define VM_Word uint32_t");
      pln("#define JavaObject_t uint32_t");
    } else {
      pln("#define VM_Address uint64_t");
      pln("#define VM_Word uint64_t");
      pln("#define JavaObject_t uint64_t");
    }
    pln("#endif /* NEED_BOOT_RECORD_DECLARATIONS || NEED_VIRTUAL_MACHINE_DECLARATIONS */");
    pln();

    pln("#ifdef NEED_BOOT_RECORD_DECLARATIONS");
    emitBootRecordDeclarations();
    pln("#endif /* NEED_BOOT_RECORD_DECLARATIONS */");
    pln();

    pln("#ifdef NEED_BOOT_RECORD_INITIALIZATION");
    emitBootRecordInitialization();
    pln("#endif /* NEED_BOOT_RECORD_INITIALIZATION */");
    pln();

    //    emitGNUClasspathVersion();

    pln("#ifdef NEED_VIRTUAL_MACHINE_DECLARATIONS");
    emitVirtualMachineDeclarations(bootImageAddress);
    pln("#endif /* NEED_VIRTUAL_MACHINE_DECLARATIONS */");
    pln();

    pln("#ifdef NEED_ASSEMBLER_DECLARATIONS");
    emitAssemblerDeclarations();
    pln("#endif /* NEED_ASSEMBLER_DECLARATIONS */");
  }

  /** Get the version of the GNU Classpath library from
        gnu.classpath.Configuration */
  public void emitGNUClasspathVersion() 
    throws Exception
  {
    /* Add some cross-checking here. */
    Class localClasspathConfig = Class.forName("gnu.classpath.Configuration");

    if (verbose > 0) {
      epln("localClasspathConfig = " + localClasspathConfig);
      epln("    used class loader: " + localClasspathConfig.getClassLoader());
    }      
    

    pln("#ifdef NEED_GNU_CLASSPATH_VERSION");
    /*  We have to use reflection here.

        The case to consider: 

        A VM (not necessarily Jikes RVM) that uses GNU Classpath version X,
        but where we are building Jikes RVM with GNU Classpath version Y
    */
    Class classpathConfig = getClassNamed("gnu.classpath.Configuration");
    if (verbose > 0) {
      epln("classpathConfig = " + classpathConfig);
      epln("  used class loader: " + classpathConfig.getClassLoader());
    }      
    if (Shared.altCL != ClassLoader.getSystemClassLoader()
        && classpathConfig == localClasspathConfig) {
      epln("This should never happen: classpathConfig = localClasspathConfig");
      
    }
    
    Field versionField = classpathConfig.getField("CLASSPATH_VERSION");
    String ver = (String) versionField.get("CLASSPATH_VERSION");
    
    p("static const char*classpath_version              = \"" + ver + "\";\n");
    pln("#endif /* NEED_GNU_CLASSPATH_VERSION */");
    pln();

  }

  private static class SortableField implements Comparable {
    final VM_Field f;
    final int offset;
    SortableField (VM_Field ff) { f = ff; offset = f.getOffset(); }
    public int compareTo (Object y) {
      if (y instanceof SortableField) {
        int offset2 = ((SortableField) y).offset;
        if (offset > offset2) return 1;
        if (offset < offset2) return -1;
        return 0;
      }
      return 1;
    }
  }

  void emitCDeclarationsForJavaType (String Cname, VM_Class cls) {
    // How many instance fields are there?
    //
    VM_Field[] allFields = cls.getDeclaredFields();
    int fieldCount = 0;
    for (int i=0; i<allFields.length; i++)
      if (!allFields[i].isStatic())
        fieldCount++;

    // Sort them in ascending offset order
    //
    SortableField [] fields = new SortableField[fieldCount];
    for (int i=0, j=0; i<allFields.length; i++)
      if (!allFields[i].isStatic())
        fields[j++] = new SortableField(allFields[i]);
    Arrays.sort(fields);

    // Set up cursor - scalars will waste 4 bytes on 64-bit arch
    //
    //    boolean needsAlign = VM.BuildFor64Addr;
    boolean needsAlign = vmBool("BuildFor64Addr");
    int addrSize = vmBool("BuildFor32Addr") ? 4 : 8;
    int current = fields[0].offset;
    if (needsAlign && ((current & 7) != 0))
        current -= 4;
    if (current >= 0) 
        pln("Are scalars no longer backwards?  If so, check this code.");

    // Emit field declarations
    //
    p("struct " + Cname + " {\n");
    for (int i = 0; i<fields.length; i++) {
      VM_Field field = fields[i].f;
      VM_TypeReference t = field.getType();
      int offset = field.getOffset();
      String name = field.getName().toString();
      // Align by blowing 4 bytes if needed
      if (needsAlign && current + 4 == offset) {
          pln("  uint32_t    padding" + i + ";");
          current += 4;
      }
      if (current != offset) 
        pln("current = " + current + " and offset = " + offset + " are neither identical not differ by 4");
      if (t.isIntType()) {
        current += 4;
        p("   uint32_t " + name + ";\n");
      } else if (t.isLongType()) {
        current += 8;
        p("   uint64_t " + name + ";\n");
      } else if (t.isWordType()) {
        p("   VM_Address " + name + ";\n");
        current += addrSize;
      } else if (t.isArrayType() && t.getArrayElementType().isWordType()) {
        p("   VM_Address * " + name + ";\n");
        current += addrSize;
      } else if (t.isArrayType() && t.getArrayElementType().isIntType()) {
        p("   unsigned int * " + name + ";\n");
        current += addrSize;
      } else if (t.isReferenceType()) {
        p("   JavaObject_t " + name + ";\n");
        current += addrSize;
      } else {
        ep("Unexpected field " + name.toString() + " with type " + t + "\n");
        throw new RuntimeException("unexpected field type");
      }
    }

    p("};\n");
  }


  void emitBootRecordDeclarations () {
    VM_Atom className = VM_Atom.findOrCreateAsciiAtom("com/ibm/JikesRVM/VM_BootRecord");
    VM_Atom classDescriptor = className.descriptorFromClassName();
    VM_Class bootRecord = null;
    try {
      bootRecord = VM_TypeReference.findOrCreate(altCL, classDescriptor).resolve().asClass();
    } catch (NoClassDefFoundError e) {
      epln("Failed to load VM_BootRecord!");
      System.exit(-1);
    }
    emitCDeclarationsForJavaType("VM_BootRecord", bootRecord);
  }




  // Emit declarations for VM_BootRecord object.
  //
  void emitBootRecordInitialization() {
    VM_Atom className = VM_Atom.findOrCreateAsciiAtom("com/ibm/JikesRVM/VM_BootRecord");
    VM_Atom classDescriptor = className.descriptorFromClassName();
    VM_Class bootRecord = null;
    try {
      bootRecord = VM_TypeReference.findOrCreate(altCL, classDescriptor).resolve().asClass();
    } catch (NoClassDefFoundError e) {
      reportTrouble("Failed to load VM_BootRecord", e);
      System.exit(-1);          // unreached
    }
    VM_Field[] fields = bootRecord.getDeclaredFields();

    // emit function declarations
    //
    for (int i = fields.length; --i >= 0;) {
      VM_Field field = fields[i];
      if (field.isStatic())
        continue;
      String fieldName = field.getName().toString();
      int suffixIndex = fieldName.indexOf("IP");
      if (suffixIndex > 0) {
        // java field "xxxIP" corresponds to C function "xxx"
        String functionName = fieldName.substring(0, suffixIndex);
        // e. g.,
        // extern "C" void sysFOOf();
        p("extern \"C\" int " + functionName + "();\n");
      }
    }

    // emit field initializers
    //
    p("extern \"C\" void setLinkage(VM_BootRecord* br){\n");
    for (int i = fields.length; --i >= 0;) {
      VM_Field field = fields[i];
      if (field.isStatic())
        continue;

      String fieldName = field.getName().toString();
      int suffixIndex = fieldName.indexOf("IP");
      if (suffixIndex > 0) {
        // java field "xxxIP" corresponds to C function "xxx"
        String functionName = fieldName.substring(0, suffixIndex);
        if (vmBool("BuildForAix") 
            || (vmBool("BuildForLinux") && vmBool("BuildFor64Addr"))) {
          // e. g.,
          // sysFOOIP = ((AixLinkageLayout *)&sysFOO)->ip;
          p("  br->" + fieldName + " = ((AixLinkageLayout *)&" + functionName + ")->ip;\n"); 
        } else {
          // e. g.,
          //sysFOOIP = (int) sysFOO; 
          p("  br->" + fieldName + " = (int) " + functionName + ";\n");
        }
      }

      suffixIndex = fieldName.indexOf("TOC");
      if (suffixIndex > 0) {
        // java field "xxxTOC" corresponds to C function "xxx"
        String functionName = fieldName.substring(0, suffixIndex);
        if (vmBool("BuildForAix") 
            || (vmBool("BuildForLinux") && vmBool("BuildFor64Addr"))) {
          // e. g.,
          // sysTOC = ((AixLinkageLayout *)&sys)->toc;
          p("  br->" + fieldName + " = ((AixLinkageLayout *)&" + functionName + ")->toc;\n"); 
        } else {
          p("  br->" + fieldName + " = 0;\n");
        }
      }
    }

    p("}\n");
  }


  // Emit virtual machine class interface information.
  //
  void emitVirtualMachineDeclarations (int bootImageAddress) 
    throws NoSuchFieldException, IllegalAccessException, InvocationTargetException, NoSuchMethodException
  {
    // load address for the boot image
    //
    p("static const int bootImageAddress                        = 0x"
        + Integer.toHexString(bootImageAddress) + ";\n");

    // values in VM_Constants, from VM_Configuration
    //
    Class vc = getClassNamed("com.ibm.JikesRVM.VM_Constants");
    IntEmitter i = new IntEmitter(vc, "VM_Constants_");
    // String[] fieldNames;

    //-#if RVM_FOR_POWERPC
    // Trust the preprocessor: 
    //    if (VM.BuildForPowerPC) {
        //Try 2:
        //      i.emit("JTOC_POINTER");
        // Try 1:
      //      p("static const int VM_Constants_JTOC_POINTER               = "
      //          + VM_Constants.JTOC_POINTER + ";\n");

    if (vmBool("BuildForPowerPC")) {
      i.emit(new String[] {
        "JTOC_POINTER", "FRAME_POINTER", "PROCESSOR_REGISTER",
        "FIRST_VOLATILE_GPR", "DIVIDE_BY_ZERO_MASK", "DIVIDE_BY_ZERO_TRAP",
        "MUST_IMPLEMENT_MASK", "MUST_IMPLEMENT_TRAP", "STORE_CHECK_MASK", 
        "STORE_CHECK_TRAP", "ARRAY_INDEX_MASK", "ARRAY_INDEX_TRAP", 
        "ARRAY_INDEX_REG_MASK", "ARRAY_INDEX_REG_SHIFT", 
        "CONSTANT_ARRAY_INDEX_MASK", "CONSTANT_ARRAY_INDEX_TRAP", 
        "CONSTANT_ARRAY_INDEX_INFO", "WRITE_BUFFER_OVERFLOW_MASK", 
        "WRITE_BUFFER_OVERFLOW_TRAP", "STACK_OVERFLOW_MASK",
        "STACK_OVERFLOW_HAVE_FRAME_TRAP", "STACK_OVERFLOW_TRAP", 
        "CHECKCAST_MASK", "CHECKCAST_TRAP", "REGENERATE_MASK", 
        "REGENERATE_TRAP", "NULLCHECK_MASK", "NULLCHECK_TRAP",
        "JNI_STACK_TRAP_MASK", "JNI_STACK_TRAP", 
        "STACKFRAME_NEXT_INSTRUCTION_OFFSET", "STACKFRAME_ALIGNMENT" 
      });
    }
    
    //    }
    //-#endif
    
    //-#if RVM_FOR_IA32
    if (vmBool("BuildForIA32")) {
      i.emit(new String[] {
        "EAX", "ECX", "EDX", "EBX", "ESP", "EBP", 
        "ESI", "EDI", "STACKFRAME_BODY_OFFSET", 
        "STACKFRAME_RETURN_ADDRESS_OFFSET", "RVM_TRAP_BASE" });
    }
    //-#endif
    //    i.emit(fieldNames);

    /* Fields shared among distributions. */
    i.emit(new String[] {
      "STACK_SIZE_GUARD", "INVISIBLE_METHOD_ID",
    });
    IntEmitter thinLockEmitter 
	= new IntEmitter(
	    getClassNamed("com.ibm.JikesRVM.VM_ThinLockConstants"),
	    "VM_ThinLockConstants_");
    thinLockEmitter.emit("TL_THREAD_ID_SHIFT");
    i.emit(new String[] { "STACKFRAME_HEADER_SIZE",
			  "STACKFRAME_METHOD_ID_OFFSET", 
			  "STACKFRAME_FRAME_POINTER_OFFSET" }
	);
    

    i.emitAddress("STACKFRAME_SENTINEL_FP");

    // values in VM_ObjectModel
    //
    pln("static const int VM_ObjectModel_ARRAY_LENGTH_OFFSET = " + 
        getObjectModelArrayLengthOffset() + ";");

    // values in VM_Scheduler
    //
    i = new IntEmitter(getClassNamed("com.ibm.JikesRVM.VM_Scheduler"),
                       "VM_Scheduler_");
    i.emit("PRIMORDIAL_PROCESSOR_ID");
    i.emit("PRIMORDIAL_THREAD_INDEX");
    pln();

    // values in VM_ThreadEventConstants
    //
    DoubleEmitter d 
      = new DoubleEmitter(
                 getClassNamed("com.ibm.JikesRVM.VM_ThreadEventConstants"),
                 "VM_ThreadEventConstants_");
    
    d.emit("WAIT_INFINITE");

    // values in VM_ThreadIOQueue
    //
    i = new IntEmitter(getClassNamed("com.ibm.JikesRVM.VM_ThreadIOQueue"),
                       "VM_ThreadIOQueue_");
    i.emit(new String[] {"READ_OFFSET", "WRITE_OFFSET", "EXCEPT_OFFSET" });
    
    pln();

    // values in VM_ThreadIOConstants
    //
    
    i = new IntEmitter(getClassNamed("com.ibm.JikesRVM.VM_ThreadIOConstants"),
                       "VM_ThreadIOConstants_");
    i.emit(new String[] {"FD_READY", "FD_READY_BIT", "FD_INVALID", "FD_INVALID_BIT", "FD_MASK"
    });

    pln();

    // values in VM_ThreadProcessWaitQueue
    //
    i = new IntEmitter(
	   getClassNamed("com.ibm.JikesRVM.VM_ThreadProcessWaitQueue"),
                         "VM_ThreadProcessWaitQueue_");
    i.emit("PROCESS_FINISHED");
//     p("static const int VM_ThreadProcessWaitQueue_PROCESS_FINISHED = " +
//         VM_ThreadProcessWaitQueue.PROCESS_FINISHED + ";\n");

    // values in VM_Runtime
    //
    i = new IntEmitter(
	   getClassNamed("com.ibm.JikesRVM.VM_Runtime"),
                         "VM_Runtime_");
    i.emit(new String[] {
	"TRAP_UNKNOWN", "TRAP_NULL_POINTER", "TRAP_ARRAY_BOUNDS", "TRAP_DIVIDE_BY_ZERO","TRAP_STACK_OVERFLOW", "TRAP_CHECKCAST", "TRAP_REGENERATE", "TRAP_JNI_STACK", "TRAP_MUST_IMPLEMENT", "TRAP_STORE_CHECK"
    });
    
    pln();

    // values in VM_FileSystem
    //
    i = new IntEmitter(getClassNamed("com.ibm.JikesRVM.VM_FileSystem"),
                       "VM_FileSystem_");

    i.emit(new String[] {
	"OPEN_READ", "OPEN_WRITE", "OPEN_MODIFY", "OPEN_APPEND", "SEEK_SET",
	"SEEK_CUR", "SEEK_END", "STAT_EXISTS", "STAT_IS_FILE", "STAT_IS_DIRECTORY", "STAT_IS_READABLE", "STAT_IS_WRITABLE", "STAT_LAST_MODIFIED", "STAT_LENGTH"
    });
    

    // fields in VM_Processor
    //
    Class entryPoints = getClassNamed("com.ibm.JikesRVM.VM_Entrypoints");
    OffsetEmitter o = new OffsetEmitter(entryPoints, "VM_Processor_");
    o.emit("threadSwitchRequested");
                          
    o.emit("activeThreadStackLimit");
    o.emit("pthreadID", "pthread_id");
    o.emit("epoch");
    o.emit("activeThread");
    o.emit("threadId");

    //-#if RVM_FOR_IA32
    if (vmBool("BuildForIA32")) {
      o.emit(new String[] {"framePointer", "jtoc", "arrayIndexTrapParam"});
    }
    //-#endif

    // Fields in VM_Thread
    //
    o = new OffsetEmitter(entryPoints, "VM_Thread_");
    o.emit("threadStack", "stack");
    o.emit("stackLimit");
    o.emit("threadHardwareExceptionRegisters", "hardwareExceptionRegisters");
    o.emit("jniEnv");

    // fields in VM_Registers
    //
    o = new OffsetEmitter(entryPoints, "VM_Registers_");
    o.emit("registersGPRs", "gprs");
    o.emit("registersFPRs", "fprs");
    o.emit("registersIP", "ip");
    //-#if RVM_FOR_IA32
    if (vmBool("BuildForIA32")) {
      o.emit("registersFP", "fp");
    }
    //-#endif
    //-#if RVM_FOR_POWERPC
    if (vmBool("BuildForPowerPC")) {
      o.emit("registersLR", "lr");
    }
    //-#endif

    o.emit("registersInUse", "inuse");

    // fields in VM_JNIEnvironment
    o = new OffsetEmitter(entryPoints, "VM_JNIEnvironment_");
    o.emit("JNIExternalFunctions", "JNIExternalFunctions");

    // fields in java.net.InetAddress
    //
    o = new OffsetEmitter(entryPoints, "java_net_");
    o.emit("inetAddressAddress", "InetAddress_address");
    o.emit("inetAddressFamily", "InetAddress_family");

    // fields in java.net.SocketImpl
    //
    o.emit("socketImplAddress", "SocketImpl_address");
    o.emit("socketImplPort", "SocketImpl_port");

    // fields in com.ibm.JikesRVM.memoryManagers.JMTk.BasePlan
    OffsetReader reader = new OffsetReader(entryPoints);
    int offset = reader.get("gcStatusField");
    p("static const int com_ibm_JikesRVM_memoryManagers_JMTk_BasePlan_gcStatusOffset = "
                     + offset + ";\n");
  }


  // Emit assembler constants.
  //
  void emitAssemblerDeclarations () {

    FieldReader bcReader
      = new FieldReader(getClassNamed(
                                "com.ibm.JikesRVM.VM_BaselineConstants"));
    
    FieldReader constReader
      = new FieldReader(getClassNamed(
                                "com.ibm.JikesRVM.VM_Constants"));
    
                        
    //-#if RVM_FOR_POWERPC
    if (vmBool("BuildForPowerPC")) {
      //-#if RVM_FOR_OSX
      if (vmBool("BuildForOSX")) {
        pln("#define FP r"   + bcReader.asString("FP"));
        pln("#define JTOC r" + bcReader.asString("JTOC"));
        pln("#define PROCESSOR_REGISTER r"    
            + bcReader.asString("PROCESSOR_REGISTER"));
        pln("#define S0 r"   + bcReader.asString("S0"));
        pln("#define T0 r"   + bcReader.asString("T0"));
        pln("#define T1 r"   + bcReader.asString("T1"));
        pln("#define T2 r"   + bcReader.asString("T2"));
        pln("#define T3 r"   + bcReader.asString("T3"));
        pln("#define STACKFRAME_NEXT_INSTRUCTION_OFFSET " 
            + constReader("STACKFRAME_NEXT_INSTRUCTION_OFFSET"));
      } else {
        //-#else
        //        if (vmBool("BuildForPowerPC")) {
          pln(".set FP,"   + bcReader.asString("FP"));
          pln(".set JTOC," + bcReader.asString("JTOC"));
          pln(".set PROCESSOR_REGISTER,"    
              + bcReader.asString("PROCESSOR_REGISTER"));
          pln(".set S0,"   + bcReader.asString("S0"));
          pln(".set T0,"   + bcReader.asString("T0"));
          pln(".set T1,"   + bcReader.asString("T1"));
          pln(".set T2,"   + bcReader.asString("T2"));
          pln(".set T3,"   + bcReader.asString("T3"));
          pln(".set STACKFRAME_NEXT_INSTRUCTION_OFFSET," 
              + constReader.asString("STACKFRAME_NEXT_INSTRUCTION_OFFSET"));
          //        }
        if (! vmBool("BuildForAix")) 
          pln(".set T4,"   + (constReader.asInt("T3") + 1));
      }
    }
    //-#endif
    //-#endif

    //-#if RVM_FOR_IA32
    if (vmBool("BuildForIA32")) {
      FieldReader regReader
        = new FieldReader(getClassNamed(
                                "com.ibm.JikesRVM.VM_RegisterConstants"));
      String[]  gpr_names = regReader.asStringArray("GPR_NAMES");

      p("#define JTOC %" + gpr_names[bcReader.asInt("JTOC")] + ";\n");
      p("#define PR %" + gpr_names[bcReader.asInt("ESI")] + ";\n");
    }
    //-#endif
  }


  /** Return the value of the static field named @param fieldName in the
   * alternate VM class. */ 
  boolean vmBool(String fieldName) 
    //    throws IllegalAccessException
  {
    Field f = null;
    try {
      f = vmClass.getField(fieldName);
    } catch (NoSuchFieldException e) {
      reportTrouble("Unable to find a (boolean) field named " + fieldName
                    + "in the VM class", e);
      // Unreached
    }
    try {
      return f.getBoolean(null);
    } catch (IllegalAccessException e) {
      reportTrouble("Protection error while reading the boolean field named "
                    + fieldName + "in the VM class", e);
    }
    return false;             // unreached
  }

  int getObjectModelArrayLengthOffset() 
    throws IllegalAccessException, InvocationTargetException 
  {
    final Class omClass = getClassNamed("com.ibm.JikesRVM.VM_ObjectModel");
    Method getOff = null;
    try {
      getOff = omClass.getMethod("getArrayLengthOffset", new Class[0]);
    } catch (NoSuchMethodException e) {
      reportTrouble(omClass.toString() 
                    + " doesn't have a method named getArrayLengthOffset", e);
    }
    return ((Integer) getOff.invoke(null, new Object[0])).intValue();
  }
}
