
(C) Copyright IBM Corp. 2001

$Id$

   This README file cover the following topics:


Getting started	- easiest way to start debugging

About jdp 	- what, why, how

jdp environment - files needed, setting, convention assumed by jdp

jdp commands 	- commands, macro (text from typing "help" in jdp)

Debugging tips 	- useful debugging tricks

You may find the information on jdp presented in the userguide is more
update and easier to work with.

@author: Ton Ngo

-------------------------------------------------------------------------


Getting started
---------------

   You can use jdp in two modes: debugging boot image only and general
debugging.  

   1. Use the boot image only mode if you are only debugging code
in the boot image since this is faster and the debugger is more stable
(even when the VM becomes corrupted):

	jdp -jdpbootonly myProgram myArguments

   In this mode, methods of classes outside the boot image appears
as "unknown method" and you cannot set breakpoint for these methods.


   2. Use the general mode if you are debugging codes in classes that are 
dynamically loaded:

	jdp myProgram myArguments

   This mode is slower because there are two levels of interpretation
and the debugger can get lost if the dictionaries in the VM become 
corrupted.


Other useful options:

   You can use jdp to start the VM for debugging as above, or if the
VM is already running and appears to be hung, you can attach jdp to
this VM by:

	jdp -jdpattach<processID>

   The process ID is obtained from the "ps" command.  
   The option "-jdpbootonly" can be used in conjunction with "-jdpattach"

   If there is an error in the RVM initialization, you can start debugging
at a point where the boot image has been loaded but the RVM has not begun
executing yet. Specify the option:

        jdp -jdpviewboot myProgram myArguments

   Note that if the option "-jdpbootonly" is used, the option
"-jdpviewboot" is also included by default because jdp would be unable
to find the dynamically loaded user's main method.



-------------------------------------------------------------------------


About jdp
---------

  jdp, Jikes RVM Debugger Primitive, is a debugger developed to support the
Jikes RVM effort.  Because no existing debugger satisfactorily meets the
need of our VM, jdp was written essentially from scratch, hence the
name primitive.  jdp uses an interesting technique called Remote
Reflection (see the related paper on the Jikes RVM web page).  This
allows jdp to run out-of-process, yet it uses reflection extensively to
access the internal data structures as if it resides inside the VM.

   jdp is written in Java and JNI with native code in C.  jdp uses the
AIX ptrace interface and the standard Unix process support (fork,
wait, ...).  When porting to another platform, this native portion
(called from Platform.java) will have to be rewritten.  Since jdp and
the VM being debugged are two separate processes, an interpreter is
used to connect jdp with the VM: Remote Reflection maps the access
bytecodes in the reflection methods to obtain the internal values in
the VM.
  
  jdp is not intended to be a general purpose debugger; it is driven
by the needs of the VM group and new command can be added easily.


-------------------------------------------------------------------------


jdp environment
---------------

   This section describes the files and settings that the debugger
needs.  The jdp command is a ksh script that does some preliminary
argument parsing and fills in default arguments before invoking the
debugger in the appropriate mode.

The debugger requires the following files:

1. The VM boot image:
   This file is typically $RVM_BUILD/RVM.image but it could have other
   names with the .image extension.  You can specify a different boot image
   name.
   jdp argument:	-i bootImageName
   Default value:  	$RVM_BUILD/RVM.image

2. The symbol map:
   This file is a symbol map of the boot image.  It contains a listing of the JTOC
   and the compiled methods.  It is generated when the build configuration 
   in $RVM_ROOT/rvm/bin/jconfigure contains the flag (true by default):
	export GENERATE_MAP=1
   jdp uses offset values from this file to find all symbols in the boot image.
   In the dynamic mode, the interpreter also uses this file to find the base 
   offset for the dictionaries for the remote reflection feature.
   jdp argument:  	(none)
   Default value:	$RVM_BUILD/RVM.map

3. The list of classes in the boot image:
   jdp looks for this file $RVM_BUILD/RVM.primordials
   jdp argument:	-n classListName
   Default value: 	$RVM_BUILD/RVM.primordials

4. The program to load and run the VM boot image:
   This file is typically $RVM_BUILD/JikesRVM
   Normally you don't have to be concerned about this file since it rarely
   changes.
   jdp argument:	-r booterName
   Default value: 	$RVM_BUILD/JikesRVM



Initial breakpoint:  

   This is where jdp will stop first.  By default, jdp stops after the 
   first 4 instructions in the assembler procedure .bootThread in:
	$RVM_ROOT/rvm/src/tools/bootImageRunner/bootThread.c
   This is after the VM boot image has been loaded into memory and
   the 4 registers jtoc, proc, thread index and FP have been initialized.
   At this point, only one thread is running and the stack frame has only 
   one entry pointing to the booting C code.



Finally, jdp assumes the following conventions in navigating within the 
boot image (they arise from the base line compiler):

1. The method ID is saved a the end of the instruction block for each
   method

2. The end of the prolog of the instruction block is marked by the pattern:
          4ffffb82      
   which is the instruction:
	 cror   0x1f,0x1f,0x1f



-------------------------------------------------------------------------


jdp commands
------------

step          step current thread by instruction, into method
stepbr        step current thread by instruction, over method
stepline      step current thread by java source line, into method 
steplineover  step current thread by java source line, over method 
creturn       continue to last caller 
cont          continue all threads
kill          terminate program 
run           start new program 
break         list/set breakpoint 
clearbreak    clear breakpoints 

thread        set or turn off thread context
where         print short stack trace 
whereframe    print full stack trace 
stack         display formatted stack 
mem           display memory
memraw        display actual memory, jdp breakpoints visible
reg           display registers 
printclass    print the class statics or the type of an object address
print         print local variables or cast an address as an object
listi         list machine instruction
listt         list threads

quit          exit debugger
x2d	      convert number from hex to decimal
d2x           convert number from decimal to hex
preference    set user preference
verbose       toggle verbose mode
(macro name)  load and execute this macro (a text file with suffix .jdp)
(enter)       repeat last command

To get more information on a specific command (including what arguments it
processes), type: 
        help thiscommand



JDP Macro
---------

-A maco file has the ".jdp" suffix and contains normal jdp commands
-When you type "mymacro" at the command line, jdp will look for "mymacro.jdp" 
 in the normal class path and execute each line in the macro file as if 
 they are entered at the command line.
-On entry to jdp, if the file "startup.jdp" exists in the current directory, 
 it will be loaded and executed automatically.

  This should be convenient for:
-Short cut to repeat a series of commands to get a debugging point
-Regression testing:  redirect the output and compare with previous 
 results.  This is specifically intended for regression testing of jdp 
 itself but  may be useful for other tests as well, especially if the test 
 needs to inspect specific runtime values in registers, memory.


-------------------------------------------------------------------------


Debugging tips
--------------

o Compiling with local variables:
  The default boot image is built without the local variable tables; 
  therefore the "p" command would always display no variable in scope.
  The local variable tables are only supported with the baseline compiler.
  To get local variables:
	jmake bootImageWithLocal
  or set this flag to true in your local shadow:
	VM_Properties.LoadLocalVariableTables
  prior to building with jbuild. Be sure to run jbuild -clean if you have
  a previous build.


o Setting breakpoint:
  Sometimes a breakpoint cannot be set.  In the boot image only mode, jdp
  cannot find code outside the boot image.  In the general mode, jdp cannot
  find codes for classes that has not been loaded and compiled, simply
  because they don't exist in the dictionaries yet.  To get around these
  situations, the boot image contains a dummy method which jdp can always
  find:
	VM.debugBreakpoint
  You can insert a call to this method in the code where you want to stop.
  Then set a breakpoint on this method:
	b VM.debugBreakpoint
  In the general debugging mode, when jdp stops at this breakpoint, the 
  particular class has been loaded and you can then set breakpoints in any 
  method of this class.  However, if the build configuration enable lazy 
  compilation, then each method is compiled only then it is first invoked.


o Setting breakpoint in the prolog:
  Normally, jdp skips past the prolog code when it sets a breakpoint in
  a method.  To force jdp to set a breakpoint at the beginning of the
  method prolog, specify 0 as the line number:
	b myclass.mymethod:0


o Expanding expression:
  Symbolic expression for printing class static variable and stack local
  variable can be nested arbitrarily
	pc VM_Scheduler.threads[1].contextRegisters
	p 0:myLocalVar.field1.field2


o Casting an address as an object:
  If you have the address of an object and you know the class name,
  you can cast the address to print the object:
	p (className) xxxxxxxx
  This can also be used to print a concrete object of an abstract class.
  If the casting is not correct, you will see messages such as:
	CAUTION, address not accessible: 0x80620420


o Getting the class name of an object address:
  If you have the address of an object and want to know the type:
	pc xxxxxxxx


o Printing string:
  Strings are stored as VM_Atom in the VM.	
  To print the string as character, print the memory at the address of
  the field VM_Atom.val:

	jdp:0>p (VM_Atom) 30266638
	VM_Atom = 
	  VM_Atom @0x30266638
	    val = {100, 101, 98, 117, 103, 66, 114, 101, 97, 107, 112, 111, 105, 110, 116} @0x30269628
	    hash = 1544209252  @0x30266624

	jdp:0>m 30269628
	  0x30269628: 64 65 62 75    d e b u
	  0x3026962c: 67 42 72 65    g B r e
	  0x30269630: 61 6b 70 6f    a k p o
	  0x30269634: 69 6e 74 00    i n t .
	  0x30269638: 30 05 67 90    0 . g .

  Note that on Lintel, the character columns are in reverse order.

o Restarting your program:
  If your program runs to completion and you want to reexecute it,
  type "run" in jdp.  A new VM will be loaded and started in a new
  process.  The existing breakpoints will be saved and set again 
  when the boot image has been loaded.


o Display number in hex or decimal:
  Integers are normally displayed in decimal for variables and
  in hex for stack.  In many cases, variables contain addresses as 
  integer and stack entries contain small integer values.  In
  these cases, it may be more convenient to view the integer 
  in hex or decimal. 
  To change the display format for variables to hex:
	pref int x
  To change the display format for stack to decimal:
	pref stack d
  The format preference can be changed back by specifying x or d
  as appropriate.

o Display floating point value in the FP registers:
  These values are normally shown in floating point format.  They
  can be shown in hex format for comparison by:
	pref fpr x
  or:
	pref fpr f

o The stack is shown in hex format but it contains both address and 
  integer values. To display the stack with a decimal column, specify:
	pref stack d
  and to turn it off:
	pref stack x


o Debugger error messages:
  What these messages means:

  "CAUTION, address not accessible: 0x80620420"
	This means that jdp got an error when it reads an address
	in the VM space.  This may have occured because jdp is 
	dereferencing an object from a bad address, or the VM has
	become corrupted.  This message does not mean that jdp
	has crashed; you should be able to continue debugging.

  
  "jid>"
	In the general debugging mode (running with the interpreter),
  	this means that the interpreter has encountered an internal 
	error and has entered its own internal debugging mode.  At this 
	point, you can type "w" to see the interpreter stack and report 
	the error to Developer Works.



-------------------------------------------------------------------------

JDP arguments
-------------

jdp supports a number of options although only a few common ones are
visible.  jdp arguments are processed in two places: the script file
and in jdp.java.  This is necessary because some options are used to
start up jdp in different configurations.  In addition, some options
are tedious to be set manually and are set automatically by the script
file.

jdp accepts these options:

	-jdpattach	the process ID if attaching to a current process
	-jdpbootonly	whether we are running under the interpreter
	-jdpbreakpoint	breakpoint value
	-jdpbootrunner	the C program that will load the boot image
	-jdpviewboot	to stop in boot image
	-jdpserver	running in server mode for a GUI client
	-help
	-jdpmacro

The script file set the default value for these options automatically.
	

-------------------------------------------------------------------------
