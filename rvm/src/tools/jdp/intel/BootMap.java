/*
 * (C) Copyright IBM Corp. 2001
 */
//$Id$
/**
 * Abstract class for accessing the symbolic information in the JVM
 * The external implementation uses the .jbi.map file generated by BootImageWriter
 * The internal implementation uses the JVM descriptor directly
 *
 * @author Ton Ngo (4/22/98)
 */

import java.util.*;
import java.io.*;
 
abstract class BootMap implements jdpConstants  {
  /**
   * Pointer back to the process that owns this map
   */
  OsProcess owner;                  	  

  /**
   * A buffer holding the current java source
   */
  public SourceSnapshot sourceSnapshot;   

  /** 
   * Start and End address of the boot Image
   */     
  int bootStart = -1; 
  int bootEnd = -1;

  /**
   * Cached address of the field VM_BootRecord.endAddress
   * NOTE:  this only works if VM_BootRecord is not moved by GC
   * for now this is a valid assumption
   */
  int vmEndAddress = -1;      

  //**********************************************************************
  // The abstracts methods:  
  // the external implementation will rely on the boot map from BootImageWriter
  // the internal implementation will use the JVM runtime interface

  /**
   * Find the class.method name for an instruction address
   * @param methodID  an index into either the method dictionary table or the compiled method table
   * @param usingCompiledMethodID true if indexing the VM_ClassLoader.compiledMethodID
   *                              false if indexing the method dictionary table
   * @return a name of the form class.method for this code
   * @see BootMapExternal.findClassMethodName, BootMapInternal.findClassMethodName
   */
    public abstract String findClassMethodName(int methodID, boolean usingCompiledMethodID);

  /**
   * Find the class name for an instruction address
   * @param methodID  an index into either the method dictionary table or the compiled method table
   * @param usingCompiledMethodID true if indexing the VM_ClassLoader.compiledMethodID
   *                              false if indexing the method dictionary table
   * @return the class name for this code
   * @see BootMapExternal.findClassName, BootMapInternal.findClassName
   */
  public abstract String findClassName(int methodID, boolean usingCompiledMethodID);

  /**
   * Find the method name for an instruction address
   * @param methodID  an index into either the method dictionary table or the compiled method table
   * @param usingCompiledMethodID true if indexing the VM_ClassLoader.compiledMethodID
   *                              false if indexing the method dictionary table
   * @return the method name for this code
   * @see BootMapExternal.findMethodName, BootMapInternal.findMethodName
   */
  public abstract String findMethodName(int methodID, boolean usingCompiledMethodID); 

  /**
   * Find the signature of the method for an instruction address
   * @param methodID  an index into either the method dictionary table or the compiled method table
   * @param usingCompiledMethodID true if indexing the VM_ClassLoader.compiledMethodID
   *                              false if indexing the method dictionary table
   * @return the signature string for this code
   * @see BootMapExternal.findSignature, BootMapInternal.findSignature
   */
  public abstract String findSignature(int methodID, boolean usingCompiledMethodID);

  /**
   * Find the VM_Class for an instruction address
   * @param methodID  an index into either the method dictionary table or the compiled method table
   * @param usingCompiledMethodID true if indexing the VM_ClassLoader.compiledMethodID
   *                              false if indexing the method dictionary table
   * @return the runtime VM_Class 
   * @exception BmapNotFoundException if the name is not found
   * @see BootMapExternal.findVMClass, BootMapInternal.findVMClass
   */
  public abstract VM_Class findVMClass(int methodID, boolean usingCompiledMethodID);

  /**
   * Find the VM_Method for an instruction address
   * @param address an address pointing to arbitrary instruction
   * @return the runtime VM_Method containing this code
   * @exception BmapNotFoundException if the name is not found
   * @see BootMapExternal.findVMMethod, BootMapInternal.findVMMethod
   */
  public abstract VM_Method findVMMethod(int methodID, boolean usingCompiledMethodID);

  /**
   * Check to see if the address falls in the method prolog:
   * @param an address pointing to a machine instruction
   * @return  if in prolog, return the first address after the prolog
   * 	      if not in prolog, just return the given address
   * @see BootMapExternal.findAddressSkippingProlog, BootMapInternal.findAddressSkippingProlog
   */
  public abstract int findAddressSkippingProlog(int address);

  /**
   * Search for the closest match for names
   * <ul>
   * <li> for method name only, see if it is unique
   * <li> for not unique, see if any belongs to the current class
   * <li> for class.method name, see if method is overloaded
   * <li> for overloaded, try the signature
   * <li> for class.method:line, look up the line number also
   * <li> for class:line, find the method for this line to set the breakpoint
   * <li> for method:0, breakpoint at the beginning of the method prolog
   * </ul>
   * @param  method name with or without classname preceding, delimited by ".",
   *         and with or without line number following, delimited by ":"
   * @param  signature optional, can be null
   * @param  address of current instruction for lookup
   * @return  the corresponding address of the machine instructions 
   * @exception  BmapMultipleException if multiple matches exist
   * @exception	 BmapNotFoundException if no match
   * @see BootMapExternal.findAddress, BootMapInternal.findAddress
   */
  public abstract breakpoint findBreakpoint(String name, String sig, int address) 
    throws BmapMultipleException, BmapNotFoundException;

  public abstract int instructionAddress(int compiledMethodID);
  public abstract boolean isInstructionAddress(int startAddress, int address);
  public abstract int scanPrologSize(int instructionStartAddress);
  public abstract int getCompiledMethodIDForInstruction(int instructionStartAddress);

  /**
   * Find the byte offset of this address  from the start of instruction block 
   * for this method
   * @param address an address pointing to arbitrary machine instructions
   * @return the byte offset 
   * @exception BmapNotFoundException if the address does not have an entry in the 
   *            method map
   * @see BootMapExternal.instructionOffset, BootMapInternal.instructionOffset
   */
  public abstract int instructionOffset(int compiledMethodID, int address) throws BmapNotFoundException;

  public abstract void fillBootMethodTable();
  public abstract int getCompiledMethodID(int fp, int address);

  /****************************************************************************
   */

  /**
   * Set up the super class instance;  most of the work will be done by
   * the subclass constructor
   *
   * @param process    an OsProcess object for access to other objects 
   *                   owned by the process
   * @return
   * @see OsProcess, BootMapExternal, BootMapInternal
   */
  public BootMap(OsProcess process) {
    owner = process;         // save the reference to the owning process
    sourceSnapshot = new SourceSnapshot();      // for source access
  }


  /**
   * Find a class field by name
   * @param  className  the class name
   * @param  fieldName  the field name
   * @return the runtime VM_Field for this class variable
   * @exception BmapNotFoundException if the name is not found
   * @see VM_Field
   */
  public static VM_Field findVMField(String className, String fieldName)  
    throws BmapNotFoundException {
    VM_Class cls = findVMClassByName(className);
    VM_Field field[] = cls.getInstanceFields();

    // check dynamic fields of this class and superclass
    for (int i = 0, n = field.length; i < n; ++i) {
      if (field[i].getName().toString().equals(fieldName)) {
	return field[i];
      }
    }
    // check static fields of this class and its superclass
    VM_Class supercls = cls;
    while (supercls!=null) {
      field = supercls.getStaticFields();    
      for (int i = 0, n = field.length; i < n; ++i) {
	if (field[i].getName().toString().equals(fieldName)) {
	  return field[i];
	}
      }
      supercls = supercls.getSuperClass();
    }
    
    throw new BmapNotFoundException("Field " + fieldName + " not found in class " + className);
  }

  /**
   * Find the runtime VM_Class given the class name.
   * If invoked externally to the JVM, this method cannot handle dynamically loaded classes,
   * so if the class is not loaded with the boot image on startup, it will not be found
   * This problem does not occur if invoked internally to the JVM
   * @param className the class name as String
   * @return the VM_Class
   * @exception BmapNotFoundException if the name is not in the map
   * @see VM_Class
   */
  public static VM_Class findVMClassByName(String className) throws BmapNotFoundException {
    // System.out.println("findVMClassByName: looking up " + className);
    String classDescriptor;
    if (className.indexOf(';') == -1)
    {
      classDescriptor = "L" + className.replace('.','/') + ";";
    }
    else
    {
      classDescriptor = className;
    }
    VM_Type vmtype = dictionaryExtension.findType(classDescriptor);

    if (vmtype!=null)
      return vmtype.asClass();
    else {
      System.out.println("findVMClassByName: class not found, " + className);
      throw new BmapNotFoundException("class " + className + " is not in the boot image");
    }
  }

  /**
   * finds the VM_Array descriptor for the given array type
   * @param typeName the relevant type name
   * @return the corresponding VM_Array object
   * @exception BmapNotFoundException if the array type is not found
   */
  public static VM_Array findVMArrayByTypeName(String typeName) throws BmapNotFoundException
  {
    String arrayDescriptor;
    // fix up the type name string to be of the form [LElementClass;
    if (typeName.startsWith("["))
    {
      arrayDescriptor = typeName.replace('.','/');
    }
    else
    {
      arrayDescriptor = "[L" + typeName.replace('.','/') + ";";
    }
    // lookup the array type
    VM_Type vmtype = dictionaryExtension.findType(arrayDescriptor);
    if (vmtype!=null)
    {
      return vmtype.asArray();
    }
    else
    {
      System.out.println("findVMArrayByTypeName: array type not found, " + typeName);
      throw new BmapNotFoundException("array type " + typeName + " is not in the boot image");
    }
  }

  /**
   * Find the address of a static field 
   * @param name    a string of the form class.variable
   * @return address of the TOC entry
   * @exception BmapNotFoundException if the name is not found
   * @see 
   */
  public int findFieldAsAddress(String name) throws BmapNotFoundException {
    String className = CommandLine.varParseClass(name);
    String fieldName[] = CommandLine.varParseField(name);
    if (className==null || fieldName==null)
      throw new BmapNotFoundException("bad name: " + name);    

    VM_Field field = findVMField(className, fieldName[0]);
    int offset = field.getOffset();
    if (field.isStatic()) {
      // System.out.println("static field " + field.getName().toString() +
      // 		    ", descriptor " + field.getDescriptor().toString() +
      // 		    ", offset = " + Integer.toHexString(offset) );
      return owner.mem.addressTOC(offset);
    } else {
      System.out.println("nonstatic field " + field.getName().toString() +
			 ", descriptor " + field.getDescriptor().toString() +
			 ", offset = " + Integer.toHexString(offset) );      
      throw new BmapNotFoundException(field.getName().toString() + " is nonstatic, cannot access through class, please specify an instance of " + CommandLine.varParseClass(name) ); 
    }
    
  }

  /**
   * Return the content of a static field
   * @param name    a string of the form class.variable
   * @return  a string representing the field data
   * @exception BmapNotFoundException if the name is not found
   * @see
   */
  public String staticToString(String name) throws BmapNotFoundException {
    String className = CommandLine.varParseClass(name);
    String fieldNames[] = CommandLine.varParseField(name);

    // How can a reference be made to an object?
    // the first field has to be static or local in the selected stack
    // So if a field is specified, check to make sure that it's static
    if (fieldNames!=null) {
      VM_Field field = findVMField(className,fieldNames[0]);
      if (!field.isStatic()) {
	throw new BmapNotFoundException(field.getName().toString() + 
					" is nonstatic, please specify an instance of " +
					className);
      }
    }

    // the address will be offset from the JTOC since this is static
    try {
      return objectToString(name, 0, true);  // flag set to true to get only static fields
    } catch (memoryException e) {
      return "(" + e.getMessage() + ")";
    }
  }

  /**
   * Given a general expression that resolves to a field (static or dynamic reference)
   * and the address, return the content as a string
   * @param name    a string of the form class.variable, with arbitrary nested fields
   * @param address the address (initial address if nested expression)
   *                this is ignored for static reference
   * @return  a string representing the field data
   * @exception BmapNotFoundException if the name is not found
   * @see
   */
  public String objectToString(String name, int startAddress, boolean staticOnly) 
    throws BmapNotFoundException, memoryException {
    int address = startAddress;
    VM_Field field=null;
    String className = CommandLine.varParseClass(name);
    String fieldNames[] = CommandLine.varParseField(name);
    String fieldDimension[] = CommandLine.varParseFieldDimension(name);

    if (className==null && fieldNames==null)
      throw new BmapNotFoundException("bad name: " + name);    
    if (className!=null && fieldNames==null) {
      if (startAddress==0)
	address = 0;
      else
	address = owner.mem.readsafe(startAddress);  // get the address of the object
      return classToString(name, address, staticOnly);        
    }

    String finalName = className + "." + fieldNames[0]; 

    // deference each field until the last field
    for (int i=0; i<fieldNames.length; i++) {
      // System.out.println("objectToString: for class " + className + 
      // 		    ", field " + fieldNames[i] + 
      // 		    ", dimension " + fieldDimension[i]);
      field = findVMField(className,fieldNames[i]);
      VM_Type fieldtype = field.getType();
      int fieldOffset = field.getOffset();

      // (1) Defererence the address:
      // for a static field, the offset is from the JTOC register pointer
      // for a nonstatic field, the offset if from the object pointer which is passed in
      // as an address
      if (field.isStatic()) {
	address = owner.mem.addressTOC(fieldOffset);
      } else {
	address = owner.mem.readsafe(address) + fieldOffset;	
      }  

      // (2) Construct the name for the remaining fields by collapsing the first field.
      // (the last field will be handled by the toString methods to convert to String)
      if (i<(fieldNames.length-1)) {     

	// If the field is an object, we need to dereference it:
	// update the class name with the type for this field,
	if (fieldtype.isClassType()) {
	  className = fieldtype.getName();
	  finalName = className + "." + fieldNames[i+1];
	}  

	// If the field is an array, we need to get the element type
	// and dereference through the array dimension
	else if (fieldtype.isArrayType()) {
	  VM_Type elementType = ((VM_Array)fieldtype).getElementType();
	  if (elementType.isPrimitiveType()) {
	    throw new BmapNotFoundException(fieldNames[i] + 
					    " is an array of primitive, it has no field");
	  }
	  address = arrayElementAddress(((VM_Array)fieldtype), 
					fieldNames[i]+fieldDimension[i], address);
	  className = elementType.toString();
	  finalName = className + "." + fieldNames[i+1];
	} 

	// If this field is a primitive, there shouldn't be any more fields
	else if (fieldtype.isPrimitiveType()) {
	  throw new BmapNotFoundException(fieldNames[i] + 
					  " is a primitive, it has no field");
	}

      }

      // Some more syntax checking
      if ((fieldtype.isClassType() || fieldtype.isPrimitiveType() ) && 
	  !fieldDimension[i].equals("")) {
	throw new BmapNotFoundException(fieldNames[i] + " is not an array");
      }     

      // System.out.println("objectToString: field " + i + " is type " + fieldtype.getName() + 
      //			 ", address " + VM.intAsHexString(address) + " at offset " + fieldOffset);

    }

    //     System.out.println("objectToString: last field " + finalName + ", address: " + 
    // 			  VM.intAsHexString(address));

    return VMFieldToString(field, finalName+fieldDimension[fieldNames.length-1], address, false);

  }

  /**
   * Follow the array pointers to get to the address of an innermost element
   * The indices for the element is in the String name in the form [n][m]...
   * This does not handle deferencing part-way into the array; in other words,
   * the indices dimension must match the full array dimension
   * @param typeArray  a runtime VM_Array
   * @param name the name corresponding to the VM_Array, with dimension
   * @param addressOfPointer a double-indirect pointer to the array 
   *        (e.g., the address of a TOC or stack entry)
   * @return address of the specified array element
   * @exception BmapNotFoundException for null array, bad array dimension, or 
   *            dimension not matching the array's dimension
   * @exception memoryException if an error occurs in accessing the array
   * @see objectToString, localToString
   */
  private int arrayElementAddress(VM_Array typeArray, String name, int addressOfPointer) throws BmapNotFoundException, memoryException {
    int actualDim = typeArray.getDimensionality();          
    int requestDim[];
    int topAddress, elementAddress, length;

    // System.out.println("arrayElementAddress: on entry " + 
    //		       Integer.toHexString(addressOfPointer));

    try {
      requestDim = CommandLine.varParseArrayDimension(name);
    } catch (NumberFormatException e) {
      throw new BmapNotFoundException("(bad array dimension)");
    }

    if (requestDim.length!=actualDim) {
      throw new BmapNotFoundException("cannot reach innermost element of array " + name);
    } 

    // follow pointers to the desired dimension
    elementAddress = addressOfPointer;
    for (int dim=0; dim<actualDim; dim++) {
     topAddress = owner.mem.readsafe(elementAddress); 
     if (topAddress==0) 
       throw new BmapNotFoundException("(null array)");
     length = owner.mem.readsafe(topAddress + VM.ARRAY_LENGTH_OFFSET);
     if (requestDim[dim]>length-1) {
       throw new BmapNotFoundException("out of range in dimension " + dim + ", 0:" + (length-1));
     } else {
       elementAddress = topAddress + requestDim[dim]*4;
     }
     //     System.out.println("arrayElementAddress: at dim " + dim + 
     //			 ", element " + requestDim[dim] + " @" +
     //			Integer.toHexString(elementAddress));
    }
    
    return elementAddress;

  }


  /**
   * Given a nonstatic VM_Field which is accessed through an object instance
   * return a string representation of the data
   * <p>
   * <ul>
   * <li> For a primitive, the string corresponds to its type
   * <li> For an array, the string either indicates <i>array of array</i> 
   *      or lists all the elements of the last dimension
   * <li> For an object (class), the string is the class name
   * </ul> 
   * 
   * @param address the pointer to the object instance
   * @param field   the VM_Field to be converted to String
   * @param name    the name corresponding to the VM_Field
   * @return  a string representing the VM_Field
   * @see VM_Field 
   */
  public String VMFieldToString (VM_Field field, String name, int fieldAddress, boolean staticOnly) 
    throws memoryException {
    VM_Type fieldType = field.getType();
    int offset = field.getOffset();
    int address;
    
    // System.out.println("VMFieldToString: " + name + ", " + field.getName().toString());

    if (field.isStatic()) 
      address = owner.mem.addressTOC(offset);
    else
      address = fieldAddress;

    if (fieldType.isArrayType()) {
      int arrayAddress = owner.mem.readsafe(fieldAddress);
      return arrayToString(fieldType.asArray(), name, arrayAddress, staticOnly);

    } else if (fieldType.isClassType()) {
      String className = field.getDescriptor().toString();
      className = className.substring(1,className.length()-1);
      address = owner.mem.readsafe(address);   // get the address of the object itself
      return classToString(className, address, staticOnly);

    } else if (fieldType.isPrimitiveType()) {
      // in the TOC, the primitive takes up the same space as on the stack
      return primitiveToString(fieldType, address, fieldType.getStackWords()*4) +
	"  @" + VM.intAsHexString(address);

    } else {
      return "unknown type";
    }

  }

  /**
   * Return a string for the contents of the current object identified as "this".
   * The class is derived from the current stack frame.
   * If the method is static, there is no object reference and only the 
   * static class is returned.
   * If the method is virtual, the object is at the top in the argument list
   * If the current stack frame is not mapped (the class is not in the boot image)
   * return an error message.
   * @param frame     the stack frame to look for "this"
   * @param thisName  a string of the form this.field1.field2...., where the
   *                  fields can be omitted
   * @return a string representing the object, with newline separating the fields
   * @see 
   */
  public String currentClassToString (int frame, String thisName) {
    String fields;
    int ip, fp, compiledMethodID;

    // do we need to get specific fields in "this" object?
    int dot = thisName.indexOf('.');    
    if (dot!=-1)
      fields = thisName.substring(dot);
    else 
      fields = "";

    // traverse to the frame requested
    if (frame!=0) {
      try {
	fp = owner.mem.upNumberOfFrame(frame, owner.reg.currentFP());
	ip = owner.mem.frameIP(fp);
	compiledMethodID = getCompiledMethodID(fp, ip);
      } catch (Exception e) {
	return e.getMessage();
      }
    } else {
      fp = owner.reg.currentFP();
      ip = owner.reg.currentIP();
      compiledMethodID = getCompiledMethodID(fp, ip);
    }

    if (compiledMethodID==NATIVE_METHOD_ID)
      return("native stack frame, no THIS object");

    try {
      // find the method to see if it's static or virtual
      VM_Method currentMethod = findVMMethod(compiledMethodID, true);
      String currentClassName = currentMethod.getDeclaringClass().getName().toString();
      
      if (currentMethod.isStatic()) {
	// for static method, we don't have an object reference 
	return "(method " + currentMethod.getName().toString() + " is static, no _this_ object)";
      } else {
      	// for virtual method, the object is the first in the argument list 
      	int localOffset = VM_Compiler.getFirstLocalOffset(currentMethod);
      	int objectAddr = fp + localOffset;
	// flag set to false to get only nonstatic fields
      	return objectToString(currentClassName+fields, objectAddr, false);  
      }
    } catch (BmapNotFoundException e) {
      return ("class not found for this stack frame, possibly because this class is not in the bootimage");
    } catch (memoryException e1) {
      return e1.getMessage();
    }

  }


  /**
   * Given the name and address of a class object, 
   * return a string for the contents of the object
   * @param className the name of this class (no field name)
   * @param address   the address of the object according to the JVM convention
   *                  (This would be the content of a TOC entry or a stack frame)
   * @return a string representing the object, with newline separating the fields
   * @see 
   */
  public String classToString (String className, int address, boolean staticOnly) 
    throws memoryException {
    VM_Class cls;
    String result = "";
    VM_Field field[];

    // get the VM_Class for this object
    try {
      cls = findVMClassByName(className);
    } catch (BmapNotFoundException e) {
      return "ERROR:  could not find class " + className + 
	"\n (likely because it was not in the boot image)";
    }

    if (staticOnly)
      field = cls.getStaticFields();    // not including the superclass, will get on recursion
    else
      field = cls.getInstanceFields();  // this includes the superclass instance fields
    
    // start with the class name (and address if dynamic object)
    if (!staticOnly && address==0)
      return "null (" + className + ")";
      
    if (staticOnly)
      result += "\n";
    else
      result += "\n  " + className + " @" + VM.intAsHexString(address) + "\n";
    
    // System.out.println("classToString: " + field.length + " fields for " + className + 
    //		       " at " + VM.intAsHexString(address) + ", " + staticOnly);

    // convert each field of the class to string
    for (int i = 0; i < field.length; i++) {
      String fieldName = field[i].getName().toString();
      VM_Type fieldType = field[i].getType();
      int fieldOffset = field[i].getOffset();	  
      int fieldAddress;
      boolean fieldIsStatic = field[i].isStatic();

      // compute the address of this field:  
      // statics is offset from the JTOC, nonstatic is offset from the object address
      // don't print static fields for dynamic object
      // 	 if (staticOnly && !fieldIsStatic)
      // 	   continue;
      // 	 if (!staticOnly && fieldIsStatic)
      // 	   continue;
      
      if (fieldIsStatic)
	fieldAddress = owner.mem.addressTOC(fieldOffset);
      else
	fieldAddress = address + fieldOffset;  // dereference the object

      // System.out.println("classToString: field " + i + " = " + fieldName + 
      // 		    " @" + VM.intAsHexString(fieldAddress));

      // (1) for fields that are classes, just print the class name (This means 
      // we allow only one level of expansion of object, and avoid recursion for 
      // pointer to self)
      if (fieldType.isClassType()) {
	String fieldClassName = fieldType.toString();
	result += "    " + fieldName + " = " + fieldClassName.replace('.','/') + 
	  " @" + VM.intAsHexString(owner.mem.read(fieldAddress)) + "\n";	
	continue;
      } 

      // (2) for fields that are primitive and arrays, 
      if (field[i].isStatic()) {

	// (2a) Find them on the TOC if they are static 
	// (note: this is not a recursion through VMFieldToString 
	// because this field is not a class)
	result += "    " + fieldName + " = " + 
	  VMFieldToString(field[i], className+"."+fieldName, fieldAddress, staticOnly) + "\n";
      } else {

	// (2b) or get them through the object pointer if they are nonstatic
	if (fieldType.isPrimitiveType()) {
	  result += "    " + fieldName + " = " + 
	    primitiveToString(fieldType, fieldAddress, fieldType.getStackWords()*4) + 
	    "  @" + VM.intAsHexString(fieldAddress) + "\n";	  
	} else {
	  int arrayAddress = owner.mem.readsafe(fieldAddress);
	  result += "    " + fieldName + " = ";
	  result += arrayToString(fieldType.asArray(), className+"."+fieldName, 
				  arrayAddress, staticOnly);
	  result += "\n";
	} 
      }

    }  // for field loop //
    
    // now recurse to the superclass to get the statics in the superclass
    // excluding java.lang.Object at the top
    if (staticOnly) {
      VM_Class supercls = cls.getSuperClass();
      if (supercls!=null && 
	  !supercls.getName().toString().equals("java.lang.Object")) {
	//  int superOffset = VM.getMember("LVM_Class;", "superClass", "LVM_Class;").getOffset();
	//  System.out.println("classToString:  superoffset = " + superOffset);
	String superString = classToString(supercls.getName().toString(), 
					 address, staticOnly);
	result = superString + result;
      }
    }
    
    return result;

  }

  /**
   * Return a string that either indicates <i>array of array</i> 
   * or lists all the elements of the last dimension
   * @param field    the VM_Field to be converted to String
   * @param name     the name corresponding to the VM_Field
   * @param address   the address pointing to the array
   * @return a string representing the array
   * @see VM_Array
   */
  private String arrayToString (VM_Array arrayObj, String name, int arrayAddress, boolean staticOnly)
    throws memoryException {
    VM_Type elementType = arrayObj.getElementType();
    int actualDim = arrayObj.getDimensionality();          
    int requestDim[];
    int address = arrayAddress;
    int length, dim;

    // System.out.println("arrayToString: " + elementType.getName() + " at " + 
    //                    VM.intAsHexString(arrayAddress));
    if (address==0) 
      return "(null array)";

    try {
      requestDim = CommandLine.varParseArrayDimension(name);
    } catch (NumberFormatException e) {
      return "(bad array dimension)";
    }

    if (requestDim.length>actualDim) {
      return requestDim.length + " dimension is too many, actual is " + actualDim +
	" for array " + name;
    } else {
      int stopat;
      if (requestDim.length==actualDim) {   // single element requested
	stopat = requestDim.length-1;
      } else {
	stopat = requestDim.length;
      }

      // follow pointers to the desired dimension
      for (dim=0; dim<stopat; dim++) {
	// System.out.println("at " + dim + ": " + Integer.toHexString(address));
	length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);
	if (requestDim[dim]>length-1) {
	  return "out of range in dimension " + dim + ", 0:" + (length-1);
	} else {
	  if (elementType.isArrayType())
	    elementType = ((VM_Array) elementType).getElementType();
	  address = owner.mem.readsafe(address + requestDim[dim]*4);
	}
 
      }

      // find the storage size in byte of the array element
      int logsize = arrayObj.getLogElementSize();
      int size=1;
      for (int i=0; i<logsize; i++)   // do this because we don't have 2^n
	size *= 2;

      // and the array size at this dimension
      length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);

      // then access the array;  there are 3 cases:
      // (1) haven't gotten to the last dimension yet
      if (elementType.isArrayType()) {
	return "array of [0:" + (length-1) + "] arrays @" + VM.intAsHexString(address);
      } 

      // (2) print a single element 
      else if (requestDim.length==actualDim) {   
	if (requestDim[stopat]>(length-1)) {
	  return " out of range, [0:" + (length-1) + "]";
	} else {
	  if (elementType.isPrimitiveType()) {
	    address += requestDim[dim]*size;
	    return primitiveToString(elementType, address, size) + " @" + VM.intAsHexString(address);
	  } else {   
	    address = owner.mem.readsafe(address+requestDim[dim]*4); // get the object address
	    return classToString(elementType.getName(), address, staticOnly);
	  }
	}
      } 

      // (3) print the entire 1D array
      else {                                     // whole last dimension of array
	return array1DToString(elementType,address,size);    
      }
    }

  }

  
  /**
   * Return string listing the contents of a 1D array
   * or the first 20 elements if longer than 20
   * @param etype the VM_Type descriptor for the array element
   * @param address the starting address of the array
   * @param size  the size of the array element 
   * @return a string listing the array
   * @see arrayToString
   */
  private String array1DToString (VM_Type elementType, int address, int size) throws memoryException {
    int length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);

    // System.out.println("array1DToString: " + elementType.getName() + " at " + VM.intAsHexString(address));
    if (elementType.isPrimitiveType()) {
      String result = "{";
      result += primitiveToString(elementType, address, size);    
      int limit = 20;
      limit = (length<limit) ? length : limit;
      for (int i=1; i<limit; i++) {
    	result += ", " + primitiveToString(elementType, address+i*size, size);
      }
      if ((length<20)) { 
	result += "}";
      } else {
	result += ", ... length is " + length + "}";
      }
      result += " @" + VM.intAsHexString(address);
      return result;
    } else {
      if (length!=0)
	return elementType.getName() + "[0:" + (length-1) + "]  @" + VM.intAsHexString(address);
      else
	return elementType.getName() + "[empty]  @" + VM.intAsHexString(address);
    }
  }

  /**
   * Return a string representation of a primitive type
   * Note that we need the address of the primitive, not the value itself
   * because the size of a primitive type may be different depending on 
   * whether it resides on the stack, in the TOC, or in heap memory.
   * This method will access memory by the correct size.
   * @param etype the VM_Type descriptor 
   * @param address the address of this primitive
   * @param size  the size of this type;  this could be different for the same
   *              type depending on whether it's on the stack, in the TOC, or
   *              in an array.
   * @return a string representing the data 
   * @exception
   * @see VM_Type
   */
  private String primitiveToString (VM_Type etype, int address, int size) {    
    int data, data2;

    // System.out.println("primitiveToString: " + etype.toString() + " at " + 
    //        Integer.toHexString(address) + ", size " + size);    

    try {
      switch (size) {
      case 1: 
      	data = owner.mem.readByte(address);
      	break;
      case 2:
      	data = owner.mem.readShort(address);
      	break;
      case 4:
      	data = owner.mem.readsafe(address);
      	break;
      case 8:
      	data = owner.mem.readsafe(address);
      	break;
      default:
      	return "unknown size for primitive type";
      }
      
      if (etype.isIntType()) {                    // integer primitive
	if (Debugger.integerPreference=='x')
	  return VM.intAsHexString(data);
	else
	  return String.valueOf(data);
      
      } else if (etype.isByteType()) {            // byte primitive
      	return String.valueOf((byte) data);
      
      } else if (etype.isCharType()) {            // character primitive
      	return String.valueOf((char) data);
      
      } else if (etype.isDoubleType()) {          // double primitive
      	data2 = owner.mem.readsafe(address+4);
      	return String.valueOf(Double.longBitsToDouble(twoIntsToLong(data,data2)));
      
      } else if (etype.isFloatType()) {          // float primitive
      	return String.valueOf(Float.intBitsToFloat(data));
      
      } else if (etype.isLongType()) {          // long primitive
      	data2 = owner.mem.readsafe(address+4);
      	return String.valueOf(twoIntsToLong(data, data2));
      
      } else if (etype.isShortType()) {          // short primitive
      	return String.valueOf((short) data);      
      
      } else if (etype.isBooleanType()) {          // boolean primitive
      	// can't cast integer to boolean, so just decode it directly
      	if (data==1)
      	  return "true";
      	else if (data==0)
      	  return "false";
      	else 
      	  return "(bad value for boolean)";
      } else {
      	return "unknown primitive type";
      }

    } catch  (memoryException e) {
      return "(" + e.getMessage() + ")";
    }

  }

  /** 
   * Given a stack frame number and a string expression,
   * return the contents of the local variables on this stack frame as a string.
   * If the expression is null, all local variables are returned
   * This method only returns the local variables that falls within the scope 
   * of the current instruction for the stack frame
   * @param frameNumber the stack frame number, current frame is 0
   * @param name the name of the local variable;  null for all variables.
   * @return a string representing the data 
   * @exception
   * @see localToString
   *  
   */
  public String localVariableToString (int frameNumber, String name) {
    int ipOffset, localOffset, spillOffset, fp, ip, compiledMethodID;
    VM_Method mth;
    String localString;
    String requestedLocal[] = null;

    // class, array, or primitive
    if (name!=null) 
      // a hack:  add a dummy class name to parse correctly
      requestedLocal = CommandLine.varParseField("dummyclass." + name);  
    
    // find method and instruction offset of this stack frame
    try {
      if (frameNumber==0) {
	fp = owner.reg.currentFP();
	ip = owner.reg.currentIP();
	compiledMethodID = getCompiledMethodID(fp, ip);
	if (!isFpReady(ip))
	  return "stack frame still being constructed";	
      }
      else {
	fp = owner.mem.upNumberOfFrame(frameNumber, owner.reg.currentFP());
	ip = owner.mem.frameIP(fp);
	compiledMethodID = getCompiledMethodID(fp, ip);
      }

      if (compiledMethodID==NATIVE_METHOD_ID)
	return "native stack frame, no local variables";

      ipOffset = instructionOffset(compiledMethodID, ip);
      if (ipOffset==-1)
        return "(in prolog or epilog code)";
      mth = findVMMethod(compiledMethodID,true);
      if (mth==null)
        return "(method ID not set up yet)";
      localOffset = VM_Compiler.getFirstLocalOffset(mth);
      spillOffset = VM_Compiler.getEmptyStackOffset(mth);
    } catch (BmapNotFoundException e) {
      return "stack frame " + frameNumber + " unmapped";
    } catch (Exception e1) {
      return e1.getMessage();
    }

    // System.out.println("fp = " + VM.intAsHexString(fp) + " in " + mth.getName());

    // get list of local variables that are currently in scope
    // TODO:  use compiled method ID to get the correct compilerInfo
    VM_LocalVariable locals[] = mth.getMostRecentlyGeneratedCompilerInfo().findLocalVariablesForInstruction(ipOffset);
    if (locals==null)
      return "Locals in frame " + frameNumber + ", " + 
      mth.getName().toString() + ":\n (no local variable)";

    // walk through the list
    // -print the name
    // -get the value at the stack offset
    // -convert the value to string:  primitive or reference
    localString = "";
    for (int i=0; i<locals.length; i++) {
      int    varOffset  = locals[i].getStackOffset()*4;
      int    varAddress = fp+localOffset-varOffset;
      String varName    = locals[i].getName();
      String actualName;
      if (requestedLocal!=null) {      // name specified, find matching fields
          if (!requestedLocal[0].equals(varName))
            continue;
          else
            actualName = name;
        } else {
          actualName = varName;   // no name given, use the name found in the field
        }
        localString += actualName;
        try {
          localString += " = " + localToString(locals[i],actualName,varAddress) + "\n";
        } catch (memoryException e) {
          localString += " = (" + e.getMessage() + ")";
        }
    }

    if (name!=null && localString.equals(""))
      localString += name + " not found or not in current scope";
    if (name==null && localString.equals(""))
      localString += " (none in current scope)";

    return "Locals in frame " + frameNumber + ", " + 
      mth.getName().toString() + ":\n" + localString;

  }

  /**
   * Given a single stack entry for a local variable, return the string
   * for the content of the variable
   * @param local a VM_LocalVariable descriptor
   * @param name  a string of the form localName.field1.field2..., nested arbitrarily
   *              and with any array subscript
   * @param address the stack address of the local variable
   * @return a string for the content of the variable: a primitive value, 
   *         the array contents, or the entire object contents.
   * @exception memoryException if an error occurs in dereferencing the local variable
   */


  public String localToString (VM_LocalVariable local, String name, int address) throws memoryException {
    int pointer = owner.mem.readsafe(address);
    String descriptor = local.getDescriptor().toString();
    VM_Type localType = dictionaryExtension.findType(descriptor);
    String newname;

    // Do we have nested fields to pass on?
    // Separate into the local variable name and any nested fields
    // (a hack:  the local name may also contain array dimension)
    String localName = CommandLine.varParseClass(name);
    String fieldsName = name.substring(localName.length());

    // System.out.println("localToString, getting: " + local.getName() + ", " + name);
    // System.out.println("localToString: " + localType.toString() + " at " + VM.intAsHexString(pointer));

    // for object reference on stack
    // replace the local name with its class name
    // for the class name, use the "/" notation so that later we can parse 
    // the class from the nested fields in the expression
    if (localType.isClassType()) {
      if (pointer==0)                     // null pointer
	return "(null object)";
      else {
	newname = local.getDescriptor().classNameFromDescriptor().replace('.','/');
	newname += fieldsName;
	try {
	  // flag set to false to get only nonstatic fields
	  return objectToString(newname,address, false);   
	} catch (BmapNotFoundException e) {
	  return (e.getMessage());
	}
      }
    }

    // (2) for array on stack
    // replace the local name with its element type
    // If the element is primitive, print the array using arrayToString() and there 
    // shouldn't be any nested fields
    // If the element is class, print using objectToString
    if (localType.isArrayType()) {
      if (pointer==0) 
	return "(null array)";

      if (fieldsName.equals(""))
	// flag set to false to get only nonstatic fields
	return arrayToString(localType.asArray(), name, pointer, false); 

      VM_Type elementType = localType.asArray().getInnermostElementType();
      if (elementType.isClassType()) {
	newname = elementType.getDescriptor().classNameFromDescriptor().replace('.','/');
	newname += fieldsName;
	
	try {
	  // dereference the address throught the array dimension
	  int arrayPointer = arrayElementAddress(localType.asArray(), localName, address);
	  // flag set to false to get only nonstatic fields
	  return objectToString(newname, arrayPointer, false);
	} catch (BmapNotFoundException e) {
	  return (e.getMessage());
	}
      } else {
	// element is not a class, so there can be no fields
	return local.getName() + " is an array of primitive, it has no field ";
      }
    }

    // (3) for primitive on stack
    return primitiveToString(localType, address, localType.getStackWords()*4);
  }

  /**
   * Given an object address, lookup the type ID and get the class name
   * @param address an object address
   * @return the class name as string 
   * @exception if a memory is encountered while deferencing the type ID
   */

  public String addressToClassString(int address) throws memoryException {
    int stringAddr, size;
    int typeAddr = owner.mem.readsafe(address + VM_ObjectLayoutConstants.OBJECT_TIB_OFFSET);
    typeAddr = owner.mem.readsafe(typeAddr);           // this should point to the VM_Type

    try {
      VM_Field field = findVMField("VM_Type", "descriptor");
      stringAddr = owner.mem.readsafe(typeAddr + field.getOffset());    // the descriptor
      field = findVMField("VM_Atom", "val");
      stringAddr = owner.mem.readsafe(stringAddr + field.getOffset());  // the string array as byte
      size = owner.mem.readsafe(stringAddr + VM.ARRAY_LENGTH_OFFSET);   // the string size
    } catch (BmapNotFoundException e) {
      return e.getMessage();
    }

    // System.out.println("VM_Type @" + VM.intAsHexString(typeAddr) + 
    //		       ", string @" + VM.intAsHexString(stringAddr));
    // It's a string but stored as an array of byte, so we have to retrieve
    // each byte at a time
    byte className[] = new byte[size];
    for (int i=0; i<size; i++) {
      className[i] = owner.mem.readByte(stringAddr+i);
    }

    return new String(className);
  }

  /**
   * Return the VM_Method at the specified stack frame, relative to the
   * top frame
   * @param frameNumber  the requested stack frame 
   * @return the VM_Method at this stack frame
   * @exception  if the frame is not ready or is invalid
   * @see CommandCompletion.completeLocalAndField
   */
  public VM_Method getMethodAtFrame(int frameNumber) throws Exception {
    try {
      int fp, ip, compiledMethodID;
      if (frameNumber==0) {
	fp = owner.reg.currentFP();
	ip = owner.reg.currentIP();
	if (!isFpReady(ip))
	  throw new Exception("stack frame still being constructed");	
      }
      else {
	fp = owner.mem.upNumberOfFrame(frameNumber, owner.reg.currentFP());
	ip = owner.mem.frameIP(fp);
      }
      compiledMethodID = getCompiledMethodID(fp, ip);
      if (compiledMethodID==NATIVE_METHOD_ID)
	throw new Exception("native stack frame " + frameNumber);
      return findVMMethod(compiledMethodID, true);
    } catch (BmapNotFoundException e) {
      throw new Exception("stack frame " + frameNumber + " unmapped");
    }
  }

  /**
   * Combine two integer to make a long
   * @param hi the upper word for the long
   * @param lo the lower word for the long
   * @return a long number
   * @see
   */
  public static long twoIntsToLong(int hi, int lo) {
    long result = (((long) hi) << 32);
    result |= ((long) lo) & 0xFFFFFFFFL;
    return result;
  }

  /**
   * Return false if the FP is still being calculated and the stack frame 
   * is not updated yet (the address is within 4 words from the start of the method)
   * @param address    an arbitrary address pointing to a machine instruction 
   * @return true if the FP value is valid or the address is not in the map
   * @see
   */
  public boolean isFpReady(int address) {
    int offset;
    return true;   // disable for now, no reliable way to detect invalid fp
    // try {
    // 	 offset = instructionOffset(address)/4;
    // 	 // System.out.println("  for " + Integer.toHexString(address) + ", offset = " + offset);
    // 	 if (offset<=4)      // fp is updated after the 4th prolog instruction
    // 	   return false;     // (THIS COULD CHANGE)
    // 	 else
    // 	   return true;
    // } 
    // catch (BmapNotFoundException e) {
    // 	 return true;        // not in map, assume it's OK
    // }
  }


  /**
   *  Check if an instruction address is in the address space for the JVM
   *  If not, then it must be in the space for native code (system or user)
   *  @param instructionAddress a random instruction address
   *  @return true if the address is in the JVM space, false otherwise 
   */
  public boolean isInRVMspace(int instructionAddress) {
    int vmEnd = owner.mem.read(vmEndAddress); 
    if (instructionAddress>=bootStart & instructionAddress<=vmEnd)
      return true;
    else
      return false;
  }


  /**
   * Find the line number associated with an address
   * @param compiledMethodID  an index into the compiled method table
   * @param address   an arbitrary address pointing to a machine instruction 
   * @return  the source line number, or ? if line number is not available,
   *         or <prolog> if the address is in the prolog code of the method
   * @see findLineNumber
   */
  public String findLineNumberAsString(int compiledMethodID, int address) {
    try {
      int line = findLineNumber(compiledMethodID, address);   
      return String.valueOf(line);
    } catch (LnNotAvailException e) {
      return "?";
    } catch (BcPrologException e1) {
      return "<prolog>";
    }
  }

  /**
   * Find the line number that is one before the current line 
   * @param compiledMethodID   the index into the table of compiled methods
   * @param  address    an arbitrary address pointing to a machine instruction
   * @return the source line number, or ? if line number is not available,
   *         or <prolog> if the address is in the prolog code of the method
   * @see findPreviousLineNumber
   */
  public String findPreviousLineNumberAsString(int compiledMethodID, int address) {
    try {
      int line = findPreviousLineNumber(compiledMethodID, address);   
      return String.valueOf(line);
    } catch (LnNotAvailException e) {
      return "?";
    } catch (BcPrologException e1) {
      return "<prolog>";
    }
  }

  /**
   * Find the line number associated with an address
   * @param compiledMethodID   the index into the table of compiled methods
   * @param address    an arbitrary address pointing to a machine instruction
   * @return  the current source line number
   * @exception LnNotAvailException if the method was not compiled with -g
   * @exception BcPrologException   if the address is in the prolog code of the method
   * @see findLineFromVMMethod
   */
  public int findLineNumber(int compiledMethodID, int address) 
    throws LnNotAvailException, BcPrologException 
  {
    boolean previous_line = false;
    return findLineFromVMMethod(compiledMethodID, address, previous_line);  
  }

  /**
   * Find the line number that is one before the current line 
   * @param compiledMethodID   the index into the table of compiled methods
   * @param  address    an arbitrary address pointing to a machine instruction
   * @return  the previous source line number
   * @exception LnNotAvailException if the method was not compiled with -g
   * @exception BcPrologException   if the address is in the prolog code of the method
   * @see  findLineFromVMMethod
   */
  private int findPreviousLineNumber(int compiledMethodID, int address) 
    throws LnNotAvailException, BcPrologException 
  {
    boolean previous_line = true;
    return findLineFromVMMethod(compiledMethodID, address, previous_line);  
  }

  /**
   * Find the line number associated with an address, common code shared by
   * <i>findLineNumber</i> and <i>findPreviousLineNumber</i>
   * @param address  an arbitrary address pointing to a machine instruction
   * @param previous_line flag to get the current line or the previous line
   *  (necessary because VM_Magic.findLineNumberForInstruction returns the 
   *   previous line)
   * @return the source line number 
   * @exception LnNotAvailException if the method was not compiled with -g
   * @exception BcPrologException   if the address is in the prolog code of the method
   * @see VM_Magic.findLineNumberForInstruction, findLineNumber, findPreviousLineNumber
   */
  private int findLineFromVMMethod(int compiledMethodID, int address, boolean previous_line) 
    throws LnNotAvailException, BcPrologException 
  {
    int line, offset, prologOffset;

    try {
      VM_Method mth = findVMMethod(compiledMethodID, true);
      offset = instructionOffset(compiledMethodID, address);
      prologOffset = scanPrologSize(instructionAddress(compiledMethodID));
      if (offset<prologOffset)
	throw new BcPrologException();
      if (!previous_line)
	offset+=1;

      // TODO:  should use compiled method ID to get the correct compilerInfo
      VM_CompilerInfo compInfo = mth.getMostRecentlyGeneratedCompilerInfo();
      // VM_OptCompilerInfo compInfo = (VM_OptCompilerInfo) (mth.getMostRecentlyGeneratedCompilerInfo());

      // check because there may be no compiler info:  native method
      if (compInfo==null) {
	line = 0;
      } else {
	line = compInfo.findLineNumberForInstruction(offset);
      }
      // System.out.println("offset=" + offset + ", line=" + line + 
      //			 " for " + mth.getName().toString());
    } catch (BmapNotFoundException e) {
      throw new LnNotAvailException();
    } 

    if (line==0) {
      throw new LnNotAvailException();
    } else {
      return line;
    }
  }

  /**
   * Find the file name of the Java source 
   * @param address  an arbitrary address pointing to a machine instruction
   * @return the Java source file name for this class
   * @exception BmapNotFoundException
   * @see
   */
  private String findSourceFileName(int compiledMethodID) throws BmapNotFoundException {
    VM_Class cls = findVMClass(compiledMethodID, true);
    VM_Atom source = cls.getSourceName();
    if (source!=null) {
      return source.toString();
    } else {
      throw new BmapNotFoundException("No Java source file for this class");
    }
  }

  /**
   * Display the Java source line that has a machine instruction at this address
   * @return
   * @see
   */
  public void printCurrentSourceLine() {
    int curr_line;
    int fp, ip, compiledMethodID;

    try {
      fp = owner.reg.currentFP();
      ip = owner.reg.currentIP();
      compiledMethodID = getCompiledMethodID(fp, ip);
      
      if (compiledMethodID==NATIVE_METHOD_ID) {
	System.out.println("  (native code)");
        return;
      }

      curr_line = findLineNumber(compiledMethodID, ip);
      try {
	String source = findSourceFileName(compiledMethodID);
	if (!sourceSnapshot.sameSourceFile(source))
	  System.out.println("  In file " + source + ":");
	String sourceline = sourceSnapshot.getSourceLine(source, curr_line);
	System.out.println("  line " + curr_line + ":" + sourceline);
      } catch (BmapNotFoundException e) {
	System.out.println("  (source file name not recorded):"  + curr_line);
      }
    } catch (LnNotAvailException e) {
      System.out.println("  (line number not available)");
    } catch (BcPrologException e1) {
      System.out.println("  (in method prolog)");
    } catch (Exception e) {
      System.out.println("  ERROR reading register FP");  
    }
  }

  // METHODS FOR NETWORK DEBUGGER

  /**
   * Return a JDPClass for the contents of the current thread, obtained from VM_Processor
   * @return a JDP_Class representing the object
   */
  public JDP_Class currentThreadToJDPClass () {
    int ip, fp, compiledMethodID;

    try {
    
      int vp = owner.reg.read("PR");
      // get the current thread
      int objectAddr = owner.mem.read(vp + VM_Entrypoints.activeThreadOffset);  
      
      // get the type string for this thread
      String currentClassName = addressToClassString(objectAddr);   
      
      // chopoff the L and ; from the type descriptor
      currentClassName = currentClassName.substring(1, currentClassName.length()-1);  
      return objectToJDPClass(currentClassName, 
			      (vp + VM_Entrypoints.activeThreadOffset), false);
    } catch (Exception e) {
      System.out.println("currentThreadToJDPClass: fail to get current thread, " + 
			 e.getMessage());
      return null;
    }

  } 

  /**
   * Given a class name and address of a pointer to the object, returns a JDP_Class
   * object representing the object
   * @param name    a string class name
   * @param startAddress the address of a pointer to the object
   * @return  a JDP_Class representing the field data
   * @exception BmapNotFoundException if the name is not found
   * @exception memoryException if some bad memory access occurs
   * @exception NoSuchClassException if some other invalid invocation occurs
   * @see Debugger.doGetClassCommand, Debugger.doGetArrayCommand
   */
  public JDP_Class objectToJDPClass(String name, int startAddress, boolean staticOnly) 
    throws BmapNotFoundException, memoryException, NoSuchClassException {
    int address = startAddress;
    VM_Field field=null;
    // parse the name
    String className = CommandLine.varParseClass(name);
    String fieldNames[] = CommandLine.varParseField(name);
    String fieldDimension[] = CommandLine.varParseFieldDimension(name);
    // create the JDP_Class object
    JDP_Class jdpClass = new JDP_Class();
    jdpClass.name = className;
    jdpClass.instance = !staticOnly;    
    if (className==null)
      throw new BmapNotFoundException("bad name: " + name);    
    if (className!=null && fieldNames==null) {
      // we just want to get the statics for <className>
      address = owner.mem.readsafe(startAddress);  // get the address of the Class object
      jdpClass.address = address;
      classToJDPClass(name, address, staticOnly, jdpClass);
    }
    else
    {
      throw new BmapNotFoundException("incorrect call to objectToJDPClass");
    }
    return jdpClass;    
  }

  /**
   * given the type of an array and its address, creates a JDP_Class object
   * representing the array
   * @param name the name of the array variable
   * @param type the type of the array
   * @param address the address of the array
   * @return a JDP_Class object representing the array
   * @exception BmapNotFoundException if the name is not found
   * @exception memoryException if some bad memory access occurs
   * @exception NoSuchClassException if some other invalid invocation occurs
   */
  public JDP_Class arrayTypeToJDPClass(String name, String type, int address, boolean staticOnly)
    throws BmapNotFoundException, memoryException, NoSuchClassException 
  {
    JDP_Class jdpClass = new JDP_Class();
    jdpClass.name = name;
    jdpClass.instance = !staticOnly;
    jdpClass.address = address;
    // System.out.println(address);
    // get the array type
    VM_Array vmarray = findVMArrayByTypeName(type);
    int length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);
    // make fields for each of the array elements
    for (int i = 0; i < length; i++)
    {
      //System.out.println("field " + i);
      JDP_Field jdpField = new JDP_Field();
      jdpField.name = name + "[" + i + "]";
      //System.out.println("name = " + jdpField.name);
      jdpField.arrayType = true;
      jdpField.classType = false; // will be set true later if necessary
      // we hack the name because the address is already for a certain sub-dimension
      // of the array
      String hackedName = name;
      if (name.indexOf('[') != -1)
      {
        hackedName = name.substring(0, name.indexOf('['));
      }
      //System.out.println(hackedName);
      arrayToJDPField(vmarray, hackedName + "[" + i + "]",
                        address, false, jdpField);
      jdpClass.fields.addElement(jdpField);
    }
    return jdpClass;

  }
  /**
   * modifies a JDP_Class object to hold the information about a
   * class or instance
   * @param className      the name of the class
   * @param address        address of instance, ignored if staticOnly is true
   * @param staticOnly     true if only static information is desired, false if
   *                       instance information is needed
   * @param jdpClass       the JDP_Class object to modify
   * @exception memoryException if some memory error occurs
   * @exception NoSuchClassException if some other invalid invocation occurs
   */
  public void classToJDPClass(String className, int address,
                              boolean staticOnly, JDP_Class jdpClass)
    throws NoSuchClassException, memoryException
  {
    
    VM_Class cls;
    VM_Field field[];

    // get the VM_Class for this object
    try {
      cls = findVMClassByName(className);
    } catch (BmapNotFoundException e) {
      throw new NoSuchClassException();
    }

    // if statics are desired, recurse to the superclass to
    // get the statics in the superclass excluding java.lang.Object
    // at the top
    if (staticOnly) {
      VM_Class supercls = cls.getSuperClass();
      if (supercls!=null && 
	  !supercls.getName().toString().equals("java.lang.Object")) {
	classToJDPClass(supercls.getName().toString(), 
                        address, staticOnly, jdpClass);
      }
    }
    
    if (staticOnly)
      field = cls.getStaticFields();    
    else
      field = cls.getInstanceFields();  // this includes the superclass instance fields
    
    // create a JDP_Field object for each field of the class
    for (int i = 0; i < field.length; i++) {
      JDP_Field curField = new JDP_Field();
      curField.name = field[i].getName().toString();
      VM_Type fieldType = field[i].getType();
      curField.type = fieldType.toString();
      int fieldOffset = field[i].getOffset();	  
      boolean fieldIsStatic = field[i].isStatic();

      // compute the address of this field:  
      // statics is offset from the JTOC, nonstatic is offset from the object address
      if (fieldIsStatic)
	curField.address = owner.mem.addressTOC(fieldOffset);
      else
	curField.address = address + fieldOffset;  // dereference the object

      // (1) for fields that are classes, just get the address and finish
      // further information about the class will be retrieved when requested
      // by the client
      if (fieldType.isClassType()) {
        curField.classType = true;
        curField.address = owner.mem.read(curField.address);
        jdpClass.fields.addElement(curField);
	continue;
      } 
      if (fieldType.isPrimitiveType()) {
        // for primitive fields, just get the value
        curField.value = primitiveToString(fieldType, curField.address, fieldType.getStackWords()*4);
      } else {
        // fieldType.isArrayType() == true
        curField.address = owner.mem.readsafe(curField.address);
        curField.arrayType = true;
        arrayToJDPField(fieldType.asArray(), className+"."+curField.name, 
                        curField.address, staticOnly, curField);
      } 
      jdpClass.fields.addElement(curField);
    }  // for field loop //
  }

  /**
   * modify a JDP_Field object to hold information about a
   * given array
   * @param arrayObj       the relevant VM_Array
   * @param name           the name of the array 
   * @param arrayAddress   the address pointing to the array
   * @param staticOnly     true if only static information is desired
   * @param jdpField       the JDP_Field to be modified
   * @exception memoryException if some memory error occurs
   * @exception NoSuchClassException if some other invalid invocation occurs
   * @see VM_Array
   */
  private void arrayToJDPField (VM_Array arrayObj, String name, int arrayAddress, boolean staticOnly,
                                  JDP_Field jdpField) 
    throws memoryException, NoSuchClassException {
    // get array info
    VM_Type arrayType = arrayObj;
    VM_Type elementType = arrayObj.getElementType();
    int actualDim = arrayObj.getDimensionality();          
    int requestDim[];
    int address = arrayAddress;
    int length, dim;
    if (address==0)
    {
      // null array
      return;
    }
    
    try {
      // get the dimension of the array requested
      requestDim = CommandLine.varParseArrayDimension(name);
    } catch (NumberFormatException e) {
      throw new NoSuchClassException();
    }

    if (requestDim.length>actualDim) {
      throw new NoSuchClassException();
    } else {
      int stopat; // dimension to stop at when traversing pointers
      if (requestDim.length==actualDim) {   // single element requested
	stopat = requestDim.length-1;
      } else {
	stopat = requestDim.length;
      }

      // follow pointers to the desired dimension
      for (dim=0; dim<stopat; dim++) {
        // read length of array
	length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);
	if (requestDim[dim]>length-1) {
          // array index out of bounds for this dimension
          throw new NoSuchClassException();
	} else {
	  if (elementType.isArrayType())
          {
            arrayType = elementType;
	    elementType = (elementType.asArray()).getElementType();
          }
	  address = owner.mem.readsafe(address + requestDim[dim]*4);
	}
 
      }

      // find the storage size in bytes of the array element
      int logsize = arrayObj.getLogElementSize();
      int size=1;
      for (int i=0; i<logsize; i++)   // do this because we don't have 2^n
	size *= 2;

      // and the array size at this dimension
      length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);
      jdpField.arrayLength = length;

      // set the type field of jdpField to be the array type
      // at this dimension
      jdpField.type = arrayType.toString();      

      // then access the array;  there are 3 cases:
      // (1) haven't gotten to the last dimension yet
      if (elementType.isArrayType()) {
        jdpField.classType = true; // hack to make it expandable in tree
        jdpField.address = address;
      } 

      // (2) print a single element 
      else if (requestDim.length==actualDim) {
	if (requestDim[stopat]>(length-1)) {
          // array index out of bounds
	  throw new NoSuchClassException();
	} else {
          jdpField.type = elementType.toString();
          jdpField.arrayType = false;
	  if (elementType.isPrimitiveType()) {
            // get primitive value
	    address += requestDim[dim]*size;
            jdpField.address = address;
	    jdpField.value = primitiveToString(elementType, address, size) + " @" + VM.intAsHexString(address);
	  } else {
            jdpField.classType = true;
            address = owner.mem.readsafe(address+requestDim[dim]*4); // get the object address
            jdpField.address = address;
	  }
	}
      } 

      // (3) process the entire 1D array
      else {                                     // whole last dimension of array
	array1DToJDPField(elementType,address,size, jdpField);    
      }
    }
    
  }

  /**
   * modify JDP_Field object to hold information on given
   * dimension of array
   * @param elementType the VM_Type descriptor for the array element
   * @param address the starting address of the array
   * @param size  the size of the array element
   * @param jdpField the relevant JDP_Field object
   * @exception memoryException if some memory error occurs   
   * @see arrayToString
   */
  private void array1DToJDPField (VM_Type elementType, int address, int size,
                                  JDP_Field jdpField) throws memoryException {
    // get array length

    int length = owner.mem.readsafe(address + VM.ARRAY_LENGTH_OFFSET);

    if (elementType.isPrimitiveType()) {
      // just set the value to be a representation of the primitive
      // array element values
      // don't display more than 20 elements on the line
      String result = "{";
      result += primitiveToString(elementType, address, size);    
      int limit = 20;
      limit = (length<limit) ? length : limit;
      for (int i=1; i<limit; i++) {
    	result += ", " + primitiveToString(elementType, address+i*size, size);
      }
      if ((length<20)) { 
	result += "}";
      } else {
	result += ", ... length is " + length + "}";
      }
      result += " @" + VM.intAsHexString(address);
      jdpField.value = result;
    } else {
      // make this an expandable node
      jdpField.classType = true;
      jdpField.address = address;
      if (length!=0)
	jdpField.value = elementType.getName() + "[0:" + (length-1) + "]  @" + VM.intAsHexString(address);
      else
	jdpField.value = elementType.getName() + "[empty]  @" + VM.intAsHexString(address);
    }
  }

  /**
   * returns the current class name and source line number
   * @return a String containing the current class and line number
   */
  public String getCurrentClassAndLineNumber()
  {
    // get the method ID
    int fp = owner.reg.currentFP();
    int ip = owner.reg.currentIP();
    int compiledMethodID = getCompiledMethodID(fp, ip);
    if (compiledMethodID==NATIVE_METHOD_ID)
    {
      return "(native code)";
    }
    return getCurrentClassName(compiledMethodID) +
    "." + findVMMethod(compiledMethodID,true).getName().toString() +
    ":" + findLineNumberAsString(compiledMethodID, ip);
  }

  /**
   * return the current class name
   * @return the String class name
   */
  private String getCurrentClassName(int compiledMethodID)
  {
    VM_Class cls = findVMClass(compiledMethodID, true);
    return cls.getName();
  }

  /**
   * get a Vector of JDP_Frames representing all the frames
   * currently on the stack
   * @return a Vector of JDP_Frame objects
   */
  public Vector getFrames()
  {
    int fp = owner.reg.currentFP();
    int depth = owner.mem.findFrameCountFrom(fp);
    Vector frames = new Vector(); // JDP_Frame objects
    for (int i = 0; i < depth - 1; i++)
    {
      JDP_Frame frame = createJDPFrame(i);
      frames.addElement(frame);
    }
    frames.trimToSize(); // to improve network performance
    return frames;
  }

  /**
   * create a JDP_Frame object representing the requested frame
   * @param frameNumber depth of the desired frame, with 0 being the current frame
   * @return the JDP_Frame object
   */
  private JDP_Frame createJDPFrame(int frameNumber)
  {
    int fp, ip, ipOffset, compiledMethodID;
    VM_Method mth;
    JDP_Frame frame = new JDP_Frame();
    frame.number = frameNumber;
    try
    {
      // figure out which frame was requested
      if (frameNumber==0)
      {
	fp = owner.reg.currentFP();
	ip = owner.reg.currentIP();
	compiledMethodID = getCompiledMethodID(fp, ip);
	if (!isFpReady(ip))
          // frame not ready
          return invalidateFrame(frame,"stack frame still being constructed");

      }
      else
      {
	fp = owner.mem.upNumberOfFrame(frameNumber, owner.reg.currentFP());
	ip = owner.mem.frameIP(fp);
	compiledMethodID = getCompiledMethodID(fp, ip);
      }
      if (compiledMethodID==NATIVE_METHOD_ID)
        // no locals for native frame
        return invalidateFrame(frame,"native stack frame, no local variables");
      ipOffset = instructionOffset(compiledMethodID, ip);
      if (ipOffset==-1)
        return invalidateFrame(frame,"(in prolog or epilog code)");
      mth = findVMMethod(compiledMethodID,true);
      if (mth==null)
        return invalidateFrame(frame,"(method ID not set up yet)");
      frame.compiledMethodID = compiledMethodID;
      frame.fp = fp;
      frame.ipOffset = ipOffset;
    }
    catch (BmapNotFoundException e)
    {
      return invalidateFrame(frame,"stack frame " + frameNumber + " unmapped");
    }
    catch (Exception e1)
    {
      return invalidateFrame(frame,e1.getMessage());
    }
    frame.valid = true;
    frame.methodName = getCurrentClassName(compiledMethodID) + "." + mth.getName().toString();
    return frame;
  }
    
  /**
   * create a JDP_Locals object representing the locals in the requested frame
   * @param frameNumber depth of the desired frame, with 0 being the current frame
   * @param compiledMethodID the compiled method ID for the method corresponding
   *                         to the frame
   * @param fp the frame pointer for the requested frame
   * @param ipOffset offset of currently executing instruction in requested frame
   * @return the JDP_Locals object
   */
  public JDP_Locals localsToJDPLocals (int frameNumber, int compiledMethodID,
                                       int fp, int ipOffset)
  {
    int localOffset, spillOffset;
    VM_Method mth;
    JDP_Locals localVars = new JDP_Locals();
    mth = findVMMethod(compiledMethodID,true);
    if (mth==null)
      return null;
    localOffset = VM_Compiler.getFirstLocalOffset(mth);
    spillOffset = VM_Compiler.getEmptyStackOffset(mth);
    
    // get list of local variables that are currently in scope
    // TODO:  use compiled method ID to get the correct compilerInfo
    VM_LocalVariable locals[] = mth.getMostRecentlyGeneratedCompilerInfo().findLocalVariablesForInstruction(ipOffset);
    if (locals==null)
      return localVars;

    // walk through the list, creating a JDP_Field object
    // for each local variable
    for (int i=0; i<locals.length; i++)
    {
      int    varOffset  = locals[i].getStackOffset()*4;
      int    varAddress = fp+localOffset-varOffset;
      try
      {
        localVars.vars.addElement(localToJDPField(locals[i], varAddress));
      }
      catch (memoryException e1)
      {
        return null;
      }
      catch (NoSuchClassException e2)
      {
        return null;
      }
    }
    localVars.vars.trimToSize();
    return localVars;
  }

  /**
   * create a JDP_Field object representing the local variable
   * @param local the local variable
   * @param address the address of the local
   * @return the JDP_Field object
   * @exception memoryException if an invalid memory address is accessed
   * @exception NoSuchClassException if the query is otherwise invalid
   */
  private JDP_Field localToJDPField(VM_LocalVariable local, int varAddress) throws memoryException, NoSuchClassException
  {
    JDP_Field localField = new JDP_Field();
    localField.name = local.getName();
    int pointer = owner.mem.readsafe(varAddress);
    String descriptor = local.getDescriptor().toString();
    //System.out.println(descriptor);
    VM_Type localType = dictionaryExtension.findType(descriptor);
    localField.type = localType.toString();
    //System.out.println("type = " + localField.type);
    String newname;

    // for object reference on stack
    // set fields and return, will be expanded in later request
    if (localType.isClassType()) {
      localField.classType = true;
      localField.address = pointer;
      return localField;
    }

    // (2) for array on stack
    if (localType.isArrayType()) {
      localField.arrayType = true;
      localField.address = pointer;
      arrayToJDPField(localType.asArray(), localField.name, 
                      localField.address, false, localField);
      return localField;
    }
    
    // (3) for primitive on stack
    localField.value = primitiveToString(localType, varAddress, localType.getStackWords()*4);
    return localField;
  }
    

  /**
   * set a JDP_Frame to be invalid with a certain message
   * @param frame the JDP_Frame object
   * @param invalidMessage the message
   * @return the invalidated JDP_Frame object
   */
  private JDP_Frame invalidateFrame(JDP_Frame frame, String invalidMessage)
  {
    frame.valid = false;
    frame.invalidMessage = invalidMessage;
    return frame;
  }
  

}


