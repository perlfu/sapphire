/*
 * (C) Copyright IBM Corp. 2001
 */

//$Id$

/**
 *  <P> This class is the low-level assembler for Intel; it contains
 * functionality for encoding specific instructions into an array of
 * bytes.  It consists of three parts: </P>
 * <UL>
 *  <LI> Some support that handles common operations for generating
 *       any IA32 instruction, such as encoding the operands into the
 *       ModRM and SIB bytes
 *  <LI> Some hand-coded methods that emit instructions with
 *       distinctive formats or with special consistency requirements,
 *       such as FXCH or CMOV
 *  <LI> Machine-generated methods that emit instructions with
 *       relatively standard formats, such as binary accumulation
 *       instructions like ADD and SUB.
 * </UL>
 *  <P> This assembler provides a direct interface to the IA32 ISA: it
 * contains emit methods that generate specific IA32 opcodes, and each
 * emit method specifies the addressing modes and operand sizes that
 * it expects.  Thus, it has an emit method that generates an ADD of a
 * register-displacement operand  and an immediate operand.  It is the
 * job of the client to determine the addressing modes, operand
 * sizes and exact opcodes that it desires. </P>
 *
 *  <P> This assembler does provide support for forward branches.  It
 * is permitted to specify a branch operand as an arbitrary label, and
 * later to inform the assembler to which instruction this label
 * refers.  The assembler, when informed to what the label refers,
 * will go back and generate the appropriate offsets for all branches
 * that refer to the given label. The mechanism is implemented by the
 * following methods and helper classes:
 * <UL>
 * <LI> {@link #forwardRefs}
 * <LI> {@link #resolveForwardReferences}
 * <LI> {@link #patchUnconditionalBranch}
 * <LI> {@link #patchConditionalBranch}
 * <LI> {@link #emitJCC_Cond_Label}
 * <LI> {@link #emitJMP_Label}
 * <LI> {@link #emitCALL_Label}
 * <LI> {@link VM_ForwardReference}
 * </UL>
 * </P>
 *
 *  <P> There is also support for generating tableswitches.  This
 * consists providing support for storing tables of relative addresses
 * that can be used to compute the target of a tableswitch.  This
 * support assumes a particular code sequence for tableswitches
 * (followed by baseline and optimizing compilers).  See {@link
 * emitOFFSET_Imm_ImmOrLabel} and {@link patchCaseLabel} for
 * details. </P>
 *
 *  <P> The automatically-generated emit methods of this assembler
 * exploit regularities in the IA32 binary encoding; for example,
 * several instructions (ADD, ADC, SUB, AND, OR, XOR) can be
 * classified as binary accumulators that share a common set of
 * permitted addressing modes and binary encoding all the way down a
 * special case for enconding operands EAX and an immediate.  A shell
 * script (genAssembler.sh in the intel assembler source directory)
 * explots this by specifying a generic way of emtting a binary
 * accumulation and then calling it for each specific opcode that fits
 * that format.  These generated methods are combined with the
 * hand-coded ones (from VM_Assembler.in, also in the assembler 
 * source directory) as part of the Jikes RVM build process. </P>
 *
 *  <P> This assembler is shared by the baseline and optimizing
 * compilers: it used directly by the baseline compiler, while the
 * optimizing compiler has an {@link OPT_Assembler} that is built on
 * top of this one to match {@link OPT_Instruction}s and {@link
 * OPT_Operator}s to the emit methods this assembler provides.  The
 * {@link OPT_Assembler} is entirely machine-generated, and this
 * requires that the methods for encoding instructions use a stylized
 * naming and signiture convention that is designed to make the method
 * signiture computable from the opcode and the operand types.  The
 * naming convention is as follows:
 *
 * <PRE>
 *   final void emit<EM>opcode</EM>\(_<EM>operand code</EM>\)*[_<EM>size</EM>](\(<EM>operand arguments</EM>\)*)
 * </PRE>
 *
 * where the following substitutions are made:
 * <DL>
 * <DT> <EM>opcode</EM> 
 * <DI> is the opcode of the instruction (e.g. ADC, MOV, etc)
 *
 * <DT> <EM>operand code</EM> 
 * <DI> represents the type of the nth operand:
 *   <DL>
 *   <DT> "Imm"		<DI> immediate operands
 *   <DT> "Reg"		<DI> register operands
 *   <DT> "RegInd"	<DI> register indirect operands
 *   <DT> "RegDisp"	<DI> register displacement
 *   <DT> "RegOff"	<DI> shifted index + displacement
 *   <DT> "RegIdx"	<DI> register base + shifted index + displacement
 *   <DT> "Cond"	<DI> condition codes
 *   </DL>
 *
 * <DT> <EM>size</EM> 
 * <DI> indicates non-word-sized operations
 *   <DL>
 *   <DT> "Byte"	<DI> bytes
 *   <DT> "Word"	<DI> Intel "words" (i.e. 16 bites)
 *   <DT> "Quad"	<DI> quad words (i.e. double-precision floating point)
 *   </DL>
 *
 * <DT> <EM>operand arguments</EM>
 * <DI> are the needed components of the operands, in order
 *  <DL>
 *  <DT> "Imm" 
 *  <DI>
 *    <UL>
 *	<LI> immediate value (int)
 *    </UL>
 *  <DT> "Reg"	
 *  <DI> 
 *    <UL> 
 *	<LI> register number (byte)
 *    </UL>
 *  <DT> "RegInd" 
 *  <DI>
 *    <UL>
 *	<LI> register number (byte)
 *    </UL>
 *  <DT> "RegDisp"
 *  <DI>
 *    <UL>
 *	<LI> register number (byte)
 *	<LI> displacement (int)
 *    </UL>
 *  <DT> "RegOff" 
 *  <DI> 
 *    <UL>
 *	<LI> index register (byte)
 *	<LI> scale (short)
 *	<LI> displacement (int)
 *    </UL>
 *  <DT> "RegIdx" 
 *  <DI>
 *    <UL>
 *	<LI> base register (byte)
 *	<LI> index register (byte)
 *	<LI> scale (short)
 *	<LI> displacement (int)
 *    </UL>
 *  <DT> "Cond" 
 *  <DI>
 *    <UL>
 *	<LI> condition code mask (byte)
 *    </UL>
 *  </DL>
 * </DL>
 *
 * @see OPT_Assembler
 * @see VM_Lister
 * @see VM_ForwardReference
 *
 * @author Julian Dolby
 * @author Bowen Alpern 
*/
class VM_Assembler implements VM_RegisterConstants, VM_AssemblerConstants {
	
  /**
   * dump assemby code as it is generated?
   */	
  static boolean TRACE = false;

  /**
   * The lister object is used to print generated machine code.
   */
  private VM_Lister	 lister;

  /**
   * The array holding the generated binary code.  
   */
  private INSTRUCTION [] machineCodes;

  /**
   * The current end of the generated machine code
   */
  protected int		 mi;	      

  /**
   * Create an assembler with a given machine code buffer size.	 This
   * size is merely a heuristic, because the assembler will expand its
   * buffer if it becomes full.	 This constructor uses the global
   * TRACE to determine whether the assemblewr should dump its
   * generated code
   *
   * @see #TRACE
   *
   * @param initial machine code buffer size.
   */
  VM_Assembler (int bytecodeSize) {
    machineCodes = new INSTRUCTION [bytecodeSize*CODE_EXPANSION_FACTOR + CODE_OVERHEAD_TERM];
    if (TRACE)
	lister = new VM_Lister(this);
    else	
	lister = null;
  }

  /**
   * Create an assembler with a given machine code buffer size and
   * tell it whether or not to print machine code as it generates it.
   * The buffer size is merely a heuristic, because the assembler will
   * expand its buffer if it becomes full. 
   *
   * @param bytecodeSize initial machine code buffer size.
   * @param shouldPrint whether to dump generated machine code.
   */
  VM_Assembler (int bytecodeSize, boolean shouldPrint) {
    machineCodes = new INSTRUCTION [bytecodeSize*CODE_EXPANSION_FACTOR + CODE_OVERHEAD_TERM];
    if (shouldPrint) 
	lister = new VM_Lister(this);
    else
	lister = null;
  }

  /**
   *  Heuristic constant used to calculate initial size of the machine
   * code buffer.  This is an average of how many bytes of generated
   * code come from a given bytecode in the baseline compiler.
   */
  private static final int  CODE_EXPANSION_FACTOR =  12;

  /**
   *  Heuristic constant used to calculate initial size of the machine
   * code buffer.  This is an estimate of the fixed method overhead
   * code generated by the baseline compiler, such as method
   * prologue. 
   */
  private static final int  CODE_OVERHEAD_TERM	  = 100;

  /**
   *  Return the current offset in the generated code buffer of the
   * end of the genertaed machine code.
   *
   * @return the end of the generated machine code.
   */
  int getMachineCodeIndex () {
      return mi;
  }
    
  /**
   *	Set the given byte offset in the machine code array to the
   * given byte value.  This is the low-level function by which the
   * assembler produces binary code into its machine code buffer.
   * This function will resize the underlying machine code array if
   * the index given exceeds the array's length.
   *
   * @param index the byte offset into which to write
   * @param data the byte data value to write
   */
  protected void setMachineCodes(int index, byte data) {
      try {
	  machineCodes[index] = data;
      } catch (ArrayIndexOutOfBoundsException e) {
	  INSTRUCTION [] old = machineCodes;
	  machineCodes = new INSTRUCTION [2 * old.length ];
	  for (int i=0; i<old.length; i++) machineCodes[i] = old[i];
	  machineCodes[index] = data;
      }
  }
    
  /**
   *	Return an array of the generated machine code.	This method
   * returns a copy of the generated code.
   *
   * @return a copy of the generated code.
   */
  INSTRUCTION [] getMachineCodes () {
      INSTRUCTION[] trimmed = new INSTRUCTION [ getMachineCodeIndex() ];
      for(int i = 0; i < getMachineCodeIndex(); i++) 
	  trimmed[i] = machineCodes[i];
      
      return trimmed;
  }
    
  /**
   *  Give the lister a message associated with a particular
   * bytecode.  This is used by the baseline assembler to print the
   * bytecode associated with portions of machine code.  (The
   * optimizing compiler does not do this because its association
   * between bytecodes and generated code is much less direct).
   *
   * @param bytecodeNumber the offset of the current bytecode in the
   *         current method's bytecode array.
   * @param bc a message descriptive of the current bytecode.
   */
  void noteBytecode (int bytecodeNumber, String bc) {
    if (lister != null) lister.noteBytecode(bytecodeNumber, bc);
  }

  /**
   *  inform the lister of a comment related to the currently
   * generated machine code.
   *
   * @param comment a comment string
   */
  void comment (String comment) {
    if (lister != null) lister.comment(mi, comment);
  }

  /**
   *  Print the raw bits of the current instruction.  It takes the
   * start of the instruction as a parameter, and prints from that
   * start to the current machine code index.
   *
   * @see #getMachineCodeIndex
   *
   * @param start the starting index of the last instruction.
   */
  void writeLastInstruction(int start) {
    for (int j=start; j<mi; j++) {
      VM.sysWrite(VM_Lister.hex(machineCodes[j]));
    }
  }

  /**
   *  Find out whether a given signed value can be represented in a
   * given number of bits.
   *
   * @param val the value to be represented
   * @param bits the number of bits to use.
   * @return true if val can be encoded in bits.
   */
  private final static boolean fits (int val, int bits) {
    val = val >> bits-1;
    return (val == 0 || val == -1);
  }

  /**
   *  In the representation of addressing modes in the ModRM and SIB
   * bytes, the code for register-displacement for on ESP has a
   * special meaning.  Thus, when register-displacement mode using ESP
   * is desired, this special SIB (scale-index-base) byte must be
   * emitted. 
   */
  private static final byte SIBforESP = (byte) ((0<<6) + (4<<3) + ESP); // (scale factor 1) no index, ESP is base

  /**
   * Return a ModRM byte encoding a source and destination register
   * (i.e. for a register-register instruction).
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  private byte regRegModRM(byte reg1, byte reg2) {
      return (byte) ((3 << 6) | (reg2 << 3) | reg1);
  }

  /**
   * Return a ModRM byte encoding a source register-32-bit-displacement
   * operand and a destination register.  Note that the displacement
   * is handled separately, and not encoded in the ModRM itself.
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  private byte regDisp32RegModRM(byte reg1, byte reg2) {
      return (byte) ((2 << 6) | (reg2 << 3) | reg1);
  }
	
  /**
   * Return a ModRM byte encoding a source register-8-bit-displacement
   * operand and a destination register.  Note that the displacement
   * is handled separately, and not encoded in the ModRM itself.
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  private byte regDisp8RegModRM(byte reg1, byte reg2) {
      return (byte) ((1 << 6) | (reg2 << 3) | reg1);
  }
	
  /**
   * Return a ModRM byte encoding a source register-indirect
   * operand and a destination register.  
   *
   * @param reg1 the r/m register.
   * @param reg2 the other register or extended opcode.
   * @return the encoded ModRM byte.
   */
  private byte regIndirectRegModRM(byte reg1, byte reg2) {
      return (byte) ((reg2 << 3) | reg1);
  }

  /**	
   *  The more complex IA32 addressing modes require a
   * scale-index-base (SIB) byte.  This is used to encode addressing
   * modes such as [ indexReg \<\< scale + baseReg ].  This method
   * encodes the SIB byte for a given base, index and scale.
   *
   * @param scale the shift amount for the index register value.
   * @param baseReg the base register.
   * @param indexReg the index register.
   * @return the encoded SIB byte.
   */
  private byte sib(short scale, byte baseReg, byte indexReg) {
      return (byte) ((scale << 6) | (indexReg << 3) | baseReg);
  }

  /**
   *  Generate the appropriate bytes into the generated machine code
   * to represent a regsiter-regsiter instruction.
   *
   * @param reg1 the r/m operand.
   * @param reg2 the other register or extended opcode.
   */
  private void emitRegRegOperands(byte reg1, byte reg2) {
      setMachineCodes(mi++, regRegModRM(reg1, reg2));
  }

  /**
   *  Generate the appropriate bytes into the generated machine code
   * to represent a regsiter-32-bit-displacement--regsiter
   * instruction. This method generates the appropriate ModRM, the SIB
   * if needed for the ESP special case, and the little-endian encoded
   * 32 bit displacement.
   *
   * @see #SIBforESP
   *
   * @param reg1 the r/m operand.
   * @param disp the 32 bit displacement.
   * @param reg2 the other register or extended opcode.
   */
  private void emitRegDisp32RegOperands(byte reg1, int disp, byte reg2) {
      setMachineCodes(mi++, regDisp32RegModRM(reg1, reg2));
      if (reg1 == ESP) setMachineCodes(mi++, SIBforESP);
      emitImm32(disp);
  }

  /**
   *  Generate the appropriate bytes into the generated machine code
   * to represent a regsiter-8-bit-displacement--regsiter
   * instruction. This method generates the appropriate ModRM, the SIB
   * if needed for the ESP special case, and the little-endian encoded
   * 32 bit displacement.
   *
   * @see #SIBforESP
   *
   * @param reg1 the r/m operand.
   * @param disp the 8 bit displacement.
   * @param reg2 the other register or extended opcode.
   */
  private void emitRegDisp8RegOperands(byte reg1, byte disp, byte reg2) {
      setMachineCodes(mi++, regDisp8RegModRM(reg1, reg2));
      if (reg1 == ESP) setMachineCodes(mi++, SIBforESP);
      emitImm8(disp);
  }

  /**
   *  Generate the appropriate bytes into the generated machine code
   * to represent a regsiter-displacement--regsiter instruction.  This
   * method simply chooses the appropriate lower-level method based on
   * displacement size
   *
   * @see #emitRegDisp32RegOperands
   * @see #emitRegDisp8RegOperands
   *
   * @param reg1 the r/m operand.
   * @param disp the displacement.
   * @param reg2 the other register or extended opcode.
   */
  private void emitRegDispRegOperands(byte reg1, int disp, byte reg2) {
      if (fits(disp,8))
	  emitRegDisp8RegOperands(reg1, (byte)disp, reg2);
      else
	  emitRegDisp32RegOperands(reg1, disp, reg2);
  }

  /**
   *  Generate the appropriate bytes into the generated machine code
   * to express a register-indirect--register instruction.  This
   * method handles low-level encoding issues, specifically the
   * special cases for register indirect mode on ESP and EBP.  Using
   * ESP requires an SIB byte, and EBP cannot be used in indirect mode
   * at all (that encoding is used to express scaled-index-displacement
   * mode) so this method uses register-displacement with a 0
   * displacement to fake it.
   *
   * @see #emitRegDispRegOperands
   *
   * @param reg1 the r/m operand
   * @param the other register or extended opcode
   */
  private void emitRegIndirectRegOperands(byte reg1, byte reg2) {
      if (reg1 == EBP) {
	  emitRegDispRegOperands(reg1, 0, reg2);
      } else {
	  setMachineCodes(mi++, regIndirectRegModRM(reg1, reg2));
	  if (reg1 == ESP) setMachineCodes(mi++, SIBforESP);
      }
  }

  /**
   *  Generate the appropriate bytes into the generated code to denote
   * a scaled-register+displacement--register instruction.  This
   * expresses the case where the SIB byte is used, but no base
   * register is desired.  This method handles the somewhat convoluted
   * special case used to express this mode (both the r/m register and
   * the base register must be 5).
   *
   * @param index the index register for the r/m operand
   * @param scale the amount to shift the index register
   * @param disp the displacement for the r/m operand
   * @param reg2 the other operand or the extended opcode
   */
  private void emitRegOffRegOperands(byte index, short scale, int disp, byte reg2) {
      setMachineCodes(mi++, regIndirectRegModRM((byte) 0x4, reg2));
      setMachineCodes(mi++, sib(scale, (byte) 0x5, index));
      emitImm32(disp);
  }

  /**
   *  Generate the appropriate bytes into the generated code to denote
   * an absolute-addresss--register instruction.  This
   * expresses the case where the SIB byte is used, but no base and no 
   * index register is desired.  This method handles the somewhat convoluted
   * special case used to express this mode (both the r/m register and
   * the base register must both be 5, and the index must 4; scale can be
   * anything, and we choose 0).
   *
   * @param disp the displacement for the r/m operand
   * @param reg2 the other operand or the extended opcode
   */
  private void emitAbsRegOperands(int disp, byte reg2) {
      setMachineCodes(mi++, regIndirectRegModRM((byte) 0x5, reg2));
      // setMachineCodes(mi++, sib((byte) 0x0, (byte) 0x5, (byte) 0x4));
      emitImm32(disp);
  }

  /**
   *  Generate the full glory of scaled-index-base-displacement
   * addressing to the generated machine code.  This method handles
   * various special cases, mostly choosing the smallest displacement
   * possible.
   *
   * @param base the base register for the r/m operand
   * @param index the index register for the r/m operand
   * @param scale the amount to shift the index register
   * @param disp the displacement for the r/m operand
   * @param reg2 the other operand or the extended opcode
   */
  private void emitSIBRegOperands(byte base, byte index, short scale, int disp, byte reg2) {
      if (VM.VerifyAssertions) VM.assert(index != ESP);
      if (disp == 0 && base != EBP) {
	  setMachineCodes(mi++, regIndirectRegModRM((byte) 0x4, reg2));
	  setMachineCodes(mi++, sib(scale, base, index));
      } else if (fits(disp,8)) {
	  setMachineCodes(mi++, regDisp8RegModRM((byte) 0x4, reg2));
	  setMachineCodes(mi++, sib(scale, base, index));
	  emitImm8((byte)disp);
      } else {
	  setMachineCodes(mi++, regDisp32RegModRM((byte) 0x4, reg2));
	  setMachineCodes(mi++, sib(scale, base, index));
	  emitImm32(disp);
      }
  }

  /**
   *  Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediates into the generated code.
   *
   * @param imm the immediate to generate.
   */
  private void emitImm32(int imm) {
      mi = emitImm32(imm, mi);
  }
    
  /**
   *  Generate the smallest-byte-first IA32 encoding of 16 bit
   * immediates into the generated code.
   *
   * @param imm the immediate to generate.
   */
  private void emitImm16(int imm) {
      mi = emitImm16(imm, mi);
  }
    
  /**
   *  Generate the IA32 encoding of an 8 bit immediate into the
   * generated code. 
   *
   * @param imm the immediate to generate.
   */
  private void emitImm8(int imm) {
      mi = emitImm8(imm, mi);
  }

  /**
   *  Generate the smallest-byte-first IA32 encoding of 16 bit
   * immediates into the generated code at the location specified.
   *
   * @param imm the immediate to generate.
   * @param idx the location in the generated code to write.
   */
  private int emitImm16(int imm, int idx) {
      setMachineCodes(idx++, (byte) ((imm >>  0) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  8) & 0xFF));
      return idx;
  }

  /**
   *  Generate the smallest-byte-first IA32 encoding of 32 bit
   * immediates into the generated code at the location specified.
   *
   * @param imm the immediate to generate.
   * @param idx the location in the generated code to write.
   */
  private int emitImm32(int imm, int idx) {
      setMachineCodes(idx++, (byte) ((imm >>  0) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >>  8) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >> 16) & 0xFF));
      setMachineCodes(idx++, (byte) ((imm >> 24) & 0xFF));
      return idx;
  }
    
  /**
   *  Generate the IA32 encoding of an 8 bit immediate into the
   * generated code at the location specified. 
   *
   * @param imm the immediate to generate.
   * @param idx the location in the generated code to write.
   */
  private int emitImm8(int imm, int idx) {
      setMachineCodes(idx++, (byte) imm);
      return idx;
  }

  /**
   *  Generate a conditional opcode given the base opcode and the
   * condition code desired.  The CMOVcc, SETcc and Jcc families of
   * instructions all have opcodes defined as a base opcode plus some
   * bits representing the condition code.  (of course, FCMOV does not
   * this, since that would be too logical).
   *
   * @param opCode the base opcode to emit
   * @param cond the condition code desired
   */
  private void emitCondOpByte(byte opCode, byte cond) {
      setMachineCodes(mi++, (byte) (opCode | cond));
  }

  /**
   *  Generate a locking prefix word into the generated code.  Locking
   * operations on IA32 are expressed by writing a locking byte before
   * the instruction.
   */
  final void emitLockNextInstruction() {
      setMachineCodes(mi++, (byte) 0xF0);
  }

  /**
   * Generate a patch point into the generated code.
   * (1) force patch point to be 16 bit aligned by optionally
   *     generating a nop.
   * (2) emit a short branch (2 byte) around 3 bytes of nops.
   * (3) If the the code is later patched, we first patch the 3
   *     nop bytes to be the upper 24 bits of a long jump
   *     instruction, then update the 2 bytes of the patch
   *     point to be an unconditional jump with a 32 bit immediate.
   */
  final void emitPatchPoint() {
    if ((mi & 0x1) == 1) {
      emitNOP();
    }
    VM_ForwardReference r = forwardJMP();
    emitNOP();
    emitNOP();
    emitNOP();
    r.resolve(this);
  }

  /**
   * Apply a patch.
   * We expect the following instruction stream:
   *  i1; JMP rel8; NOP; NOP; NOP; i2;
   * where patchOffset is the index of the last NOP.
   * We patch it to be
   *  i1; JMP rel32; i2;
   *
   * @param code        the code array to patch
   * @param patchOffset the offset of the last byte of the patch point
   * @param rel32       the new immediate to use in the branch instruction
   *                    the code patcher is going to lay down before patchOffset
   */
  final static void patchCode(INSTRUCTION[] code,
			      int patchOffset,
			      int rel32) {
    byte p0 = (byte)0xE9;
    byte p1 = (byte) (rel32 & 0x000000ff);
    byte p2 = (byte)((rel32 & 0x0000ff00) >>>  8);
    byte p3 = (byte)((rel32 & 0x00ff0000) >>> 16);
    byte p4 = (byte)((rel32 & 0xff000000) >>> 24);
    if ((patchOffset & 0x2) == 0x2) {
      // (a) lay down p4,p3,p2 one byte at a time
      // (b) pick up the two bytes before p0 and then
      //     lay down b2b1p0p1 as a word.
      code[patchOffset--] = p4;
      code[patchOffset--] = p3;
      code[patchOffset--] = p2;
      patchOffset -= 2; // skip over p1, p0
      byte b1 = code[patchOffset--];
      byte b2 = code[patchOffset];
      int patch = (((int)p1&0xff) << 24) | (((int)p0&0xff) << 16) | 
	          (((int)b1&0xff) << 8)  |  ((int)b2&0xff);
      VM_Magic.setIntAtOffset(code, patchOffset, patch);
    } else {
      // (a) lay down p4
      // (b) lay down p0p1p2p3 as a word
      code[patchOffset--] = p4;
      patchOffset -= 3; // skip over p0p1p2p3
      int patch = (((int)p3&0xff) << 24) | (((int)p2&0xff) << 16) |
        	  (((int)p1&0xff) << 8)  |  ((int)p0&0xff);
      VM_Magic.setIntAtOffset(code, patchOffset, patch);
    }
  }

  /**
   *  Generate a forward JMP instruction into the generated code.
   * This form is used when the compiler wants to hang onto the
   * forward reference object and call resolve on it directly.  These
   * forward references are not handled by the mechanism in the
   * assembler; the client is responsible for calling resolve on the
   * reference when generating the target instruction.  The baseline
   * compiler uses this form for jumps within the machine code for a
   * single bytecode.
   */
  final VM_ForwardReference forwardJMP () {
    int miStart = mi;
    VM_ForwardReference r =  new VM_ForwardReference.ShortBranch(mi);
    setMachineCodes(mi++, (byte) 0xEB);
    mi += 1; // leave space for displacement
    if (lister != null) lister.I(miStart, "JMP", 0);
    return r;
  }

  /**
   *  Generate a forward Jcc instruction into the generated code.
   * This form is used when the compiler wants to hang onto the
   * forward reference object and call resolve on it directly.  These
   * forward references are not handled by the mechanism in the
   * assembler; the client is responsible for calling resolve on the
   * reference when generating the target instruction.  The baseline
   * compiler uses this form for jumps within the machine code for a
   * single bytecode.
   *
   * @param cond the condition code on which to branch
   */
  final VM_ForwardReference forwardJcc (byte cond) {
    int miStart = mi;
    VM_ForwardReference r =  new VM_ForwardReference.ShortBranch(mi);
    setMachineCodes(mi++, (byte) (0x70 + cond));
    mi += 1; // leave space for displacement
    if (lister != null) lister.I(miStart, "J" + CONDITION[cond], 0);
    return r;
  }

  /**
   *  The set of outstanding forward references.  This list is used by
   * the assembler to keep track of all outstanding forward
   * references.  References are put on this list by the emit methods
   * for JMP and Jcc when they find a branch that is going forward.
   * Each reference must understand what instruction it is looking for
   * and how to patch its source instruction.  Then, when the client
   * calls resolveForwardBranches, the assembler searches this list to
   * find branches that match the instruction currently being
   * generated, and calls the resolve method on each one that does.
   *
   *  All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of VM_ForwardReference for more details.
   */
  VM_ForwardReference forwardRefs;

  /**
   *  Resolve all forward branches that have the given target, and
   * make them branch to the instruction currently being generated.
   * Clients of the assembler call this method immediately before they
   * emit the instruction intended to be the target of the given
   * label.
   *
   *  All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of VM_ForwardReference for more details.
   *
   * @param label the forward branch label to resolve
   */
  void resolveForwardReferences (int label) {
    if (forwardRefs == null) return; // premature optimization
    forwardRefs = VM_ForwardReference.resolveMatching(this, forwardRefs, label);
  }

  /**
   *  Make the given unconditional branch branch to the current
   * generated instruction.  It is the client's responsibility to
   * ensure the given source index really does contain an
   * unconditional branch.
   *
   * @param sourceIndex the machine code offset of the unconditional
   *                    branch to patch.
   */
  void patchUnconditionalBranch (int sourceIndex) {
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int relOffset = mi - (sourceIndex+5);
    sourceIndex++; // skip the op code
    emitImm32(relOffset, sourceIndex);
  }

  /**
   *  Make the given conditional branch branch to the current
   * generated instruction.  It is the client's responsibility to
   * ensure the given source index really does contain an
   * conditional branch.
   *
   * @param sourceIndex the machine code offset of the conditional
   *                    branch to patch.
   */
  void patchConditionalBranch (int sourceIndex) {
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int relOffset = mi - (sourceIndex+6);
    sourceIndex += 2; // skip the (two byte) op code
    emitImm32(relOffset, sourceIndex);
  }

  /**
   *  Make the given unconditional branch branch to the current
   * generated instruction.  It is the client's responsibility to
   * ensure the given source index really does contain an
   * unconditional branch.  This instruction requires that the branch
   * have been generated with an 8 bit offset.
   *
   * @param sourceIndex the machine code offset of the unconditional
   *                    branch to patch.
   */
  void patchShortBranch (int sourceIndex) {
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int relOffset = mi - (sourceIndex+2);
    if (VM.VerifyAssertions) VM.assert(fits(relOffset, 8));
    sourceIndex++; // skip the op code
    emitImm8((byte)relOffset, sourceIndex);
  }

  /////////////////////////////////////
  // table switch support /////////////
  /////////////////////////////////////

  /**
   *  <P> An OFFSET instruction is not really an instruction; it is rather
   * an address (of an instruction) that is written into the binary
   * code.  These are used to build a table of addresses for table
   * switches.  The code for tableswitches first captures the current
   * pc, then jumps to that value plus the value from a table of
   * relative offsets indexed by the value of the switch expression. </P>
   *
   *  <P> This mechanism assumes code for emitting tableswitch looks as
   * follows; it is not very nice, but no relocatable IA32 code for such
   * switches is.  Indeed, GCC generates something similar when given
   * -fpic.  Note that default cases must be handled separateky. </P>
   *
   * <PRE>
   *         CALL x ([SP] gets IP of first OFFSET instruction)
   *         OFFSET 0 (case 0 target)
   *         OFFSET 1 (case 1 target)
   *         ...
   *         OFFSET n (case n target)
   *         
   *     -------------------------------
   *
   *     x:  [SP] = [SP] + [ [SP] + case expression value<<2 ]
   *         RET (goes to adjusted location in [SP])
   * </PRE>
   *
   *  <P> The above mechanism means that the RET instruction is
   * effectively a register-indexed relative jump (the whole reason
   * for this mess is that IA32 has no such instruction).  The offset
   * is based on the case expression, and the jump is relative to the
   * instruction following the CALL.  Thus, table offsets must be
   * relative to the start of the table, not their own addresses
   * within it. </P>
   *
   *  <P> Therefore, handling of forward bracnhes is slightly different
   * from the normal case of JMP and Jcc; when a forward branch is
   * found, the current table entry (c) is stored into the table.
   * When the fixup code runs, it uses this index to compute the
   * start of the table, and store the offset of the target
   * instruction relative to that.  Similarly, for backward branches,
   * the case index c is used to find the start of the table to store
   * te appropriate relative offset. </P>
   *
   * @see patchSwitchCase
   *
   * @param c the table entry being emitted (i.e. the value of the
   * switch expression corresponding to this target)
   * @param mTarget the method-relative target offset 
   * @param bTarget the label associated with the branch target instrucion 
   */
  void emitOFFSET_Imm_ImmOrLabel (int c, int mTarget, int bTarget) {
    int miStart = mi;
    if (0 < mTarget) { // resolved (backward) reference 
      int delta = mTarget - (mi - (c<<2));  // delta is from start of table of 4-byte entries (not this entry)
      emitImm32(delta);
      if (lister != null) lister.I(miStart, "DATA", mTarget);
    } else {		// unresolved forward reference
      VM_ForwardReference r =  new VM_ForwardReference.SwitchCase(mi, bTarget);
      forwardRefs = VM_ForwardReference.enqueue(forwardRefs, r);
      emitImm32(c);
      if (lister != null) lister.I(miStart, "DATA", c);
    }
  }

  /**
   *  Patch a tableswitch offset table entry at the given source
   * index.  This method resolves the table entry at the given source
   * index to point to the current instruction.  
   *
   * @see #emitOFFSET_Imm_ImmOrLabel
   *
   * @param sourceIndex the location of the offset to patch
   */
  void patchSwitchCase (int sourceIndex) {
    if (lister != null) lister.comefrom(mi, sourceIndex);
    int c = 0;
    c |= (machineCodes[sourceIndex+0] & 0xFF) <<  0;
    c |= (machineCodes[sourceIndex+1] & 0xFF) <<  8;
    c |= (machineCodes[sourceIndex+2] & 0xFF) << 16;
    c |= (machineCodes[sourceIndex+3] & 0xFF) << 24;  // c = case index
    int delta = mi - (sourceIndex - (c<<2)); // from begining of table of 4-byte entries to here
    setMachineCodes(sourceIndex+0, (byte) ((delta >>  0) & 0xFF));
    setMachineCodes(sourceIndex+1, (byte) ((delta >>  8) & 0xFF));
    setMachineCodes(sourceIndex+2, (byte) ((delta >> 16) & 0xFF));
    setMachineCodes(sourceIndex+3, (byte) ((delta >> 24) & 0xFF));
  }

  /////////////////////////////////////
  // instructions (hand coded)	     //
  /////////////////////////////////////

  /**
   *  Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = src
   * </PRE>
   */
  final void emitCMOV_Cond_Reg_Reg(byte cond, byte dst, byte src) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x40, cond);
      emitRegRegOperands(src, dst);
      if (lister != null) lister.RR(miStart, "CMOV" + CONDITION[cond], dst, src);
  }

  /**
   *  Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [src + disp]
   * </PRE>
   */
  final void emitCMOV_Cond_Reg_RegDisp(byte cond, byte dst, byte src, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x40, cond);
      emitRegDispRegOperands(src, disp, dst);
      if (lister != null) lister.RRD(miStart, "CMOV" + CONDITION[cond], dst, src, disp);
  }

  /**
   *  Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [src]
   * </PRE>
   */
  final void emitCMOV_Cond_Reg_RegInd(byte cond, byte dst, byte src) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x40, cond);
      emitRegIndirectRegOperands(src, dst);
      if (lister != null) lister.RRN(miStart, "CMOV" + CONDITION[cond], dst, src);
  }

  /**
   *  Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [index2<<scale2 + disp2]
   * </PRE>
   */
  final void emitCMOV_Cond_Reg_RegOff(byte cond, byte dst, byte index2, short scale2, int disp2) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x40, cond);
      emitRegOffRegOperands(index2, scale2, disp2, dst);
      if (lister != null) lister.RRFD(miStart, "CMOV" + CONDITION[cond], dst, index2, scale2, disp2);
  }

  /**
   *  Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [disp2]
   * </PRE>
   */
  final void emitCMOV_Cond_Reg_Abs(byte cond, byte dst, int disp2) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x40, cond);
      emitAbsRegOperands(disp2, dst);
      if (lister != null) lister.RRA(miStart, "CMOV" + CONDITION[cond], dst, disp2);
  }

  /**
   *  Conditionally move the source to the destination, i.e.
   * <PRE>
   * if (cond) dst = [base2 + index2<<scale2 + disp2]
   * </PRE>
   */
  final void emitCMOV_Cond_Reg_RegIdx(byte cond, byte dst, byte base2, byte index2, short scale2, int disp2) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x40, cond);
      emitSIBRegOperands(base2, index2, scale2, disp2, dst);
      if (lister != null) lister.RRXD(miStart, "CMOV" + CONDITION[cond], dst, base2, index2, scale2, disp2);
  }

  /**
   *  Set destination to zero or one, if the given condition is false
   * or true, respectively.  That is,
   * <PRE>
   * dst = (cond)? 1: 0
   * </PRE>
   *
   * @param cond the condition to be tested
   * @param dst the destination register
   */
  final void emitSET_Cond_Reg_Byte(byte cond, byte dst) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x90, cond);
      emitRegRegOperands(dst, (byte) 0x00);
      if (lister != null) lister.R(miStart, "SET" + CONDITION[cond], dst);
  }

  final void emitSET_Cond_RegDisp_Byte(byte cond, byte dst, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x90, cond);
      emitRegDispRegOperands(dst, disp, (byte) 0x00);
      if (lister != null) lister.RD(miStart, "SET" + CONDITION[cond], dst, disp);
  }

  final void emitSET_Cond_RegInd_Byte(byte cond, byte dst) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x90, cond);
      emitRegIndirectRegOperands(dst, (byte) 0x00);
      if (lister != null) lister.RN(miStart, "SET" + CONDITION[cond], dst);
  }

  final void emitSET_Cond_RegIdx_Byte(byte cond, byte base, byte index, short scale, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x90, cond);
      emitSIBRegOperands(base, index, scale, disp, (byte) 0x00);
      if (lister != null) lister.RXD(miStart, "SET" + CONDITION[cond], base, index, scale, disp);
  }

  final void emitSET_Cond_RegOff_Byte(byte cond, byte index, short scale, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x90, cond);
      emitRegOffRegOperands(index, scale, disp, (byte) 0x00);
      if (lister != null) lister.RFD(miStart, "SET" + CONDITION[cond], index, scale, disp);
  }

  final void emitSET_Cond_Abs_Byte(byte cond, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      emitCondOpByte((byte)0x90, cond);
      emitAbsRegOperands(disp, (byte) 0x00);
      if (lister != null) lister.RA(miStart, "SET" + CONDITION[cond], disp);
  }

  final void emitIMUL2_Reg_Reg(byte dstReg, byte srcReg) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0xAF);
      emitRegRegOperands(srcReg, dstReg);
      if (lister != null) lister.RR(miStart, "IMUL", dstReg, srcReg);
  }

  final void emitIMUL2_Reg_RegInd(byte dstReg, byte srcReg) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0xAF);
      emitRegIndirectRegOperands(srcReg, dstReg);
      if (lister != null) lister.RRN(miStart, "IMUL", dstReg, srcReg);
  }

  final void emitIMUL2_Reg_RegDisp(byte dstReg, byte srcReg, int srcDisp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0xAF);
      emitRegDispRegOperands(srcReg, srcDisp, dstReg);
      if (lister != null) lister.RRD(miStart, "IMUL", dstReg, srcReg, srcDisp);
  }

  final void emitIMUL2_Reg_RegOff(byte dstReg, byte srcIndex, short scale, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0xAF);
      emitRegOffRegOperands(srcIndex, scale, disp, dstReg);
      if (lister != null) lister.RRFD(miStart, "IMUL", dstReg, srcIndex, scale, disp);
  }

  final void emitIMUL2_Reg_Abs(byte dstReg, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0xAF);
      emitAbsRegOperands(disp, dstReg);
      if (lister != null) lister.RRA(miStart, "IMUL", dstReg, disp);
  }

  final void emitIMUL2_Reg_RegIdx(byte dstReg, byte srcBase, byte srcIndex, short scale, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) 0xAF);
      emitSIBRegOperands(srcBase, srcIndex, scale, disp, dstReg);
      if (lister != null) lister.RRXD(miStart, "IMUL", dstReg, srcBase, srcIndex, scale, disp);
  }

  final void emitIMUL2_Reg_Imm(byte dstReg, int imm) {
      int miStart = mi;
      if (fits(imm,8)) {
	  setMachineCodes(mi++, (byte) 0x6B);
	  emitRegRegOperands(dstReg, dstReg);
	  emitImm8((byte)imm);
      } else {
	  setMachineCodes(mi++, (byte) 0x69);
	  emitRegRegOperands(dstReg, dstReg);
	  emitImm32(imm);
      }
      if (lister != null) lister.RI(miStart, "IMUL", dstReg, imm);
  }

  // trap 
  final void emitINT_Imm (int v) {
    if (VM.VerifyAssertions) VM.assert(v <= 0xFF);
    int miStart = mi;
    if (v == 3) { // special case interrupt
      setMachineCodes(mi++, (byte) 0xCC);
    } else {
      setMachineCodes(mi++, (byte) 0xCD);
      setMachineCodes(mi++, (byte) v);
    }
    if (lister != null) lister.I(miStart, "INT", v);
  }

  /**
   *  Conditionally branch to the given target, i.e.
   * <PRE>
   * if (cond) then IP = (instruction @ label)
   * </PRE>
   *
   *  This emit method is expecting only a forward branch (that is
   * what the Label operand means); it creates a VM_ForwardReference
   * to the given label, and puts it into the assembler's list of
   * references to resolve.  This emiiter knows it emits conditional
   * branches, so it uses VM_ForwardReference.ConditionalBranch as the
   * forward reference type to create.
   *
   *  All forward branches have a label as the branch target; clients
   * can arbirarily associate labels and instructions, but must be
   * consistent in giving the chosen label as the target of branches
   * to an instruction and calling resolveForwardBranches with the
   * given label immediately before emitting the target instruction.
   * See the header comments of VM_ForwardReference for more details.
   *
   * @param cond the IA32 ISA condition code bits to mask into opcode
   * @param label the label associated with the branch target instrucion
   *
   * @see VM_ForwardReference.ConditionalBranch 
   */
  final void emitJCC_Cond_Label (byte cond, int label) {
      int miStart = mi;
      VM_ForwardReference r =  new VM_ForwardReference.ConditionalBranch(mi, label);
      forwardRefs = VM_ForwardReference.enqueue(forwardRefs, r);
      setMachineCodes(mi++, (byte) 0x0F);
      setMachineCodes(mi++, (byte) (0x80 + cond));
      mi += 4; // leave space for displacement	TODO!! handle short branches
      if (lister != null) lister.I(miStart, "J" + CONDITION[cond], label);
  }

  /**
   *  Conditionally branch to the given target, i.e.
   * <PRE>
   * if (cond) then IP = mTarget
   * </PRE>
   *
   *  This emit method emits only backward branches (that is what
   * branching to an Imm operand means), so it simply writes the
   * appropriate binary code without bothering with the forward
   * reference mechanism.
   * 
   * @param cond the IA32 ISA condition code bits to mask into opcode
   * @param mTarget the method-relative target offset 
   */
  final void emitJCC_Cond_Imm (byte cond, int mTarget) {
      int miStart = mi;
      int relOffset = mTarget - (mi + 1 + 1); // address relative to next instruction
      if (fits(relOffset, 8)) {
	  emitCondOpByte((byte)0x70, cond);
	  emitImm8((byte)relOffset);
      } else {
	setMachineCodes(mi++, (byte) 0x0F);
	emitCondOpByte((byte)0x80, cond);
	relOffset = mTarget - (mi + 4); // address relative to next instruction
	emitImm32(relOffset);
      }
      if (lister != null) lister.I(miStart, "J" + CONDITION[cond], relOffset);
  }

  /**
   *  Conditionally branch to the given target, i.e.
   * <PRE>
   * if (cond) then IP = mTarget -or- (instruction @ bTarget)
   * </PRE>
   *
   *  This emit method represents a branch that could be either
   * forward or backward; it simply calls either the Label or Imm
   * emit method.
   *
   * @see emitJCC_Cond_Label
   * @see emitJCC_Cond_Imm
   *
   * @param cond the IA32 ISA condition code bits to mask into opcode
   * @param mTarget the method-relative target offset 
   * @param bTarget the label associated with the branch target instrucion
   */
  final void emitJCC_Cond_ImmOrLabel (byte cond, int mTarget, int bTarget) {
    if (mTarget == 0) { // forward branch
	emitJCC_Cond_Label(cond, bTarget);
    } else { // backward branch
	emitJCC_Cond_Imm(cond, mTarget);
    }
  }

  final void emitLEA_Reg_RegDisp(byte dstReg, byte srcReg, int srcDisp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x8D);
      emitRegDispRegOperands(srcReg, srcDisp, dstReg);
      if (lister != null) lister.RRD(miStart, "LEA", dstReg, srcReg, srcDisp);
  }

  final void emitLEA_Reg_RegInd(byte dstReg, byte srcReg) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x8D);
      emitRegIndirectRegOperands(srcReg, dstReg);
      if (lister != null) lister.RRN(miStart, "LEA", dstReg, srcReg);
  }

  final void emitLEA_Reg_RegOff(byte dstReg, byte idx, short scale, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x8D);
      emitRegOffRegOperands(idx, scale, disp, dstReg);
      if (lister != null) lister.RRFD(miStart, "LEA", dstReg, idx, scale, disp);
  }

  final void emitLEA_Reg_Abs(byte dstReg, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x8D);
      emitAbsRegOperands(disp, dstReg);
      if (lister != null) lister.RRA(miStart, "LEA", dstReg, disp);
  }

  final void emitLEA_Reg_RegIdx(byte dstReg, byte base, byte idx, short scale, int disp) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) 0x8D);
      emitSIBRegOperands(base, idx, scale, disp, dstReg);
      if (lister != null) lister.RRXD(miStart, "LEA", dstReg, base, idx, scale, disp);
  }

  final void emitMOV_Reg_Imm(byte dst, int imm) {
      int miStart = mi;
      setMachineCodes(mi++, (byte) (0xB8 | dst));
      emitImm32(imm);
      if (lister != null) lister.RI(miStart, "MOV", dst, imm);
  }

  // pop address and goto it
  final void emitRET () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xC3);
    if (lister != null) lister.OP(miStart, "RET");
  }

  // pop address and goto it, pop parameterBytes additional bytes
  final void emitRET_Imm (int parameterBytes) {
    int miStart = mi;
    if (parameterBytes == 0) {	 
      setMachineCodes(mi++, (byte) 0xC3);
      if (lister != null) lister.OP(miStart, "RET");
    } else {
      setMachineCodes(mi++, (byte) 0xC2);
      emitImm16(parameterBytes);
      if (VM.VerifyAssertions) VM.assert ((parameterBytes & 0xffff0000) == 0); 
      if (lister != null) lister.I(miStart, "RET", parameterBytes);
    }
  }

  // allocate stack frame for procedure
  final void emitENTER_Imm (int frameSize) {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xC8);
    emitImm16(frameSize);
    setMachineCodes(mi++, (byte) 0x0);
    if (lister != null) lister.I(miStart, "ENTER", frameSize);
  }

  // sign extends EAX into EDX
  final void emitCDQ () {
    int miStart = mi;
    setMachineCodes(mi++, (byte)0x99);
    if (lister != null) lister.OP(miStart, "CDQ");
  }

  // edx:eax <- time stamp counter
  // on Linux this appears to be unpriviledged
  final void emitRDTSC() {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x0F);
    setMachineCodes(mi++, (byte) 0x31);
    if (lister != null) lister.OP(miStart, "RDTSC");
  }

  // nop
  final void emitNOP () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0x90);
    if (lister != null) lister.OP(miStart, "NOP");
  }

  ////////////////////////////////////////////
  // hand-coded floating point instructions //
  ////////////////////////////////////////////

    // floating point conditional moves
    final void emitFCMOV_Cond_Reg_Reg(byte cond, byte reg1, byte reg2) {
	int miStart = mi;
	if (VM.VerifyAssertions) VM.assert(reg1 == FP0);
	switch (cond) {
	case LLT:
	    setMachineCodes(mi++, (byte) 0xDA);
	    setMachineCodes(mi++, (byte) (0xC0 + reg2));
	    break;
	case EQ:
	    setMachineCodes(mi++, (byte) 0xDA);
	    setMachineCodes(mi++, (byte) (0xC8 + reg2));
	    break;
	case LLE:
	    setMachineCodes(mi++, (byte) 0xDA);
	    setMachineCodes(mi++, (byte) (0xD0 + reg2));
	    break;
	case U:
	    setMachineCodes(mi++, (byte) 0xDA);
	    setMachineCodes(mi++, (byte) (0xD8 + reg2));
	    break;
	case LGE:
	    setMachineCodes(mi++, (byte) 0xDB);
	    setMachineCodes(mi++, (byte) (0xC0 + reg2));
	    break;
	case NE:
	    setMachineCodes(mi++, (byte) 0xDB);
	    setMachineCodes(mi++, (byte) (0xC8 + reg2));
	    break;
	case LGT:
	    setMachineCodes(mi++, (byte) 0xDB);
	    setMachineCodes(mi++, (byte) (0xD0 + reg2));
	    break;
	case NU:
	    setMachineCodes(mi++, (byte) 0xDB);
	    setMachineCodes(mi++, (byte) (0xD8 + reg2));
	    break;
	default:
	    if (VM.VerifyAssertions) VM.assert(VM.NOT_REACHED);
	}
	if (lister != null) lister.RR(miStart, "FCMOV" + CONDITION[cond], reg1, reg2);
    }

    // floating point push of ST(i) into ST(0)
    final void emitFLD_Reg_Reg(byte destReg, byte srcReg) {
	int miStart = mi;
	if (VM.VerifyAssertions) VM.assert(destReg == FP0);
	setMachineCodes(mi++, (byte) 0xD9);
	setMachineCodes(mi++, (byte) (0xC0 + srcReg));
	if (lister != null) lister.R(miStart, "FLD", srcReg);
    }
    
    // floating point copy of ST(0) into ST(I)
    final void emitFST_Reg_Reg(byte destReg, byte srcReg) {
	int miStart = mi;
	if (VM.VerifyAssertions) VM.assert(srcReg == FP0);
	setMachineCodes(mi++, (byte) 0xDD);
	setMachineCodes(mi++, (byte) (0xD0 + destReg));
	if (lister != null) lister.R(miStart, "FST", destReg);
    }
    
    // floating point pop of ST(0) into ST(I)
    final void emitFSTP_Reg_Reg(byte destReg, byte srcReg) {
	int miStart = mi;
	if (VM.VerifyAssertions) VM.assert(srcReg == FP0);
	setMachineCodes(mi++, (byte) 0xDD);
	setMachineCodes(mi++, (byte) (0xD8 + destReg));
	if (lister != null) lister.R(miStart, "FST", destReg);
    }
	
  // Change Sign: Top of FPU register stack -= Top og FPU register stack
  final void emitFCHS () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xE0);
    if (lister != null) lister.OP(miStart, "FADD32");
  }


  final void emitFUCOMPP () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xDA);
    setMachineCodes(mi++, (byte) 0xE9);
    if (lister != null) lister.OP(miStart, "FUCOMPP");
  }

  // Store Status Word into AX register/noexecptions
  final void emitFNSTSW () {
    int miStart = mi;
    int relOffset = 0;
    setMachineCodes(mi++, (byte) 0xDF);
    setMachineCodes(mi++, (byte) 0xE0);
    if (lister != null) lister.OP(miStart, "FNSTSW");
  }

  // Store AH into Flags
  final void emitSAHF () {
    int miStart = mi;
    int relOffset = 0;
    setMachineCodes(mi++, (byte) 0x9E);
    if (lister != null) lister.OP(miStart, "SAHF");
  }

  // Real Remainder:
  // Top of FPU register stack <- ST(0) - (Q*ST(1)
  // Q is the interger value obtained from truncating
  // ST(0)/ST(1) toward 0
  final void emitFPREM () {
    int miStart = mi;
    setMachineCodes(mi++, (byte) 0xD9);
    setMachineCodes(mi++, (byte) 0xF8);
    if (lister != null) lister.OP(miStart, "FPREM");
  }

    // Blow away floating point state
    final void emitFINIT() {
	int miStart = mi;
	setMachineCodes(mi++, (byte) 0x9B);
	setMachineCodes(mi++, (byte) 0xDB);
	setMachineCodes(mi++, (byte) 0xE3);
	if (lister != null) lister.OP(miStart, "FINIT");
    }

    // Blow away floating point state
    // Pending exceptions??? Don't tell me about pending exceptions!!
    final void emitFNINIT() {
	int miStart = mi;
	setMachineCodes(mi++, (byte) 0xDB);
	setMachineCodes(mi++, (byte) 0xE3);
	if (lister != null) lister.OP(miStart, "FNINIT");
    }

    // Declare we are no longer using FP register
    final void emitFFREE_Reg(byte reg) {
	int miStart = mi;
	setMachineCodes(mi++, (byte) 0xDD);
	setMachineCodes(mi++, (byte) ( (byte)0xC0 + reg ));
	if (lister != null) lister.R(miStart, "FFREE", reg);
    }

    // The dreaded FXCH
    // (symbol of all that's wrong with Intel floating point :)
    final void emitFXCH_Reg_Reg(byte regOne, byte regTwo) {
	int miStart = mi;

	// at least one reg must not be FP0
	byte nonZeroReg = FP0; // :)
	if (regOne == FP0 && regTwo == FP0) 
	    // do nothing; this is stupid
	    return;
	else if (regOne == FP0 && regTwo != FP0)
	    nonZeroReg = regTwo;
	else if (regTwo == FP0 && regOne != FP0)
	    nonZeroReg = regOne;

	// if not, bad instruction, so die
	if (nonZeroReg == FP0)
	    VM.assert(false, "FXCH of " + regOne + ", " + regTwo);

	// generate it, with special case (of course) for FP1
	setMachineCodes(mi++, (byte) 0xD9);
	if (nonZeroReg == FP1)
	    setMachineCodes(mi++, (byte) 0xC9);
	else 
	    setMachineCodes(mi++, (byte) (0xC8 | nonZeroReg));

	// list it
	if (lister != null) lister.R(miStart, "FXCH", nonZeroReg);
    }

    /*
     * BELOW HERE ARE AUTOMATICALLY-GENERATED INSTRUCTIONS.  DO NOT EDIT.
     *
     * These instructions are generated by genAssembler.sh in the
     * src/vm/arch/intel/assembler directory.  Please make all needed
     * edits to that script.
     */
