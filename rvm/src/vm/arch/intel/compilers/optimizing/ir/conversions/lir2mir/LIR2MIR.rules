#
# (C) Copyright IBM Corp. 2001
#
#//$Id$
#
# @author Dave Grove
#
# BURS rules for IA32 architecture
#
# The format of PRODUCTION is 'non-terminal:	rule'
PRODUCTION
# COST is a Java expression that evaluates to an integer.
# The following conventions are more or less followed:
#   Each instruction generated has a base cost of 10
#   A basic (r,r) or (r,riv) costs 3 more
#   A (m,riv) costs 7
#   A (r,m) costs 5
#   Better basic opcodes (inc instead of add 1) decrease cost by 2
COST
# For definition of FLAGS bits see BURS_TreeNode.java
FLAGS
# Code
TEMPLATE

##################################
# Definitions of non-terminals and
# mapping of leaves into non-terminals
##################################
# the non-terminal r can be mapped to non-terminal stm at no cost
stm:	r
0
NOFLAGS
// No code emitted

# the terminal REGISTER maps to non-terminal r
r:	REGISTER
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal r
# czr indicates that (1) a register result is produced
# and (2) as a side-effect of producing that result the condition registers
# are set as if the result was compared to 0.
r:	czr
0
NOFLAGS
// No code emitted

# the nonterminal czr can map to non-terminal cz
# cz indicates that the condition registers like a compare instruction
cz:	czr
0
NOFLAGS
// No code emitted

# the nonterminal szpr can map to non-terminal r
# szpr indicates that (1) a register result is produced
# and (2) that the condition registers SF, ZF, PF are set based on the result.
# are set as if the result was compared to 0.
r:	szpr
0
NOFLAGS
// No code emitted

# the nonterminal szpr can map to non-terminal szp
# szp indicates that the condition registers SF, ZF, PF are set.
szp:	szpr
0
NOFLAGS
// No code emitted

# the terminal INT_CONSTANT maps to non-terminal iv
iv:	INT_CONSTANT
0
NOFLAGS
// No code emitted

# the terminal MINUS_ONE can map to non-terminal iv
iv:	MINUS_ONE
0
NOFLAGS
// No code emitted

# the terminal ZERO can map to non-terminal iv
iv:	ZERO
0
NOFLAGS
// No code emitted

# the terminal ONE can map to non-terminal iv
iv:	ONE
0
NOFLAGS
// No code emitted

# the terminal LONG_CONSTANT maps to non-terminal lv
lv:	LONG_CONSTANT
0
NOFLAGS
// No code emitted

# the non-terminal riv is either an r or an iv
riv:	r
0
NOFLAGS
// No code emitted

riv:	iv
0
NOFLAGS
// No code emitted

# the non-terminal rlv is either an r or an lv
rlv:	r
0
NOFLAGS
// No code emitted

rlv:	lv
0
NOFLAGS
// No code emitted

# calls can have any number of arguments and we don't care what they are.
arg:	NULL
0
NOFLAGS
// No code emitted

arg:	riv
0
NOFLAGS
// No code emitted

arg:	lv
0
NOFLAGS
// No code emitted

arg:	OTHER_OPERAND(arg, arg)
0
NOFLAGS
// No code emitted

##################################
# Allow Load/Store instructions to be recognized as potential memory operands 
##################################
sload8:	BYTE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), B));

sload8:	BYTE_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), B_S, B));

uload8:	UBYTE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), B));

uload8:	UBYTE_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), B_S, B));

load8:	sload8
0
NOFLAGS
// no code emitted

load8:	uload8
0
NOFLAGS
// no code emitted

sload16: SHORT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), W));

sload16: SHORT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), W_S, W));

uload16: USHORT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), W));

uload16: USHORT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), W_S, W));

load16:	sload16
0
NOFLAGS
// no code emitted

load16:	uload16
0
NOFLAGS
// no code emitted

load32:	INT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), DW));

load32:	INT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), DW_S, DW));

load64:	LONG_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), QW));

load64:	LONG_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), QW_S, QW));

fpload:	FLOAT_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), DW));

fpload:	FLOAT_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), DW_S, DW));

fpload:	DOUBLE_LOAD(riv, riv)
0
EMIT_INSTRUCTION
pushMO(MO_L(P(p), QW));

fpload:	DOUBLE_ALOAD(r, riv)
0
EMIT_INSTRUCTION
pushMO(MO_AL(P(p), QW_S, QW));

fpload:	MATERIALIZE_FP_CONSTANT(riv)
0
EMIT_INSTRUCTION
pushMO(MO_MC(P(p)));

##################################
# Various integer computations for pointer arithmetic
##################################
address1scaledreg:	address1reg
0
NOFLAGS
//nothing to do

address:	address1scaledreg
0
NOFLAGS
//nothing to do

address1reg:	INT_ADD_ACC(r, iv)
0
EMIT_INSTRUCTION
pushAddress(BinaryAcc.getResult(P(p)), null, B_S, IV(BinaryAcc.getValue(P(p))));

address:	INT_ADD_ACC(r, r)
0
EMIT_INSTRUCTION
pushAddress(BinaryAcc.getResult(P(p)), R(BinaryAcc.getValue(P(p))), B_S, 0);

address1reg:	INT_ADD_ACC(address1reg, iv)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address1scaledreg:	INT_SHL_ACC(r,iv)
LEA_SHIFT(BinaryAcc.getValue(P(p)), 0)
EMIT_INSTRUCTION
pushAddress(null, BinaryAcc.getResult(P(p)), LEA_SHIFT(BinaryAcc.getValue(P(p))), 0);

address1scaledreg:	INT_SHL_ACC(INT_MOVE(r),iv)
LEA_SHIFT(BinaryAcc.getValue(P(p)), 0)
EMIT_INSTRUCTION
pushAddress(null, R(Move.getVal(PL(p))), LEA_SHIFT(BinaryAcc.getValue(P(p))), 0);

address1scaledreg:	INT_ADD_ACC(address1scaledreg, iv)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address:	INT_ADD_ACC(r, address1scaledreg)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getResult(P(p)));

address:	INT_ADD_ACC(address1scaledreg, r)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address:	INT_ADD_ACC(address1scaledreg, iv)
0
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p)));

address:	INT_ADD_ACC(address1scaledreg, address1reg)
0
EMIT_INSTRUCTION
combineAddresses();

address:	INT_ADD_ACC(address1reg, address1scaledreg)
0
EMIT_INSTRUCTION
combineAddresses();

##################################
# Some cases where an LEA can replace several add/shift operations
##################################
r:	INT_ADD_ACC(address1scaledreg, r)
20
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p))); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(r, address1scaledreg)
20
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getResult(P(p))); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(address1scaledreg, address1reg)
20
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(address1reg, address1scaledreg)
20
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

r:	INT_ADD_ACC(address, iv)
20
EMIT_INSTRUCTION
augmentAddress(BinaryAcc.getValue(P(p))); \
EMIT(MIR_Lea.mutate(P(p), IA32_LEA, BinaryAcc.getResult(P(p)), consumeAddress(DW, null, null)));

##################################
# A few operators are passed through unchanged
##################################
stm:	RESOLVE
10
EMIT_INSTRUCTION
RESOLVE(burs, P(p));

stm:	IG_PATCH_POINT
10
EMIT_INSTRUCTION
EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));

stm:	UNINT_BEGIN
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	UNINT_END
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_PROLOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_EPILOGUE
10
EMIT_INSTRUCTION
EMIT(P(p));

stm:	YIELDPOINT_BACKEDGE
10
EMIT_INSTRUCTION
EMIT(P(p));

##################################
# One operator is passed through nearly unchanged
##################################
stm:	LOWTABLESWITCH(r)
10
EMIT_INSTRUCTION
LOWTABLESWITCH(burs, P(p));

##################################
# NOPs can simply be dropped
##################################
stm:	NOP
10
NOFLAGS
// drop on floor

##################################
# Materialization of FP constants
##################################
r:	MATERIALIZE_FP_CONSTANT(riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Binary.getResult(P(p)), MO_MC(P(p))));

fp0:	MATERIALIZE_FP_CONSTANT(riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, D(getFPR(0)), MO_MC(P(p))));

pfp0:	MATERIALIZE_FP_CONSTANT(riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_MC(P(p))));

# Use FLD1/FLDZ to avoid loading from the JTOC
r:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ONE(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLD1, myFP0()));

r:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(riv)
isFPC_ZERO(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLDZ, myFP0()));

# Use FLD1/FLDZ to avoid loading from the JTOC
r:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ONE(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ONE(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLD1, myFP0()));

r:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Binary.getResult(P(p)), myFP0()));

fp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ZERO(P(p), 26)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	MATERIALIZE_FP_CONSTANT(GET_JTOC(r))
isFPC_ZERO(P(p), 11)
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLDZ, myFP0()));

##################################
# Guard/Trap operations
##################################
#####
# GUARD_MOVE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_MOVE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# GUARD_COMBINE
#####
# note: ignoring guard registers, thus no uses
r:	GUARD_COMBINE
11
EMIT_INSTRUCTION
EMIT(P(p));

#####
# NULL_CHECK
#####
stm:	NULL_CHECK(r)
10
EMIT_INSTRUCTION
EMIT(P(p));

#####
# TRAP
#####
stm:	TRAP
10
EMIT_INSTRUCTION
EMIT(MIR_Trap.mutate(P(p), IA32_INT, Trap.getGuardResult(P(p)), Trap.getTCode(P(p))));

#####
# TRAP_IF
#####
stm:	TRAP_IF(riv, iv)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(burs,P(p));

stm:	TRAP_IF(riv, r)
10
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \
                       TrapIf.getGuardResult(P(p)), \
		       TrapIf.getVal1(P(p)), \
		       TrapIf.getVal2(P(p)), \
		       COND(TrapIf.getCond(P(p))), \
		       TrapIf.getTCode(P(p))));

### Memory operands ###
stm:	TRAP_IF(load32, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \
                       TrapIf.getGuardResult(P(p)), \
		       consumeMO(), \
		       TrapIf.getVal2(P(p)), \
		       COND(TrapIf.getCond(P(p))), \
		       TrapIf.getTCode(P(p))));

stm:	TRAP_IF(riv, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, \
                       TrapIf.getGuardResult(P(p)), \
		       TrapIf.getVal1(P(p)), \
	               consumeMO(), \
		       COND(TrapIf.getCond(P(p))), \
		       TrapIf.getTCode(P(p))));

##################################
# Basic Boolean ALU operations 
##################################
#####
# BOOLEAN_NOT_ACC
#####
r:	BOOLEAN_NOT_ACC(r)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, UnaryAcc.getResult(P(p)), I(1)));

### Memory operands ###
stm:	BYTE_STORE(BOOLEAN_NOT_ACC(UBYTE_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_S(P(p), B), I(1)));

stm:	BYTE_ASTORE(BOOLEAN_NOT_ACC(UBYTE_ALOAD(r,riv)),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_AS(P(p), B_S, B), I(1)));

#####
# BOOLEAN_CMP
#####
r:	BOOLEAN_CMP(r,riv)
39
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), \
            BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p)), \
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP(r,riv)
13
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Compare.mutate(P(p), IA32_CMP, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP(r,ZERO)
EQ_NE(BooleanCmp.getCond(P(p)))?37:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal1(P(p)).copy())); \
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp:	BOOLEAN_CMP(r,ZERO)
EQ_NE(BooleanCmp.getCond(P(p)))?11:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)), BooleanCmp.getVal1(P(p)).copy()));

r:	BOOLEAN_CMP(cz, ZERO)
26
EMIT_INSTRUCTION 
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP(cz, ZERO)
0
EMIT_INSTRUCTION 
pushCOND(BooleanCmp.getCond(P(p))); 

r:	BOOLEAN_CMP(szp, ZERO)
EQ_NE(BooleanCmp.getCond(P(p)))?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP(szp, ZERO)
EQ_NE(BooleanCmp.getCond(P(p)))?0:INFINITE
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p)));

## chaining of boolcmps
r:	BOOLEAN_CMP(boolcmp, ONE)
BooleanCmp.getCond(P(p)).isEQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), consumeCOND());

boolcmp:	BOOLEAN_CMP(boolcmp, ONE)
BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE
NOFLAGS
// use already pushed condition

r:	BOOLEAN_CMP(boolcmp, ONE)
BooleanCmp.getCond(P(p)).isNOT_EQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), consumeCOND().flipCode());

boolcmp:	BOOLEAN_CMP(boolcmp, ONE)
BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE
EMIT_INSTRUCTION
pushCOND(consumeCOND().flipCode()); // invert already pushed condition

r:	BOOLEAN_CMP(boolcmp, ZERO)
BooleanCmp.getCond(P(p)).isNOT_EQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), consumeCOND());

boolcmp:	BOOLEAN_CMP(boolcmp, ZERO)
BooleanCmp.getCond(P(p)).isNOT_EQUAL()?26:INFINITE
NOFLAGS
// use already pushed condition

r:	BOOLEAN_CMP(boolcmp, ZERO)
BooleanCmp.getCond(P(p)).isEQUAL()?26:INFINITE
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)), consumeCOND().flipCode());

boolcmp: BOOLEAN_CMP(boolcmp, ZERO)
BooleanCmp.getCond(P(p)).isEQUAL()?26:INFINITE
EMIT_INSTRUCTION
pushCOND(consumeCOND().flipCode()); // invert already pushed condition

### Memory operands ###
r:	BOOLEAN_CMP(load32,riv)
41
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, PL(p), BooleanCmp.getResult(P(p)), \
            consumeMO(), BooleanCmp.getVal2(P(p)), \
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP(load32,riv)
15
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Compare.mutate(PL(p), IA32_CMP, consumeMO(), BooleanCmp.getVal2(P(p)))); 

r:	BOOLEAN_CMP(r,load32)
41
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, PR(p), BooleanCmp.getResult(P(p)), \
            BooleanCmp.getVal1(P(p)), consumeMO(), \
	    BooleanCmp.getCond(P(p)));

boolcmp: BOOLEAN_CMP(r,load32)
15
EMIT_INSTRUCTION
pushCOND(BooleanCmp.getCond(P(p))); \
EMIT(MIR_Compare.mutate(PR(p), IA32_CMP, BooleanCmp.getVal1(P(p)), consumeMO()));

stm:	BYTE_STORE(boolcmp, OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Set.mutate(P(p), IA32_SET$B, MO_S(P(p),B), COND(consumeCOND())));

stm:	BYTE_ASTORE(boolcmp, OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Set.mutate(P(p), IA32_SET$B, MO_AS(P(p),B_S,B), COND(consumeCOND())));

##################################
# Conditional moves
##################################
r:	CMOV(r, OTHER_OPERAND(riv, arg))
(13 + 30)
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), CondMove.getVal1(P(p)), CondMove.getVal2(P(p))); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(r, OTHER_OPERAND(ZERO, arg))
EQ_NE(CondMove.getCond(P(p)))?(11 + 30):INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, CondMove.getVal1(P(p)), CondMove.getVal1(P(p)).copy())); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
r:	CMOV(load8, OTHER_OPERAND(iv, arg))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), consumeMO(), CondMove.getVal2(P(p))); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r:	CMOV(uload8, OTHER_OPERAND(r, arg))
(15 + 30)
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), consumeMO(), CondMove.getVal2(P(p))); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
r:	CMOV(r, OTHER_OPERAND(uload8, arg))
(15 + 30)
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), consumeMO(), CondMove.getVal2(P(p))); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(sload16, OTHER_OPERAND(iv, arg))
FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), consumeMO(), CondMove.getVal2(P(p))); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(load32, OTHER_OPERAND(riv, arg))
(15 + 30)
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), consumeMO(), CondMove.getVal2(P(p))); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(r, OTHER_OPERAND(load32, arg))
(15 + 30)
EMIT_INSTRUCTION
CMOV_CMP(burs, P(p), CondMove.getVal1(P(p)), consumeMO()); \
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((boolcmp, 0/1), tv, fv)
r:	CMOV(boolcmp, OTHER_OPERAND(ZERO, arg))
(CondMove.getCond(P(p)).isNOT_EQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), consumeCOND(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(boolcmp, OTHER_OPERAND(ZERO, arg))
(CondMove.getCond(P(p)).isEQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(boolcmp, OTHER_OPERAND(ONE, arg))
(CondMove.getCond(P(p)).isEQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), consumeCOND(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

r:	CMOV(boolcmp, OTHER_OPERAND(ONE, arg))
(CondMove.getCond(P(p)).isNOT_EQUAL())?(0 + 30):INFINITE
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), consumeCOND().flipCode(), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((cz, 0), tv ,fv); condition code already set
r:	CMOV(cz, OTHER_OPERAND(ZERO, arg))
30 
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

# CMOV((szp, 0), tv ,fv); condition code already set
r:	CMOV(szp, OTHER_OPERAND(ZERO, arg))
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
CMOV_MOV(burs, P(p), CondMove.getResult(P(p)), CondMove.getCond(P(p)), \
         CondMove.getTrueValue(P(p)), CondMove.getFalseValue(P(p)));

##################################
# Basic Integer ALU operations 
##################################
#####
# INT_ADD_ACC
#####
czr:	INT_ADD_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

r:	INT_ADD_ACC(r, ONE)
11 
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, BinaryAcc.getResult(P(p))));

r:	INT_ADD_ACC(r, MINUS_ONE)
11
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, BinaryAcc.getResult(P(p))));

### Memory operands ###
czr:	INT_ADD_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_ADD_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_STORE(INT_ADD_ACC(INT_LOAD(riv,riv),ONE),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_S(P(p), DW)));

stm:	INT_STORE(INT_ADD_ACC(INT_LOAD(riv,riv),MINUS_ONE),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_ADD_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_ADD_ACC(INT_ALOAD(r,riv),ONE),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_AS(P(p), DW_S, DW)));

stm:	INT_ASTORE(INT_ADD_ACC(INT_ALOAD(r,riv),MINUS_ONE),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_AS(P(p), DW_S, DW)));

#####
# INT_SUB_ACC
#####
czr:	INT_SUB_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

r:	INT_SUB_ACC(r, ONE)
11
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, BinaryAcc.getResult(P(p))));

r:	INT_SUB_ACC(r, MINUS_ONE)
11
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, BinaryAcc.getResult(P(p))));

### Memory operands ###
czr:	INT_SUB_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_SUB_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_STORE(INT_SUB_ACC(INT_LOAD(riv,riv),ONE),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_S(P(p), DW)));

stm:	INT_STORE(INT_SUB_ACC(INT_LOAD(riv,riv),MINUS_ONE),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_SUB_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_SUB_ACC(INT_ALOAD(r,riv),ONE),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_DEC, MO_AS(P(p), DW_S, DW)));

stm:	INT_ASTORE(INT_SUB_ACC(INT_ALOAD(r,riv),MINUS_ONE),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 15)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_INC, MO_AS(P(p), DW_S, DW)));

#####
# INT_MUL_ACC
#####
r:	INT_MUL_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_IMUL2, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

### Memory operands ### 
# TODO: consider adding rules for memory operands for INT_MUL_ACC
#####
# INT_DIV
#####
r:	INT_DIV(riv, riv)
52
EMIT_INSTRUCTION
INT_DIVIDES(burs, P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \
	                GuardedBinary.getVal2(P(p)), true);

### Memory operands ### 
# TODO: consider adding rules for memory operands INT_DIV
#####
# INT_REM
#####
r:	INT_REM(riv, riv)
52
EMIT_INSTRUCTION
INT_DIVIDES(burs, P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), \
	                GuardedBinary.getVal2(P(p)), false);

### Memory operands ### 
# TODO: consider adding rules for memory operands for INT_REM
#####
# INT_NEG_ACC
#####
szpr:	INT_NEG_ACC(r)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NEG, UnaryAcc.getResult(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_NEG_ACC(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NEG, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_NEG_ACC(INT_ALOAD(r,riv)),OTHER_OPERAND(r,riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NEG, MO_AS(P(p), DW_S, DW)));

#####
# INT_SHL_ACC
#####
szpr:	INT_SHL_ACC(r, r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, BinaryAcc.getResult(P(p)),  R(getECX())));

szpr:	INT_SHL_ACC(r, iv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_SHL_ACC(INT_LOAD(riv,riv),r),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), R(getECX())));

stm:	INT_STORE(INT_SHL_ACC(INT_LOAD(riv,riv),iv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_SHL_ACC(INT_ALOAD(r,riv),r),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), R(getECX())));

stm:	INT_ASTORE(INT_SHL_ACC(INT_ALOAD(r,riv),iv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_SHR_ACC: 
#####
szpr:	INT_SHR_ACC(r, r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, BinaryAcc.getResult(P(p)), R(getECX())));

szpr:	INT_SHR_ACC(r, iv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_SHR_ACC(INT_LOAD(riv,riv),r),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), R(getECX())));

stm:	INT_STORE(INT_SHR_ACC(INT_LOAD(riv,riv),iv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_SHR_ACC(INT_ALOAD(r,riv),r),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), R(getECX())));

stm:	INT_ASTORE(INT_SHR_ACC(INT_ALOAD(r,riv),iv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_USHR_ACC
#####
szpr:	INT_USHR_ACC(r, r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, BinaryAcc.getResult(P(p)), R(getECX())));

szpr:	INT_USHR_ACC(r, iv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_USHR_ACC(INT_LOAD(riv,riv),r),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), R(getECX())));

stm:	INT_STORE(INT_USHR_ACC(INT_LOAD(riv,riv),iv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_USHR_ACC(INT_ALOAD(r,riv),r),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 27)
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, R(getECX()), BinaryAcc.getValue(PL(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), R(getECX())));

stm:	INT_ASTORE(INT_USHR_ACC(INT_ALOAD(r,riv),iv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_AND_ACC
#####
szpr:	INT_AND_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

szp:	INT_AND_ACC(r, r)
11
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p))));

### Memory operands ### 
szpr:	INT_AND_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)), consumeMO()));

szp:	INT_AND_ACC(riv, load32)
13
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, BinaryAcc.getResult(P(p)), consumeMO()));

szp:	INT_AND_ACC(load32, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_Test.mutate(P(p), IA32_TEST, BinaryAcc.getValue(P(p)), consumeMO()));

stm:	INT_STORE(INT_AND_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_AND_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_OR_ACC
#####
szpr:	INT_OR_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

### Memory operands ### 
szpr:	INT_OR_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_OR_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_OR_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_OR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_XOR_ACC
#####
szpr:	INT_XOR_ACC(r, riv)
13
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, BinaryAcc.getResult(P(p)),         \
			  BinaryAcc.getValue(P(p))));

### Memory operands ### 
szpr:	INT_XOR_ACC(r, load32)
15
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, BinaryAcc.getResult(P(p)), consumeMO()));

stm:	INT_STORE(INT_XOR_ACC(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_S(P(p), DW), BinaryAcc.getValue(PL(p))));

stm:	INT_ASTORE(INT_XOR_ACC(INT_ALOAD(r,riv),riv),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_XOR, MO_AS(P(p), DW_S, DW), BinaryAcc.getValue(PL(p))));

#####
# INT_NOT_ACC
#####
r:	INT_NOT_ACC(r)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NOT, UnaryAcc.getResult(P(p))));

### Memory operands ### 
stm:	INT_STORE(INT_NOT_ACC(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NOT, MO_S(P(p), DW)));

stm:	INT_ASTORE(INT_NOT_ACC(INT_ALOAD(r,riv)),OTHER_OPERAND(r, riv))
ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_NOT, MO_AS(P(p), DW_S, DW)));

##################################
# Basic Floating-Point ALU operations 
##################################
#####
# FP_ADD (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_ADD(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FADD, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_ADD(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FADD, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_ADD(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FADD, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_ADD(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FADD, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_ADD(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FADDP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_ADD(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FADDP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_ADD(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_ADD(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_ADD(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, D(getFPR(0)), consumeMO());

fp0:	FP_ADD(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, D(getFPR(0)), consumeMO());

pfp0:	FP_ADD(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(burs, P(p), IA32_FADD, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_ADD(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_ADD(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_ADD(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, myFP0(), consumeMO());

pfp0:	FP_ADD(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FADD, myFP0(), consumeMO());

r:	FP_ADD(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_ADD(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_ADD(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_ADD(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FADD, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_ADD(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_ADD(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_ADD(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_ADD(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_ADD(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_ADD(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_ADD(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_ADD(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FADD, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_MUL (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_MUL(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FMUL, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_MUL(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FMUL, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_MUL(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FMUL, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_MUL(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FMUL, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_MUL(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FMULP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_MUL(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FMULP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_MUL(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_MUL(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_MUL(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, D(getFPR(0)), consumeMO());

fp0:	FP_MUL(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, D(getFPR(0)), consumeMO());

pfp0:	FP_MUL(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(burs, P(p), IA32_FMUL, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_MUL(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_MUL(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_MUL(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, myFP0(), consumeMO());

pfp0:	FP_MUL(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FMUL, myFP0(), consumeMO());

r:	FP_MUL(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_MUL(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_MUL(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_MUL(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FMUL, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_MUL(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_MUL(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_MUL(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_MUL(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_MUL(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_MUL(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_MUL(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_MUL(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FMUL, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_SUB (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_SUB(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FSUB, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_SUB(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FSUBR, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_SUB(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FSUB, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_SUB(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FSUBR, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_SUB(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FSUBRP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_SUB(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FSUBP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_SUB(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUB, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_SUB(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUBR, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_SUB(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUB, D(getFPR(0)), consumeMO());

fp0:	FP_SUB(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUBR, D(getFPR(0)), consumeMO());

pfp0:	FP_SUB(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(burs, P(p), IA32_FSUB, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_SUB(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUB, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_SUB(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUBR, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_SUB(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUB, myFP0(), consumeMO());

pfp0:	FP_SUB(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FSUBR, myFP0(), consumeMO());

r:	FP_SUB(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FSUB, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_SUB(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FSUBR, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_SUB(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FSUB, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_SUB(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FSUBR, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_SUB(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUBR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_SUB(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUB, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_SUB(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUBR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_SUB(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUB, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_SUB(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUBR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_SUB(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUB, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_SUB(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUBR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_SUB(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FSUB, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_DIV (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_DIV(r, r)
p.child1.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FDIV, Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_DIV(r, r)
p.child2.isREGISTERNode()?43:26
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FDIVR, Binary.getVal2(P(p)), Binary.getVal1(P(p)));

fp0:	FP_DIV(r, fpload)
p.child1.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FDIV, Binary.getVal1(P(p)), consumeMO());

fp0:	FP_DIV(fpload, r)
p.child2.isREGISTERNode()?45:28
EMIT_INSTRUCTION
FP_MOV_OP(burs, P(p), IA32_FDIVR, Binary.getVal2(P(p)), consumeMO());

fp0:	FP_DIV(pfp0, r)
p.child2.isREGISTERNode()?48:31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FDIVRP, Binary.getVal2(P(p)), myFP0());

fp0:	FP_DIV(r, pfp0)
p.child1.isREGISTERNode()?48:31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_MOV_OP(burs, P(p), IA32_FDIVP, Binary.getVal1(P(p)), myFP0());

fp0:	FP_DIV(fp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIV, D(getFPR(0)), Binary.getVal2(P(p)));

fp0:	FP_DIV(r, fp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIVR, D(getFPR(0)), Binary.getVal1(P(p)));

fp0:	FP_DIV(fp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIV, D(getFPR(0)), consumeMO());

fp0:	FP_DIV(fpload, fp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIVR, D(getFPR(0)), consumeMO());

pfp0:	FP_DIV(r, r)
31
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Binary.getVal1(P(p)))); \
FP_OP(burs, P(p), IA32_FDIV, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_DIV(pfp0, r)
13
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIV, myFP0(), Binary.getVal2(P(p)));

pfp0:	FP_DIV(r, pfp0)
13
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIVR, myFP0(), Binary.getVal1(P(p)));

pfp0:	FP_DIV(pfp0, fpload)
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIV, myFP0(), consumeMO());

pfp0:	FP_DIV(fpload, pfp0)
15
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP(burs, P(p), IA32_FDIVR, myFP0(), consumeMO());

r:	FP_DIV(r, r)
p.child1.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FDIV, Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

r:	FP_DIV(r, r)
p.child2.isREGISTERNode()?56:39
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FDIVR, Binary.getResult(P(p)), Binary.getVal2(P(p)), Binary.getVal1(P(p)));

r:	FP_DIV(r, fpload)
p.child1.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FDIV, Binary.getResult(P(p)), Binary.getVal1(P(p)), consumeMO());

r:	FP_DIV(fpload, r)
p.child2.isREGISTERNode()?58:41
EMIT_INSTRUCTION
FP_MOV_OP_MOV(burs, P(p), IA32_FDIVR, Binary.getResult(P(p)), Binary.getVal2(P(p)), consumeMO());

r:	FP_DIV(r, fp0)
26
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIVR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal1(P(p)));

r:	FP_DIV(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIV, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), Binary.getVal2(P(p)));

r:	FP_DIV(fpload, fp0)
28
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIVR, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_DIV(fp0, fpload)
28
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIV, IA32_FMOV, Binary.getResult(P(p)), D(getFPR(0)), consumeMO());

r:	FP_DIV(r, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIVR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal1(P(p)));

r:	FP_DIV(pfp0, r)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIV, IA32_FSTP, Binary.getResult(P(p)), myFP0(), Binary.getVal2(P(p)));

r:	FP_DIV(fpload, pfp0)
31
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIVR, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

r:	FP_DIV(pfp0, fpload)
31
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_OP_MOV(burs, P(p), IA32_FDIV, IA32_FSTP, Binary.getResult(P(p)), myFP0(), consumeMO());

#####
# FP_REM (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_REM(r, r)
39
EMIT_INSTRUCTION
FP_REM(burs, P(p), Binary.getVal1(P(p)), Binary.getVal2(P(p)));

fp0:	FP_REM(fp0, r)
26
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
FP_REM(burs, P(p), Binary.getVal2(P(p)));

r:	FP_REM(r, r)
52
EMIT_INSTRUCTION
OPT_RegisterOperand res = Binary.getResult(P(p)); \
FP_REM(burs, P(p), Binary.getVal1(P(p)), Binary.getVal2(P(p))); \
EMIT(MIR_Move.create(IA32_FMOV, res, F(getFPR(0))));

r:	FP_REM(fp0, r)
52
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
OPT_RegisterOperand res = Binary.getResult(P(p)); \
FP_REM(burs, P(p), Binary.getVal2(P(p))); \
EMIT(MIR_Move.create(IA32_FMOV, res, F(getFPR(0))));

#####
# FP_NEG (handles both float and double; both are 80 bit anyways...)
#####
fp0:	FP_NEG(r)
43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, D(getFPR(0)), Unary.getVal(P(p)))); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, D(getFPR(0))));

fp0:	FP_NEG(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, D(getFPR(0))));

pfp0:	FP_NEG(r)
29
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FLD, myFP0(), Unary.getVal(P(p)))); \
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, myFP0()));

pfp0:	FP_NEG(pfp0)
13
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.mutate(P(p), IA32_FCHS, myFP0()));

r:	FP_NEG(r)
56
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, D(getFPR(0)), Unary.getVal(P(p)))); \
EMIT(MIR_UnaryAcc.create(IA32_FCHS, D(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), D(getFPR(0))));

r:	FP_NEG(fp0)
26
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.create(IA32_FCHS, D(getFPR(0)))); \
EMIT(MIR_Move.create(IA32_FMOV, Unary.getResult(P(p)), D(getFPR(0))));

r:	FP_NEG(pfp0)
31
EMIT_INSTRUCTION
EMIT(MIR_UnaryAcc.create(IA32_FCHS, myFP0())); \
EMIT(MIR_Move.create(IA32_FSTP, Unary.getResult(P(p)), myFP0()));

##################################
# Basic Long ALU operations 
##################################
#####
# LONG_ADD_ACC
#####
r:	LONG_ADD_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_ADD(burs, P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_SUB_ACC
#####
r:	LONG_SUB_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_SUB(burs, P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_MUL_ACC
#####
r:	LONG_MUL_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_MUL(burs, P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_NEG_ACC
#####
r:	LONG_NEG_ACC(r)
23
EMIT_INSTRUCTION
LONG_NEG(burs, P(p), UnaryAcc.getResult(P(p)));

#####
# LONG_SHL_ACC
#####
r:	LONG_SHL_ACC(r, riv)
20
EMIT_INSTRUCTION
EMIT(P(p)); // leave for complex expansion

#####
# LONG_SHR_ACC
#####
r:	LONG_SHR_ACC(r, riv)
20
EMIT_INSTRUCTION
EMIT(P(p)); // leave for complex expansion

#####
# LONG_USHR_ACC
#####
r:	LONG_USHR_ACC(r, riv)
20
EMIT_INSTRUCTION
EMIT(P(p)); // leave for complex expansion

#####
# LONG_AND_ACC
#####
r:	LONG_AND_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_AND(burs, P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_OR_ACC
#####
r:	LONG_OR_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_OR(burs, P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_XOR_ACC
#####
r:	LONG_XOR_ACC(r, rlv)
23
EMIT_INSTRUCTION
LONG_XOR(burs, P(p), BinaryAcc.getResult(P(p)), BinaryAcc.getValue(P(p)));

#####
# LONG_NOT_ACC
#####
r:	LONG_NOT_ACC(r)
23
EMIT_INSTRUCTION
LONG_NOT(burs, P(p), UnaryAcc.getResult(P(p)));

##################################
# Basic Conversion operations
##################################
#####
# INT_2BYTE
#####
r:	INT_2BYTE(r)
32
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$B, Unary.getResult(P(p)), MO_CONV(burs,DW)));

r:	INT_2BYTE(load32)
17
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$B, Unary.getResult(P(p)), consumeMO()));

stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Unary.getVal(PL(p))));

stm:	BYTE_ASTORE(INT_2BYTE(r),OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), Unary.getVal(PL(p))));

#####
# INT_2USHORT
#####
szpr:	INT_2USHORT(r)
23
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, Unary.getResult(P(p)), Unary.getVal(P(p)))); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, Unary.getResult(P(p)), I(0xFFFF)));

szpr:	INT_2USHORT(load32)
25
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, Unary.getResult(P(p)), consumeMO())); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, Unary.getResult(P(p)), I(0xFFFF)));

stm:	SHORT_STORE(INT_2USHORT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getVal(PL(p))));

stm:	SHORT_ASTORE(INT_2USHORT(r), OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getVal(PL(p))));

#####
# INT_2SHORT
#####
r:	INT_2SHORT(r)
32
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$W, Unary.getResult(P(p)), MO_CONV(burs,DW)));

r:	INT_2SHORT(load32)
17
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$W, Unary.getResult(P(p)), consumeMO()));

stm:	SHORT_STORE(INT_2SHORT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getVal(PL(p))));

stm:	SHORT_ASTORE(INT_2SHORT(r), OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getVal(PL(p))));

#####
# INT_2LONG
#####
r:	INT_2LONG(r)
33
EMIT_INSTRUCTION
INT_2LONG(burs, P(p), Unary.getResult(P(p)), Unary.getVal(P(p))); 

r:	INT_2LONG(load32)
33
EMIT_INSTRUCTION
INT_2LONG(burs, P(p), Unary.getResult(P(p)), consumeMO());

#####
# INT_2FP (handles both float and double; both are 80 bit anyways...)
#####
r:	INT_2FP(riv)
48
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(burs,DW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(riv)
48
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(burs,DW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(riv)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(burs,DW)));

r:	INT_2FP(load32)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(load32)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(load32)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FILD, myFP0(), consumeMO()));

r:	INT_2FP(ONE)
31
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(ONE)
31
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLD1, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(ONE)
18
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLD1, myFP0()));

r:	INT_2FP(ZERO)
31
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	INT_2FP(ZERO)
31
EMIT_INSTRUCTION
EMIT(MIR_Nullary.create(IA32_FLDZ, myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	INT_2FP(ZERO)
18
EMIT_INSTRUCTION
EMIT(MIR_Nullary.mutate(P(p), IA32_FLDZ, myFP0()));

#####
# LONG_2FP (handles both float and double; both are 80 bit anyways...)
#####
r:	LONG_2FP(rlv)
53
EMIT_INSTRUCTION
STORE_LONG_FOR_CONV(burs, Unary.getVal(P(p))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(burs,QW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	LONG_2FP(rlv)
53
EMIT_INSTRUCTION
STORE_LONG_FOR_CONV(burs, Unary.getVal(P(p))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(burs,QW))); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	LONG_2FP(rlv)
50
EMIT_INSTRUCTION
STORE_LONG_FOR_CONV(burs, Unary.getVal(P(p))); \
EMIT(MIR_Move.create(IA32_FILD, myFP0(), MO_CONV(burs,QW)));

r:	LONG_2FP(load64)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	LONG_2FP(load64)
33
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FILD, myFP0(), consumeMO())); \
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

pfp0:	LONG_2FP(load64)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FILD, myFP0(), consumeMO()));

#####
# LONG_2INT
#####
r:	LONG_2INT(r)
13
EMIT_INSTRUCTION
OPT_Register lh = burs.ir.regpool.getSecondReg(R(Unary.getVal(P(p))).register); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), R(lh)));

stm:	INT_STORE(LONG_2INT(r), OTHER_OPERAND(riv,riv))
15
EMIT_INSTRUCTION
OPT_Register lh = burs.ir.regpool.getSecondReg(R(Unary.getVal(PL(p))).register); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), R(lh)));

stm:	INT_ASTORE(LONG_2INT(r), OTHER_OPERAND(r,riv))
15
EMIT_INSTRUCTION
OPT_Register lh = burs.ir.regpool.getSecondReg(R(Unary.getVal(PL(p))).register); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), R(lh)));

r:	LONG_2INT(load64)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), consumeMO()));

#####
# FLOAT_2INT
#####
r:	FLOAT_2INT(r)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

r:	FLOAT_2INT(fp0)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), D(getFPR(0)));

r:	FLOAT_2INT(pfp0)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), myFP0());

r:	FLOAT_2INT(fpload)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), consumeMO());

#####
# FLOAT_2DOUBLE
#####
r:	FLOAT_2DOUBLE(r)
p.child1.isREGISTERNode()?30:13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), Unary.getVal(P(p))));

r:	FLOAT_2DOUBLE(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), D(getFPR(0))));

r:	FLOAT_2DOUBLE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Unary.getResult(P(p)), myFP0()));

fp0:	FLOAT_2DOUBLE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

fp0:	FLOAT_2DOUBLE(fp0)
0
NOFLAGS
// nothing to do

pfp0:	FLOAT_2DOUBLE(pfp0)
0
NOFLAGS
// nothing to do

#####
# DOUBLE_2INT
#####
r:	DOUBLE_2INT(r)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), Unary.getVal(P(p)));

r:	DOUBLE_2INT(fp0)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), D(getFPR(0)));

r:	DOUBLE_2INT(pfp0)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), myFP0());

r:	DOUBLE_2INT(fpload)
30
EMIT_INSTRUCTION
FPR_2INT(burs, P(p), Unary.getResult(P(p)), consumeMO());

#####
# DOUBLE_2FLOAT
#####
r:	DOUBLE_2FLOAT(r)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

r:	DOUBLE_2FLOAT(fp0)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), D(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

r:	DOUBLE_2FLOAT(pfp0)
50
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(burs,DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

fp0:	DOUBLE_2FLOAT(r)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(burs,DW)));

fp0:	DOUBLE_2FLOAT(fp0)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), F(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(burs,DW)));

fp0:	DOUBLE_2FLOAT(pfp0)
50
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(burs,DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(burs,DW)));

pfp0:	DOUBLE_2FLOAT(r)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(burs,DW)));

pfp0:	DOUBLE_2FLOAT(fp0)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), F(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(burs,DW)));

pfp0:	DOUBLE_2FLOAT(pfp0)
40
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(burs,DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(burs,DW)));

stm:	FLOAT_STORE(DOUBLE_2FLOAT(r), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), DW), Unary.getVal(PL(p))));

stm:	FLOAT_ASTORE(DOUBLE_2FLOAT(r), OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), DW_S, DW), Unary.getVal(PL(p))));

stm:	FLOAT_STORE(DOUBLE_2FLOAT(fp0), OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), DW), D(getFPR(0))));

stm:	FLOAT_ASTORE(DOUBLE_2FLOAT(fp0), OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), DW_S, DW), D(getFPR(0))));

stm:	FLOAT_STORE(DOUBLE_2FLOAT(pfp0), OTHER_OPERAND(riv, riv))
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_S(P(p), DW), myFP0()));

stm:	FLOAT_ASTORE(DOUBLE_2FLOAT(pfp0), OTHER_OPERAND(r, riv))
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_AS(P(p), DW_S, DW), myFP0()));

#####
# FLOAT_AS_INT_BITS
#####
r:	FLOAT_AS_INT_BITS(r)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

r:	FLOAT_AS_INT_BITS(fp0)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, MO_CONV(burs,DW), F(getFPR(0)))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

r:	FLOAT_AS_INT_BITS(pfp0)
35
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FSTP, MO_CONV(burs,DW), myFP0())); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

#####
# DOUBLE_AS_LONG_BITS
#####
# TODO: rules to consume fp0, pfp0, fpload
r:	DOUBLE_AS_LONG_BITS(r)
45
EMIT_INSTRUCTION
FPR2GPR_64(burs, P(p));

#####
# INT_BITS_AS_FLOAT
#####
r:	INT_BITS_AS_FLOAT(riv)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), MO_CONV(burs,DW)));

fp0:	INT_BITS_AS_FLOAT(riv)
45
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_CONV(burs,DW)));

pfp0:	INT_BITS_AS_FLOAT(riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_MOV, MO_CONV(burs,DW), Unary.getVal(P(p)))); \
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_CONV(burs,DW)));

r:	INT_BITS_AS_FLOAT(load32)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Unary.getResult(P(p)), consumeMO()));

fp0:	INT_BITS_AS_FLOAT(load32)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), consumeMO()));

pfp0:	INT_BITS_AS_FLOAT(load32)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), consumeMO()));

#####
# LONG_BITS_AS_DOUBLE
#####
# TODO: rules to produce fp0, pfp0
#       rules to consume long loads
r:	LONG_BITS_AS_DOUBLE(rlv)
60
EMIT_INSTRUCTION
GPR2FPR_64(burs, P(p));

##################################
# Moves (register to register moves)
##################################
######
# INT_MOVE
######
r:	INT_MOVE(riv)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

# INT_MOVEs can also 'preserve' nonterminals other than r
czr:	INT_MOVE(czr)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

cz:	INT_MOVE(cz)
0
NOFLAGS
//nothing to do

szpr:	INT_MOVE(szpr)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));

szp:	INT_MOVE(szp)
0
NOFLAGS
//nothing to do

address1reg:	INT_MOVE(address1reg)
0
NOFLAGS
//nothing to do

address1scaledreg:	INT_MOVE(address1scaledreg)
0
NOFLAGS
//nothing to do

address:	INT_MOVE(address)
0
NOFLAGS
//nothing to do

sload8:	INT_MOVE(sload8)
0
NOFLAGS
//nothing to do

uload8:	INT_MOVE(uload8)
0
NOFLAGS
//nothing to do

load8:	INT_MOVE(load8)
0
NOFLAGS
//nothing to do

sload16: INT_MOVE(sload16)
0
NOFLAGS
//nothing to do

uload16: INT_MOVE(uload16)
0
NOFLAGS
//nothing to do

load16:	INT_MOVE(load16)
0
NOFLAGS
//nothing to do

load32:	INT_MOVE(load32)
0
NOFLAGS
// nothing to do

load64:	LONG_MOVE(load64)
0
NOFLAGS
// nothing to do

######
# FLOAT_MOVE
######
r:	FLOAT_MOVE(r)
p.child1.isREGISTERNode()?30:13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), Move.getVal(P(p))));

r:	FLOAT_MOVE(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), F(getFPR(0))));

r:	FLOAT_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Move.getResult(P(p)), myFP0()));

fpload:	FLOAT_MOVE(fpload)
0
NOFLAGS
// nothing to do

fp0:	FLOAT_MOVE(fp0)
0
NOFLAGS
// nothing to do

pfp0:	FLOAT_MOVE(pfp0)
0
NOFLAGS
// nothing to do

fp0:	FLOAT_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, F(getFPR(0)), myFP0()));

fpload:	FLOAT_MOVE(fpload)
0
NOFLAGS
// nothing to do

######
# DOUBLE_MOVE
######
r:	DOUBLE_MOVE(r)
p.child1.isREGISTERNode()?30:13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), Move.getVal(P(p))));

r:	DOUBLE_MOVE(fp0)
13
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Move.getResult(P(p)), D(getFPR(0))));

r:	DOUBLE_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, Move.getResult(P(p)), myFP0()));

fpload:	DOUBLE_MOVE(fpload)
0
NOFLAGS
// nothing to do

fp0:	DOUBLE_MOVE(fp0)
13
NOFLAGS
// nothing to do

pfp0:	DOUBLE_MOVE(pfp0)
0
NOFLAGS
// nothing to do

fp0:	DOUBLE_MOVE(pfp0)
18
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, D(getFPR(0)), myFP0()));

fpload:	DOUBLE_MOVE(fpload)
0
NOFLAGS
// nothing to do

#####
# LONG_MOVE
#####
r:	LONG_MOVE(r)
23
EMIT_INSTRUCTION
OPT_Register res1 = Move.getResult(P(p)).register;               \
OPT_Register res2 = burs.ir.regpool.getSecondReg(res1);          \
OPT_Register val1 = Move.getVal(P(p)).asRegister().register;     \
OPT_Register val2 = burs.ir.regpool.getSecondReg(val1);          \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, R(res1), R(val1)));         \
EMIT(MIR_Move.create(IA32_MOV, R(res2), R(val2)));

r:	LONG_MOVE(lv)
21
EMIT_INSTRUCTION
OPT_Register res1 = Move.getResult(P(p)).register;                \
OPT_Register res2 = burs.ir.regpool.getSecondReg(res1);           \
OPT_LongConstantOperand val = L(Move.getVal(P(p)));               \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, R(res1), I(val.upper32()))); \
EMIT(MIR_Move.create(IA32_MOV, R(res2), I(val.lower32())));

##################################
# Loads (memory to register moves)
##################################
#####
# GET_CURRENT_PROCESSOR (TODO: generalize)
#####
r:	GET_CURRENT_PROCESSOR
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Nullary.getResult(P(p)), R(getESI())));

#####
# GET_JTOC
#####
r:	GET_JTOC(r)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), \
                     MO_BD(Unary.getVal(P(p)), VM_Entrypoints.jtocField.getOffset(), DW, null, null)));

#####
# BYTE_LOAD
#####
r:	BYTE_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$B, Load.getResult(P(p)), MO_L(P(p), B)));

#####
# BYTE_ALOAD
#####
r:	BYTE_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));

#####
# UBYTE_LOAD
#####
r:	UBYTE_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$B, Load.getResult(P(p)), MO_L(P(p), B)));

#####
# UBYTE_ALOAD
#####
r:	UBYTE_ALOAD(r, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));

#####
# other load8 patterns
#####
# load8 & 0xff ===> uload8
r:	INT_AND_ACC(load8, iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && IV(BinaryAcc.getValue(P(p))) == 0xff)?15:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$B, BinaryAcc.getResult(P(p)), consumeMO()));

# load8 & 0x000000ab ===> uload8 & 0x000000ab
r:	INT_AND_ACC(load8, iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && I(BinaryAcc.getValue(P(p))).upper24() == 0)?25:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.create(IA32_MOVZX$B, BinaryAcc.getResult(P(p)), consumeMO())); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)).copyD2D(), BinaryAcc.getValue(P(p))));

# load8 << 24 >>> 24 ===> uload8
r:	INT_USHR_ACC(INT_MOVE(INT_SHL_ACC(load8, iv)), iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && IV(BinaryAcc.getValue(P(p))) == 24 && \
 BinaryAcc.getValue(PLL(p)).isIntConstant() && IV(BinaryAcc.getValue(PLL(p))) == 24)?15:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$B, BinaryAcc.getResult(P(p)), consumeMO()));

# load8 << 24 >>> 24 ===> uload8
r:	INT_USHR_ACC(INT_SHL_ACC(load8, iv), iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && IV(BinaryAcc.getValue(P(p))) == 24 && \
 BinaryAcc.getValue(PL(p)).isIntConstant() && IV(BinaryAcc.getValue(PL(p))) == 24)?15:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$B, BinaryAcc.getResult(P(p)), consumeMO()));

# int2byte(load8) ===> sload8
r:	INT_2BYTE(load8)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$B, Unary.getResult(P(p)), consumeMO()));

#####
# SHORT_LOAD
#####
r:	SHORT_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$W, Load.getResult(P(p)), MO_L(P(p), W)));

#####
# SHORT_ALOAD
#####
r:	SHORT_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));

#####
# USHORT_LOAD
#####
r:	USHORT_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$W, Load.getResult(P(p)), MO_L(P(p), W)));

#####
# USHORT_ALOAD
#####
r:	USHORT_ALOAD(r, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));

#####
# other load16 patterns
#####
# load16 & 0xffff ===> uload16
r:	INT_AND_ACC(load16, iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && IV(BinaryAcc.getValue(P(p))) == 0xffff)?15:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$W, BinaryAcc.getResult(P(p)), consumeMO()));

# load16 & 0x0000abcd ===> uload16 & 0x0000abcd
r:	INT_AND_ACC(load16, iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && I(BinaryAcc.getValue(P(p))).upper16() == 0)?25:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.create(IA32_MOVZX$W, BinaryAcc.getResult(P(p)), consumeMO())); \
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, BinaryAcc.getResult(P(p)).copyD2D(), BinaryAcc.getValue(P(p))));

# load16 << 16 >>> 16 ===> uload16 (_201_compress)
r:	INT_USHR_ACC(INT_MOVE(INT_SHL_ACC(load16, iv)), iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && IV(BinaryAcc.getValue(P(p))) == 16 && \
 BinaryAcc.getValue(PLL(p)).isIntConstant() && IV(BinaryAcc.getValue(PLL(p))) == 16)?15:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$W, BinaryAcc.getResult(P(p)), consumeMO()));

# load16 << 16 >>> 16 ===> uload16 (_201_compress)
r:	INT_USHR_ACC(INT_SHL_ACC(load16, iv), iv)
(BinaryAcc.getValue(P(p)).isIntConstant() && IV(BinaryAcc.getValue(P(p))) == 16 && \
 BinaryAcc.getValue(PL(p)).isIntConstant() && IV(BinaryAcc.getValue(PL(p))) == 16)?15:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$W, BinaryAcc.getResult(P(p)), consumeMO()));

# int2ushort(load16) ===> uload16
r:	INT_2USHORT(load16)
15
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX$W, Unary.getResult(P(p)), consumeMO()));

# int2short(load16) ===> sload16
r:	INT_2USHORT(load16)
20
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX$W, Unary.getResult(P(p)), consumeMO()));

#####
# INT_LOAD
# A few more cases than for other load operators to handle pointer arithmetic introduced by use of magic
#####
r:	INT_LOAD(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), MO_L(P(p), DW)));

r:	INT_LOAD(riv, address1scaledreg)
15
EMIT_INSTRUCTION
augmentAddress(Load.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
		     consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1scaledreg, riv)
15
EMIT_INSTRUCTION
augmentAddress(Load.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1scaledreg, address1reg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address1reg, address1scaledreg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(address, iv)
15
EMIT_INSTRUCTION
augmentAddress(Load.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), \
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));

#####
#INT_ALOAD
#####
r:	INT_ALOAD(r, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));

#####
# FLOAT_LOAD
#####
r:	FLOAT_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Load.getResult(P(p)), MO_L(P(p), DW)));

fp0:	FLOAT_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_L(P(p), DW)));

pfp0:	FLOAT_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_L(P(p), DW)));

#####
# FLOAT_ALOAD
#####
r:	FLOAT_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));

fp0:	FLOAT_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, F(getFPR(0)), MO_AL(P(p), DW_S, DW)));

pfp0:	FLOAT_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_AL(P(p), DW_S, DW)));

#####
# LONG_LOAD
#####
r:	LONG_LOAD(riv, riv)
30
EMIT_INSTRUCTION
OPT_RegisterOperand hres = Load.getResult(P(p)); \
OPT_RegisterOperand lres = R(burs.ir.regpool.getSecondReg(hres.register)); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, MO_L(P(p), DW, DW).copy()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, MO_L(P(p), DW)));

#####
# LONG_ALOAD
#####
r:	LONG_ALOAD(r, riv)
30
EMIT_INSTRUCTION
OPT_RegisterOperand hres = ALoad.getResult(P(p)); \
OPT_RegisterOperand lres = R(burs.ir.regpool.getSecondReg(hres.register)); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, hres, MO_AL(P(p), QW_S, DW, DW).copy()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, lres, MO_AL(P(p), QW_S, DW)));

#####
# DOUBLE_LOAD
#####
r:	DOUBLE_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, Load.getResult(P(p)), MO_L(P(p), QW)));

fp0:	DOUBLE_LOAD(riv, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, D(getFPR(0)), MO_L(P(p), QW)));

pfp0:	DOUBLE_LOAD(riv, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_L(P(p), QW)));

#####
# DOUBLE_ALOAD
#####
r:	DOUBLE_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));

fp0:	DOUBLE_ALOAD(r, riv)
30
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, D(getFPR(0)), MO_AL(P(p), QW_S, QW)));

pfp0:	DOUBLE_ALOAD(r, riv)
20
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FLD, myFP0(), MO_AL(P(p), QW_S, QW)));

#####
# PREPARE (just a normal load on IA32)
#####
r:	PREPARE(riv, riv)
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             MO(Prepare.getAddress(P(p)), Prepare.getOffset(P(p)), DW, \
	                Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE(r, address1scaledreg)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
		     consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE(address1scaledreg, r)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE(address1scaledreg, address1reg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE(address1reg, address1scaledreg)
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE(address, iv)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

r:	PREPARE(iv, address)
15
EMIT_INSTRUCTION
augmentAddress(Prepare.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Prepare.getResult(P(p)), \
	             consumeAddress(DW, Prepare.getLocation(P(p)), Prepare.getGuard(P(p)))));

##################################
# Stores (register to memory moves)
##################################
#####
# Attempt (atomic compare-exchange)
#####
r:	ATTEMPT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
ATTEMPT(burs, Attempt.getResult(P(p)), \
              MO(Attempt.getAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(P(p))); \
ATTEMPT(burs, Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(P(p))); \
ATTEMPT(burs, Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT(burs, Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT(burs, Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT(address, OTHER_OPERAND(iv, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(P(p))); \
ATTEMPT(burs, Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

r:	ATTEMPT(iv, OTHER_OPERAND(address, OTHER_OPERAND(riv, riv)))
67
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(P(p))); \
ATTEMPT(burs, Attempt.getResult(P(p)), \
              consumeAddress(DW, Attempt.getLocation(P(p)), Attempt.getGuard(P(p))), \
              Attempt.getOldValue(P(p)), Attempt.getNewValue(P(p)));

stm:	INT_IFCMP(ATTEMPT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
ATTEMPT_IFCMP(burs, MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address, OTHER_OPERAND(iv, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(iv, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),ZERO)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
ATTEMPT_IFCMP(burs, MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
combineAddresses(); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(address, OTHER_OPERAND(iv, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getOffset(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

stm:	INT_IFCMP(ATTEMPT(iv, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),ONE)
54
EMIT_INSTRUCTION
augmentAddress(Attempt.getAddress(PL(p))); \
ATTEMPT_IFCMP(burs, consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), \
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), \
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));

#####
# BYTE_STORE
#####
stm:	BYTE_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Store.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	BYTE_STORE(load8, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = burs.ir.regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, R(tmp), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), R(tmp)));

#####
# BYTE_ASTORE
#####
stm:	BYTE_ASTORE(riv, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), AStore.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	BYTE_ASTORE(load8, OTHER_OPERAND(r, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = burs.ir.regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, R(tmp), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), R(tmp)));

#####
# SHORT_STORE
#####
stm:	SHORT_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Store.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	SHORT_STORE(load16, OTHER_OPERAND(riv, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = burs.ir.regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, R(tmp), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), R(tmp)));

#####
# SHORT_ASTORE
#####
stm:	SHORT_ASTORE(riv, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), AStore.getValue(P(p))));

# Can avoid sign/zero extension when we are just doing a transfer of bits 
# from one memory location to another.
stm:	SHORT_ASTORE(load16, OTHER_OPERAND(r, riv))
25
EMIT_INSTRUCTION
OPT_Register tmp = burs.ir.regpool.getInteger(); \
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, R(tmp), consumeMO()))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), R(tmp)));

#####
# INT_STORE
# A few more cases than for other store operators to handle pointer arithmetic introduced by use of magic
#####
stm:	INT_STORE(riv, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(riv, address1scaledreg))
15
EMIT_INSTRUCTION
augmentAddress(Store.getAddress(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, \
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
		     Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, riv))
15
EMIT_INSTRUCTION
augmentAddress(Store.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, \
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
		     Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, address1reg))
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
                    Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address1reg, address1scaledreg))
15
EMIT_INSTRUCTION
combineAddresses(); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
                    Store.getValue(P(p))));

stm:	INT_STORE(riv, OTHER_OPERAND(address, iv))
15
EMIT_INSTRUCTION
augmentAddress(Store.getOffset(P(p))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  \
	             consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), \
		     Store.getValue(P(p))));

#####
# INT_ASTORE
#####
stm:	INT_ASTORE(riv, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));

#####
# FLOAT_STORE
#####
stm:	FLOAT_STORE(r, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), DW), Store.getValue(P(p))));

stm:	FLOAT_STORE(fp0, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_S(P(p), DW), F(getFPR(0))));

stm:	FLOAT_STORE(pfp0, OTHER_OPERAND(riv, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_S(P(p), DW), myFP0()));

#####
# FLOAT_ASTORE
#####
stm:	FLOAT_ASTORE(r, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));

stm:	FLOAT_ASTORE(fp0, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_AS(P(p), DW_S, DW), F(getFPR(0))));

stm:	FLOAT_ASTORE(pfp0, OTHER_OPERAND(r, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_AS(P(p), DW_S, DW), myFP0()));

#####
# LONG_STORE
#####
stm:	LONG_STORE(r, OTHER_OPERAND(riv, riv))
30
EMIT_INSTRUCTION
OPT_RegisterOperand hval = R(Store.getValue(P(p))); \
OPT_RegisterOperand lval = R(burs.ir.regpool.getSecondReg(hval.register)); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_S(P(p), DW, DW).copy(), hval))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), lval));

stm:	LONG_STORE(lv, OTHER_OPERAND(riv, riv))
26
EMIT_INSTRUCTION
OPT_LongConstantOperand val = L(Store.getValue(P(p))); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_S(P(p), DW, DW).copy(), I(val.upper32())))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), I(val.lower32())));

#####
# LONG_ASTORE
#####
stm:	LONG_ASTORE(r, OTHER_OPERAND(r, riv))
30
EMIT_INSTRUCTION
OPT_RegisterOperand hval = R(AStore.getValue(P(p))); \
OPT_RegisterOperand lval = R(burs.ir.regpool.getSecondReg(hval.register)); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), hval))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), lval));

stm:	LONG_ASTORE(lv, OTHER_OPERAND(r, riv))
26
EMIT_INSTRUCTION
OPT_LongConstantOperand val = L(AStore.getValue(P(p))); \
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), I(val.upper32())))); \
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), I(val.lower32())));

#####
# DOUBLE_STORE
#####
stm:	DOUBLE_STORE(r, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_S(P(p), QW), Store.getValue(P(p))));

stm:	DOUBLE_STORE(fp0, OTHER_OPERAND(riv, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_S(P(p), QW), D(getFPR(0))));

stm:	DOUBLE_STORE(pfp0, OTHER_OPERAND(riv, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_S(P(p), QW), myFP0()));

#####
# DOUBLE_ASTORE
#####
stm:	DOUBLE_ASTORE(r, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), IA32_FMOV, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));

stm:	DOUBLE_ASTORE(fp0, OTHER_OPERAND(r, riv))
15
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FST, MO_AS(P(p), QW_S, QW), D(getFPR(0))));

stm:	DOUBLE_ASTORE(pfp0, OTHER_OPERAND(r, riv))
20
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Move.mutate(P(p), IA32_FSTP, MO_AS(P(p), QW_S, QW), myFP0()));

##################################
# Control flow
##################################
#####
# INT_IFCMP
#####
stm:	INT_IFCMP(r,riv)
26
EMIT_INSTRUCTION
IFCMP(burs, P(p), IfCmp.getVal1(P(p)), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(r, ZERO)
EQ_NE(IfCmp.getCond(P(p)))?24:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Test.create(IA32_TEST, IfCmp.getVal1(P(p)), IfCmp.getVal1(P(p)).copy())); \
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# Because uload is only used for booleans (0/1) we can get away
# with this for both signed and unsigned loads.
stm:	INT_IFCMP(load8, iv)
FITS(IfCmp.getVal2(P(p)), 8, 28)
EMIT_INSTRUCTION
IFCMP(burs, P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
stm:	INT_IFCMP(uload8, r)
28
EMIT_INSTRUCTION
IFCMP(burs, P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

# We only use uload8 for boolean values, so if the IR is well-typed,
# then r must contain either 0 or 1 and we can do this.
stm:	INT_IFCMP(r, uload8)
28
EMIT_INSTRUCTION
IFCMP(burs, P(p), IfCmp.getVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(sload16, iv) 
FITS(IfCmp.getVal2(P(p)), 8, 28)
EMIT_INSTRUCTION
IFCMP(burs, P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(load32, riv)
28
EMIT_INSTRUCTION
IFCMP(burs, P(p), consumeMO(), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)));

stm:	INT_IFCMP(r, load32)
28
EMIT_INSTRUCTION
IFCMP(burs, P(p), IfCmp.getVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));

# IfCmp(boolcmp, 0/1)
stm:	INT_IFCMP(boolcmp, ZERO)
(IfCmp.getCond(P(p)).isNOT_EQUAL())?13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, ZERO)
(IfCmp.getCond(P(p)).isEQUAL())?13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND().flipCode()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, ONE)
(IfCmp.getCond(P(p)).isEQUAL())?13:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

stm:	INT_IFCMP(boolcmp, ONE)
(IfCmp.getCond(P(p)).isNOT_EQUAL())?26:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND().flipCode()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(cz, 0); condition code already set
stm:	INT_IFCMP(cz, ZERO)
11
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

# IfCmp(szp, 0); condition code already set
stm:	INT_IFCMP(szp, ZERO)
EQ_NE(IfCmp.getCond(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));

#####
# INT_IFCMP2: TODO interesting rules
#####
stm:	INT_IFCMP2(r,riv)
26
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, IfCmp2.getVal1(P(p)), IfCmp2.getVal2(P(p))))); \
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

stm:	INT_IFCMP2(load32,riv)
28
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), IfCmp2.getVal2(P(p))))); \
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

stm:	INT_IFCMP2(r,load32)
28
EMIT_INSTRUCTION
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, IfCmp2.getVal1(P(p)), consumeMO()))); \
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  \
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getTarget1(P(p)),IfCmp2.getBranchProfile1(P(p)), \
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getTarget2(P(p)), IfCmp2.getBranchProfile2(P(p))));

#####
# LONG_IFCMP
#####
stm:	LONG_IFCMP(rlv,rlv)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# FLOAT_IFCMPL
#####
stm:	FLOAT_IFCMPL(fp0,r)
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPL(r,fp0)
30
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPL(pfp0,r)
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPL(r,pfp0)
35
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPL(r,r)
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPL(r,r)
p.child2.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

#####
# FLOAT_IFCMPG
#####
stm:	FLOAT_IFCMPG(fp0,r)
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPG(r,fp0)
30
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPG(pfp0,r)
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPG(r,pfp0)
35
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPG(r,r)
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	FLOAT_IFCMPG(r,r)
p.child2.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

#####
# DOUBLE_IFCMPL
#####
stm:	DOUBLE_IFCMPL(fp0,r)
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPL(r,fp0)
30
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPL(pfp0,r)
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPL(r,pfp0)
35
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPL(r,r)
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPL(r,r)
p.child2.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

#####
# DOUBLE_IFCMPG
#####
stm:	DOUBLE_IFCMPG(fp0,r)
30
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPG(r,fp0)
30
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPG(pfp0,r)
35
EMIT_INSTRUCTION | RIGHT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPG(r,pfp0)
35
EMIT_INSTRUCTION | LEFT_CHILD_FIRST
EMIT(MIR_Compare.create(IA32_FCOMIP, myFP0(), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPG(r,r)
p.child1.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

stm:	DOUBLE_IFCMPG(r,r)
p.child2.isREGISTERNode()?60:43
EMIT_INSTRUCTION
EMIT(MIR_Move.create(IA32_FMOV, F(getFPR(0)), IfCmp.getVal2(P(p)))); \
EMIT(MIR_Compare.create(IA32_FCOMI, F(getFPR(0)), IfCmp.getVal1(P(p)))); \
IfCmp.getCond(P(p)).flipOperands(); \
EMIT(P(p)); // OPT_ComplexLIR2MIRExpansion will handle rest of the work.

#####
# LONG_CMP
#####
r:	LONG_CMP(rlv,rlv)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# FLOAT_CMPL
#####
r:	FLOAT_CMPL(r,r)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# FLOAT_CMPG
#####
r:	FLOAT_CMPG(r,r)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# DOUBLE_CMPL
#####
r:	DOUBLE_CMPL(r,r)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# DOUBLE_CMPG
#####
r:	DOUBLE_CMPG(r,r)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

#####
# GOTO
#####
stm:	GOTO
11
EMIT_INSTRUCTION
EMIT(MIR_Branch.mutate(P(p), IA32_JMP, Goto.getTarget(P(p))));

##################################
# Calling convention
##################################
#####
# IR_PROLOGUE:
#####
stm:	IR_PROLOGUE
10
EMIT_INSTRUCTION
PROLOGUE(burs, P(p));

#####
# RET
#####
stm:	RETURN(NULL)
13
EMIT_INSTRUCTION
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, null, null));

stm:	RETURN(iv)
11
EMIT_INSTRUCTION
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, Return.getVal(P(p)), null));

stm:	RETURN(r)
13
EMIT_INSTRUCTION
OPT_RegisterOperand ret = R(Return.getVal(P(p)));            \
OPT_RegisterOperand ret2 = null;	                     \
if (ret.type == VM_Type.LongType) {                          \
  ret.type = VM_Type.IntType;                                \
  ret2 = R(burs.ir.regpool.getSecondReg(ret.register));      \
}                                                            \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, ret, ret2)); 

stm:	RETURN(lv)
11
EMIT_INSTRUCTION
OPT_LongConstantOperand val = L(Return.getVal(P(p))); \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, I(val.upper32()), I(val.lower32())));

stm:	RETURN(fp0)
11
EMIT_INSTRUCTION
OPT_RegisterOperand res = Return.getVal(P(p)).isDouble() ? D(getFPR(0)) : F(getFPR(0)); \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, res, null));

stm:	RETURN(pfp0)
26
EMIT_INSTRUCTION
OPT_RegisterOperand res = Return.getVal(P(p)).isDouble() ? D(getFPR(0)) : F(getFPR(0)); \
EMIT(MIR_Move.create(IA32_FSTP, res.copy(), myFP0())); \
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, res, null));

#####
# CALL
#####
r:	CALL(r, arg)
13
EMIT_INSTRUCTION
CALL(burs, P(p), Call.getAddress(P(p)));

# a recursive call that has been optimized to a branch to entry block
r:	CALL(BRANCH_TARGET, arg)
13
EMIT_INSTRUCTION
CALL(burs, P(p), Call.getAddress(P(p)));

r:	CALL(INT_LOAD(riv, riv), arg)
11
EMIT_INSTRUCTION
CALL(burs, P(p), MO_L(PL(p), DW));

r:	SYSCALL(r, arg)
13
EMIT_INSTRUCTION
SYSCALL(burs, P(p), CallSpecial.getAddress(P(p)));

r:	SYSCALL(INT_LOAD(riv, riv), arg)
11
EMIT_INSTRUCTION
SYSCALL(burs, P(p), MO_L(PL(p), DW));

###########
# Rules for exceptions
###########
r:      GET_CAUGHT_EXCEPTION
15
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(burs, P(p));

r:      SET_CAUGHT_EXCEPTION(r)
17
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(burs, P(p));

###########
# Rules for special registers
###########
stm:      ROUND_TO_ZERO
21
EMIT_INSTRUCTION
ROUND_TO_ZERO(burs, P(p));

stm:      CLEAR_FLOATING_POINT_STATE
1
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), IA32_FNINIT));

