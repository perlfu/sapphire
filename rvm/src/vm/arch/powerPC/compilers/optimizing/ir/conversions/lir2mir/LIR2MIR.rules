#
# (C) Copyright IBM Corp. 2001
#
#//ppc.dat
#
#//$Id$
#
# @author Dave Grove
# @author Mauricio J. Serrano
#
# The format of PRODUCTION is 'non-terminal:	rule'
PRODUCTION
# The format of COST is either 'cost' or 'size?cost:INFINITE'
COST
# For definition of FLAGS bits see BURS_TreeNode.java
FLAGS
# Code
TEMPLATE

# *************************************************************************
# *****  GENERAL   32-bit PPC                                         *****
# *****  NOTE: needs to convert 64-bit integer operations to          *****
# *****        corresponding 32-bit before applying this grammar      *****
# *************************************************************************
#
# statement
#stm:	r
#0
#0
#
#
#
# these rules may disappear in the future
# statement (stm) rules
r:	NULL_CHECK(r)
11
EMIT_INSTRUCTION
EMIT(P(p)); 

r:	UNINT_BEGIN
11
EMIT_INSTRUCTION
EMIT(P(p));

r:	UNINT_END
11
EMIT_INSTRUCTION
EMIT(P(p));

r:	NOP
11
EMIT_INSTRUCTION
// drop on floor

#
#    general purpose register(r)
r:	REGISTER
0
NOFLAGS
//return DF;

#
# *************************************************************************
# *****  integer operations                                           *****
# *************************************************************************
#
r:	INT_MOVE(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_MOVE, Move.getResult(P(p)),                    \
                     R(Move.getVal(P(p)))));

r:	INT_MOVE(INT_CONSTANT)
SI16(Move.getVal(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_LDI, Move.getResult(P(p)),                    \
                      Move.getVal(P(p))));

r:	INT_MOVE(INT_CONSTANT)
U16(Move.getVal(P(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_LDIS, Move.getResult(P(p)),                   \
                      SRI(Move.getVal(P(p)), 16)));

r:	INT_MOVE(INT_CONSTANT)
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand one = Move.getVal(P(p));                                       \
   EMIT(MIR_Unary.create(PPC_LDIS, Move.getResult(P(p)), CAU16(one)));        \
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Move.getResult(P(p)),               \
                          Move.getResult(P(p)), CAL16(one)));                 \
}

r:	LONG_MOVE(LONG_CONSTANT)
40
EMIT_INSTRUCTION
LONG_CONSTANT(burs, P(p), Move.getResult(P(p)),                   \
                          L(Move.getVal(P(p))));

r:	LONG_MOVE(r)
22
EMIT_INSTRUCTION
LONG_MOVE(burs, P(p), Move.getResult(P(p)), R(Move.getVal(P(p))));

# note: ignoring guard registers, thus no parameters
r:	GUARD_MOVE
11
EMIT_INSTRUCTION
EMIT(P(p));

# note: ignoring guard registers, thus no parameters
r:	GUARD_COMBINE
11
EMIT_INSTRUCTION
EMIT(P(p));

# add immediate
r:	INT_ADD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_ADD(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADD, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_ADD(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDI, Move.getResult(PR(p)),                    \
                          R(Binary.getVal1(P(p))), CAL16(val)));              \
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),            \
                          Move.getResult(PR(p)), CAU16(val)));                \
}

r:	INT_ADD(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), CAU16(Move.getVal(PR(p)))));

r:	INT_SUB(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SUBF, Binary.getResult(P(p)),                \
                       R(Binary.getVal2(P(p))), Binary.getVal1(P(p))));

r:	INT_SUB(INT_MOVE(INT_CONSTANT),r)
SI16(Move.getVal(PL(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SUBFIC, Binary.getResult(P(p)),              \
                       R(Binary.getVal2(P(p))), Move.getVal(PL(p))));

r:	INT_MUL(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_MULLI, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_MUL(r,r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_MULLW, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_NEG(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_NEG, Unary.getResult(P(p)),                   \
                      Unary.getVal(P(p))));

r:	BOOLEAN_NOT(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Unary.getResult(P(p)),                 \
                       R(Unary.getVal(P(p))), I(1)));

#
r:	INT_AND(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_AND, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_AND(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDIr, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), I(Binary.getVal2(P(p)))));

r:	INT_AND(r,INT_CONSTANT)
MASK(Binary.getVal2(P(p)))?10:INFINITE
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand mask = Binary.getVal2(P(p));                                   \
   EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Binary.getResult(P(p)),          \
                                 R(Binary.getVal1(P(p))), I(0),               \
                                 MB(mask), ME(mask)));                        \
}

r:	INT_AND(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?11:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDISr, Binary.getResult(P(p)),              \
                       R(Binary.getVal1(P(p))), I(OPT_Bits.PPCMaskUpper16(IV(Move.getVal(PR(p)))))));

r:	INT_AND(r,INT_MOVE(INT_CONSTANT))
MASK(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_MASK(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(P(p))), I(Move.getVal(PR(p))));

r:	INT_OR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_OR, Binary.getResult(P(p)),                  \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_OR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORI, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

#
r:	INT_OR(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORIS, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))),                               \
                       SRI(Move.getVal(PR(p)), 16)));

r:	INT_OR(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand c = Move.getVal(PR(p));                                        \
   EMIT(MIR_Binary.create(PPC_ORI, Binary.getResult(P(p)),                    \
                          R(Binary.getVal1(P(p))), ANDI(c, 0xffff)));         \
   EMIT(MIR_Binary.mutate(P(p), PPC_ORIS, Binary.getResult(P(p)),             \
                          Binary.getResult(P(p)), SRI(c, 16)));               \
}

r:	INT_XOR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XOR, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_XOR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_XOR(r,INT_MOVE(INT_CONSTANT))
U16(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_XORIS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))),                               \
                       SRI(Move.getVal(PR(p)), 16)));

r:	INT_NOT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)),                  \
                       R(Unary.getVal(P(p))), Unary.getVal(P(p))));

r:	INT_AND(INT_NOT(r),INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Binary.getResult(P(p)),                 \
                       R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));

r:	INT_NOT(INT_OR(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)),                  \
                       R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	INT_OR(INT_NOT(r),INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Binary.getResult(P(p)),                \
                       R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));

r:	INT_NOT(INT_AND(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Unary.getResult(P(p)),                 \
                       R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	INT_NOT(INT_XOR(r,r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_EQV, Unary.getResult(P(p)),                  \
                       R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p))));

r:	INT_AND(r,INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ANDC, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Unary.getVal(PR(p))));

r:	INT_OR(r,INT_NOT(r))
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_ORC, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Unary.getVal(PR(p))));

# rotate instructions omitted, but may combine SHIFT and AND
r:	INT_USHR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRWI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_USHR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRW, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_SHL(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SLWI, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_SHL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SLW, Binary.getResult(P(p)),                 \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_SHR(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRAWI, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	INT_SHR(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_SRAW, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

# combinations of AND and SHIFT
r:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(Binary.getVal2(P(p)))?10:INFINITE
EMIT_INSTRUCTION
USHR_AND(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Binary.getVal2(P(p))),       \
                     I(Binary.getVal2(PL(p))));

r:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_MOVE(INT_CONSTANT))
POSITIVE_MASK(Move.getVal(PR(p)))?10:INFINITE
EMIT_INSTRUCTION
USHR_AND(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Move.getVal(PR(p))),         \
                     I(Binary.getVal2(PL(p))));

r:	INT_USHR(INT_AND(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(Binary.getVal2(PL(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Binary.getVal2(PL(p))),      \
                     I(Binary.getVal2(P(p))));

r:	INT_USHR(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
POSITIVE_MASK(Move.getVal(PLR(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Move.getVal(PLR(p))),        \
                     I(Binary.getVal2(P(p))));

r:	INT_SHR(INT_AND(r,INT_CONSTANT),INT_CONSTANT)
POSITIVE_MASK(Binary.getVal2(PL(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Binary.getVal2(PL(p))),      \
                     I(Binary.getVal2(P(p))));

r:	INT_SHR(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
POSITIVE_MASK(Move.getVal(PLR(p)))?10:INFINITE
EMIT_INSTRUCTION
AND_USHR(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Move.getVal(PLR(p))),        \
                     I(Binary.getVal2(P(p))));

# combinations of SHIFT and SHIFT
r:	INT_USHR(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
10
EMIT_INSTRUCTION
SHL_USHR(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Binary.getVal2(PL(p))),      \
                     I(Binary.getVal2(P(p))));

r:	INT_SHL(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
10
EMIT_INSTRUCTION
USHR_SHL(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(PL(p))), I(Binary.getVal2(PL(p))),      \
                     I(Binary.getVal2(P(p))));

r:	INT_REM(r,r)
20
EMIT_INSTRUCTION
INT_REM(burs, P(p), GuardedBinary.getResult(P(p)),                       \
                    R(GuardedBinary.getVal1(P(p))), R(GuardedBinary.getVal2(P(p))));

r:	INT_REM(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
INT_REM_IMM(burs, P(p), GuardedBinary.getResult(P(p)),                   \
                        R(GuardedBinary.getVal1(P(p))), Move.getResult(PR(p)),       \
                        I(Move.getVal(PR(p))));

r:	INT_DIV(r,r)
20
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_DIVW, GuardedBinary.getResult(P(p)),  \
                       R(GuardedBinary.getVal1(P(p))), GuardedBinary.getVal2(P(p))));

r:	INT_DIV(r,INT_MOVE(INT_CONSTANT))
20
EMIT_INSTRUCTION
INT_DIV_IMM(burs, P(p), GuardedBinary.getResult(P(p)),                   \
                        R(GuardedBinary.getVal1(P(p))), Move.getResult(PR(p)),\
                        I(Move.getVal(PR(p))));

# *************************************************************************
# *****  long arithmetic                                              *****
# *************************************************************************
#
r:	LONG_ADD(r,r)
20
EMIT_INSTRUCTION
LONG_ADD(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_SUB(r,r)
20
EMIT_INSTRUCTION
LONG_SUB(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_NEG(r)
20
EMIT_INSTRUCTION
LONG_NEG(burs, P(p), Unary.getResult(P(p)),                       \
                     R(Unary.getVal(P(p))));

r:	LONG_AND(r,r)
20
EMIT_INSTRUCTION
LONG_LOG(burs, P(p), PPC_AND, Binary.getResult(P(p)),             \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_OR(r,r)
20
EMIT_INSTRUCTION
LONG_LOG(burs, P(p), PPC_OR, Binary.getResult(P(p)),              \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_XOR(r,r)
20
EMIT_INSTRUCTION
LONG_LOG(burs, P(p), PPC_XOR, Binary.getResult(P(p)),             \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_NOT(r)
20
EMIT_INSTRUCTION
LONG_NOT(burs, P(p), Unary.getResult(P(p)),                       \
                     R(Unary.getVal(P(p))));

r:	LONG_SHL(r,r)
20
EMIT_INSTRUCTION
LONG_SHL(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_SHR(r,r)
20
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansion

r:	LONG_USHR(r,r)
20
EMIT_INSTRUCTION
LONG_USHR(burs, P(p), Binary.getResult(P(p)),                     \
                      R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	LONG_SHL(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
LONG_SHL_IMM(burs, P(p), Binary.getResult(P(p)),                  \
                         R(Binary.getVal1(P(p))), I(Binary.getVal2(P(p))));

r:	LONG_SHR(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
LONG_SHR_IMM(burs, P(p), Binary.getResult(P(p)),                  \
                         R(Binary.getVal1(P(p))), I(Binary.getVal2(P(p))));

r:	LONG_USHR(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
LONG_USHR_IMM(burs, P(p), Binary.getResult(P(p)),                 \
                          R(Binary.getVal1(P(p))), I(Binary.getVal2(P(p))));

r:	LONG_MUL(r,r)
20
EMIT_INSTRUCTION
LONG_MUL(burs, P(p), Binary.getResult(P(p)),                      \
                     R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

# *************************************************************************
# *****  load/store integer                                           *****
# *************************************************************************
#
r:	UBYTE_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LBZ, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
                              Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	UBYTE_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LBZX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

#
r:	BYTE_LOAD(r,INT_CONSTANT)
22
EMIT_INSTRUCTION
BYTE_LOAD(burs, P(p), PPC_LBZ, Load.getResult(P(p)),              \
                      R(Load.getAddress(P(p))), Load.getOffset(P(p)),         \
		      Load.getLocation(P(p)), Load.getGuard(P(p)));

r:	BYTE_LOAD(r,r)
22
EMIT_INSTRUCTION
BYTE_LOAD(burs, P(p), PPC_LBZX, Load.getResult(P(p)),             \
                      R(Load.getAddress(P(p))), Load.getOffset(P(p)),         \
		      Load.getLocation(P(p)), Load.getGuard(P(p)));

r:	INT_AND(BYTE_LOAD(r,r),INT_CONSTANT)
IV(Binary.getVal2(P(p)))==0xff?10:INFINITE
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(PL(p), PPC_LBZX, Binary.getResult(P(p)),        \
                              R(Load.getAddress(PL(p))),                      \
                              Load.getOffset(PL(p)), Load.getLocation(PL(p)), \
                              Load.getGuard(PL(p)))));

r:	INT_AND(BYTE_LOAD(r,INT_CONSTANT),INT_CONSTANT)
IV(Binary.getVal2(P(p)))==0xff?10:INFINITE
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(PL(p), PPC_LBZ, Binary.getResult(P(p)),         \
                              R(Load.getAddress(PL(p))),                      \
                              Load.getOffset(PL(p)), Load.getLocation(PL(p)), \
                              Load.getGuard(PL(p)))));

#
r:	USHORT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LHZ, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	USHORT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LHZX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	SHORT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LHA, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	SHORT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LHAX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

#
r:	INT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LWZ, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(r,INT_MOVE(INT_CONSTANT))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LWZ, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)), CAL16(val),           \
				 Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p)))));                      \
}

r:	INT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LWZX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(INT_ADD(r,r),INT_CONSTANT)
IV(Load.getOffset(P(p)))==0?11:INFINITE
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LWZX, Load.getResult(P(p)),           \
                              R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	INT_LOAD(INT_ADD(r,INT_CONSTANT),INT_CONSTANT)
SI16(IV(Load.getOffset(P(p)))+IV(Binary.getVal2(PL(p))))?14:INFINITE
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LWZ, Load.getResult(P(p)),            \
                              R(Binary.getVal1(PL(p))),                       \
                              I(IV(Load.getOffset(P(p)))+IV(Binary.getVal2(PL(p)))), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	PREPARE(r, r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LWARX, Prepare.getResult(P(p)),   \
	                      R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           \
			      Prepare.getLocation(P(p)),                  \
                              Prepare.getGuard(P(p)))));

#
r:	LONG_LOAD(r,INT_CONSTANT)
21
EMIT_INSTRUCTION
LONG_LOAD_addi(burs, P(p), Load.getResult(P(p)),                  \
                           R(Load.getAddress(P(p))), I(Load.getOffset(P(p))), \
			   Load.getLocation(P(p)), Load.getGuard(P(p))); 

r:      LONG_LOAD(r,INT_MOVE(INT_CONSTANT))
21
EMIT_INSTRUCTION
LONG_LOAD_addis(burs, P(p), Load.getResult(P(p)),                 \
                            R(Load.getAddress(P(p))),                         \
                            R(Load.getOffset(P(p))), I(Move.getVal(PR(p))),   \
		            Load.getLocation(P(p)), Load.getGuard(P(p)));

r:	LONG_LOAD(r,r)
21
EMIT_INSTRUCTION
LONG_LOAD_addx(burs, P(p), Load.getResult(P(p)),                  \
                           R(Load.getAddress(P(p))), R(Load.getOffset(P(p))), \
			   Load.getLocation(P(p)), Load.getGuard(P(p)));

#
# statement (stm) rules
#
r:	BYTE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STB, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
                               Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	BYTE_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STBX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STB, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STBX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

#
r:	SHORT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STH, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	SHORT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STHX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getVal(PL(p))),         \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getVal(PL(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

#
r:	INT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	INT_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PRR(p));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),     \
                                  Move.getResult(PRR(p)), CAL16(val),         \
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p)))));                    \
}

#
r:	INT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STWX, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	INT_STORE(r,OTHER_OPERAND(INT_ADD(r,INT_CONSTANT),INT_CONSTANT))
SI16(IV(Store.getOffset(P(p)))+IV(Binary.getVal2(PRL(p))))?14:INFINITE
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        \
                               R(Binary.getVal1(PRL(p))),                     \
                               I(IV(Store.getOffset(P(p))) +                  \
                               IV(Binary.getVal2(PRL(p)))),                   \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

#
r:	LONG_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
22
EMIT_INSTRUCTION
LONG_STORE_addi(burs, P(p), R(Store.getValue(P(p))),              \
                            R(Store.getAddress(P(p))),                        \
                            I(Store.getOffset(P(p))),                         \
			    Store.getLocation(P(p)),                          \
                            Store.getGuard(P(p)));

r:      LONG_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
LONG_STORE_addis(burs, P(p), R(Store.getValue(P(p))),             \
                             R(Store.getAddress(P(p))),                       \
                             R(Store.getOffset(P(p))),                        \
                             I(Move.getVal(PRR(p))),                          \
			     Store.getLocation(P(p)),                         \
                             Store.getGuard(P(p)));

r:	LONG_STORE(r,OTHER_OPERAND(r,r))
22
EMIT_INSTRUCTION
LONG_STORE_addx(burs, P(p), R(Store.getValue(P(p))),              \
                            R(Store.getAddress(P(p))),                        \
                            R(Store.getOffset(P(p))),                         \
			    Store.getLocation(P(p)),                          \
                            Store.getGuard(P(p)));

# *************************************************************************
# *****  floating point operations                                    *****
# *************************************************************************
#
r:	FLOAT_MOVE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)),                     \
                     R(Move.getVal(P(p)))));

r:	DOUBLE_MOVE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)),                     \
                     R(Move.getVal(P(p)))));

r:	FLOAT_NEG(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)),                  \
                      Unary.getVal(P(p))));

r:	DOUBLE_NEG(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)),                  \
                      Unary.getVal(P(p))));

#      2 operands
r:	FLOAT_ADD(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FADDS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	DOUBLE_ADD(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FADD, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	FLOAT_SUB(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FSUBS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	DOUBLE_SUB(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FSUB, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	FLOAT_MUL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FMULS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	DOUBLE_MUL(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FMUL, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	FLOAT_DIV(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FDIVS, Binary.getResult(P(p)),               \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	DOUBLE_DIV(r,r)
10
EMIT_INSTRUCTION
EMIT(MIR_Binary.mutate(P(p), PPC_FDIV, Binary.getResult(P(p)),                \
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));

r:	FLOAT_REM(r,r)
10
EMIT_INSTRUCTION
DOUBLE_REM(burs, P(p), Binary.getResult(P(p)),                    \
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

r:	DOUBLE_REM(r,r)
10
EMIT_INSTRUCTION
DOUBLE_REM(burs, P(p), Binary.getResult(P(p)),                    \
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))));

##### FMA & ilk.
r: 	FLOAT_ADD(FLOAT_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	DOUBLE_ADD(DOUBLE_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r:	FLOAT_ADD(r, FLOAT_MUL(r,r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             \
			R(Binary.getVal1(PR(p))), R(Binary.getVal2(PR(p))),   \
			R(Binary.getVal1(P(p)))));

r:	DOUBLE_ADD(r, DOUBLE_MUL(r,r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              \
			R(Binary.getVal1(PR(p))), R(Binary.getVal2(PR(p))),   \
			R(Binary.getVal1(P(p)))));

r: 	FLOAT_SUB(FLOAT_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUBS, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	DOUBLE_SUB(DOUBLE_MUL(r, r), r)
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUB, Binary.getResult(P(p)),              \
		        R(Binary.getVal1(PL(p))), R(Binary.getVal2(PL(p))),   \
		        R(Binary.getVal2(P(p)))));

r: 	FLOAT_NEG(FLOAT_ADD(FLOAT_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Binary.getResult(P(p)),            \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r: 	DOUBLE_NEG(DOUBLE_ADD(DOUBLE_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r:	FLOAT_NEG(FLOAT_ADD(r, FLOAT_MUL(r,r)))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Binary.getResult(P(p)),           \
			R(Binary.getVal1(PLR(p))), R(Binary.getVal2(PLR(p))), \
			R(Binary.getVal1(PL(p)))));

r:	DOUBLE_NEG(DOUBLE_ADD(r, DOUBLE_MUL(r,r)))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Binary.getResult(P(p)),            \
			R(Binary.getVal1(PLR(p))), R(Binary.getVal2(PLR(p))),\
			R(Binary.getVal1(PL(p)))));

r: 	FLOAT_NEG(FLOAT_SUB(FLOAT_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUBS, Binary.getResult(P(p)),            \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

r: 	DOUBLE_NEG(DOUBLE_SUB(DOUBLE_MUL(r, r), r))
burs.ir.options.strictFP()?INFINITE:10
EMIT_INSTRUCTION
EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUB, Binary.getResult(P(p)),             \
		        R(Binary.getVal1(PLL(p))), R(Binary.getVal2(PLL(p))), \
		        R(Binary.getVal2(PL(p)))));

#
# convert operations needed
r:	INT_2BYTE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_EXTSB, Unary.getResult(P(p)),                 \
                      Unary.getVal(P(p))));

r:	INT_2USHORT(r)
20
EMIT_INSTRUCTION
EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Unary.getResult(P(p)), null,        \
                              R(Unary.getVal(P(p))), I(0), I(16), I(31)));

r:	INT_2SHORT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_EXTSH, Unary.getResult(P(p)),                 \
                      Unary.getVal(P(p))));

r:	INT_2LONG(r)
20
EMIT_INSTRUCTION
INT_2LONG(burs, P(p), Unary.getResult(P(p)),                      \
                      R(Unary.getVal(P(p)))); // for now

r:	INT_2FLOAT(r)
10
EMIT_INSTRUCTION
INT_2DOUBLE(burs, P(p), Unary.getResult(P(p)),                    \
                        R(Unary.getVal(P(p))));

r:	INT_2DOUBLE(r)
10
EMIT_INSTRUCTION
INT_2DOUBLE(burs, P(p), Unary.getResult(P(p)),                    \
                        R(Unary.getVal(P(p))));

r:	LONG_2INT(r)
10
EMIT_INSTRUCTION
LONG_2INT(burs, P(p), Unary.getResult(P(p)),                      \
                      R(Unary.getVal(P(p))));

r:	FLOAT_2INT(r)
10
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansion

r:	FLOAT_2DOUBLE(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Move.mutate(P(p), PPC_FMR, Unary.getResult(P(p)),                    \
                     R(Unary.getVal(P(p)))));

r:	DOUBLE_2INT(r)
10
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansionLeave

r:	DOUBLE_2FLOAT(r)
10
EMIT_INSTRUCTION
EMIT(MIR_Unary.mutate(P(p), PPC_FRSP, Unary.getResult(P(p)),                  \
                      Unary.getVal(P(p))));

#
# LOAD/STORE FLOATING POINT
#
r:	FLOAT_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:      FLOAT_LOAD(r,INT_MOVE(INT_CONSTANT))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)), CAL16(val),           \
			         Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p)))));                      \
}

r:	FLOAT_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LFSX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:	DOUBLE_LOAD(r,INT_CONSTANT)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),            \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

r:      DOUBLE_LOAD(r,INT_MOVE(INT_CONSTANT))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PR(p));                                      \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)),                   \
                          R(Load.getAddress(P(p))), CAU16(val)));             \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),         \
                                 Move.getResult(PR(p)), CAL16(val),           \
				 Load.getLocation(P(p)),                      \
                                 Load.getGuard(P(p)))));                      \
}

r:	DOUBLE_LOAD(r,r)
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Load.mutate(P(p), PPC_LFDX, Load.getResult(P(p)),           \
                              R(Load.getAddress(P(p))), Load.getOffset(P(p)), \
			      Load.getLocation(P(p)), Load.getGuard(P(p)))));

#
# statement (stm) rules
r:	FLOAT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:      FLOAT_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PRR(p));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),    \
                                  Move.getResult(PRR(p)), CAL16(val),         \
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p)))));                    \
}

r:	FLOAT_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STFSX, R(Store.getValue(P(p))),      \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:	DOUBLE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),       \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

r:      DOUBLE_STORE(r,OTHER_OPERAND(r,INT_MOVE(INT_CONSTANT)))
22
EMIT_INSTRUCTION
{                                                                             \
   OPT_Operand val = Move.getVal(PRR(p));                                     \
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)),                  \
                          R(Store.getAddress(P(p))), CAU16(val)));            \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),    \
                                  Move.getResult(PRR(p)), CAL16(val),         \
				  Store.getLocation(P(p)),                    \
                                  Store.getGuard(P(p)))));                    \
}

r:	DOUBLE_STORE(r,OTHER_OPERAND(r,r))
11
EMIT_INSTRUCTION
EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.mutate(P(p), PPC_STFDX, R(Store.getValue(P(p))),      \
                               R(Store.getAddress(P(p))),                     \
                               Store.getOffset(P(p)),                         \
			       Store.getLocation(P(p)),                       \
                               Store.getGuard(P(p)))));

# *************************************************************************
# *****  calling conventions                                          *****
# *************************************************************************
r:	CALL(r,r)
10
EMIT_INSTRUCTION
CALL(burs, P(p));

r:	NULL
0
NOFLAGS
// do nothing

r:	BRANCH_TARGET
0
NOFLAGS
// do nothing

r:	OTHER_OPERAND(r,r)
0
NOFLAGS
// do nothing

r:	RETURN(NULL)
10
EMIT_INSTRUCTION
RETURN(burs, P(p), null);

r:	RETURN(r)
10
EMIT_INSTRUCTION
RETURN(burs, P(p), Return.getVal(P(p)));

r:	IR_PROLOGUE
11
EMIT_INSTRUCTION
PROLOGUE(burs, P(p));

# *************************************************************************
# *****  compare/branch                                               *****
# *************************************************************************
r:	BOOLEAN_CMP(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
BOOLEAN_CMP_IMM(burs, P(p), BooleanCmp.getResult(P(p)),           \
                            R(BooleanCmp.getVal1(P(p))),                      \
                            I(BooleanCmp.getVal2(P(p))));

r:	BOOLEAN_CMP(r,r)
10
EMIT_INSTRUCTION
BOOLEAN_CMP(burs, P(p), BooleanCmp.getResult(P(p)),               \
                        R(BooleanCmp.getVal1(P(p))),                          \
                        R(BooleanCmp.getVal2(P(p))));

r:	LONG_CMP(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

r:	FLOAT_CMPL(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

r:	FLOAT_CMPG(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

r:	DOUBLE_CMPL(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

r:	DOUBLE_CMPG(r,r)
40
EMIT_INSTRUCTION
EMIT (P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

r:	LONG_IFCMP(r,r)
30
EMIT_INSTRUCTION
EMIT(P(p)); //  Leave for OPT_ComplexLIR2MIRExpansion

r:	DOUBLE_IFCMPL(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(burs, P(p), DOUBLE_CMPL, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

r:	DOUBLE_IFCMPG(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(burs, P(p), DOUBLE_CMPG, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

r:	FLOAT_IFCMPL(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(burs, P(p), FLOAT_CMPL, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

r:	FLOAT_IFCMPG(r,r)
20
EMIT_INSTRUCTION
DOUBLE_IFCMP(burs, P(p), FLOAT_CMPG, R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)));

r:	TRAP_IF(r,r)
10
EMIT_INSTRUCTION
TRAP_IF(burs, P(p));

r:	TRAP_IF(r,INT_CONSTANT)
10
EMIT_INSTRUCTION
TRAP_IF_IMM(burs, P(p));

r:	TRAP
10
EMIT_INSTRUCTION
TRAP(burs, P(p));

r:	INT_IFCMP(r,r)
20
EMIT_INSTRUCTION
CMP(burs, P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)), false);

r:	INT_IFCMP(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
CMP(burs, P(p), R(IfCmp.getVal1(P(p))), IfCmp.getVal2(P(p)), IfCmp.getCond(P(p)), true);

r:	INT_IFCMP2(r,r)
20
EMIT_INSTRUCTION
CMP2(burs, P(p), R(IfCmp2.getVal1(P(p))), IfCmp2.getVal2(P(p)), IfCmp2.getCond1(P(p)), IfCmp2.getCond2(P(p)), false);

r:	INT_IFCMP2(r,INT_CONSTANT)
20
EMIT_INSTRUCTION
CMP2(burs, P(p), R(IfCmp2.getVal1(P(p))), IfCmp2.getVal2(P(p)), IfCmp2.getCond1(P(p)), IfCmp2.getCond2(P(p)), true);

r:	INT_IFCMP(ATTEMPT(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
{                                                                             \
   OPT_ConditionOperand c = IfCmp.getCond(P(p)).flipCode();                   \
   EMIT(OPT_RVMIRTools.nonPEIGC(MIR_Store.create(PPC_STWCXr, R(Attempt.getNewValue(PL(p))), \
                                  R(Attempt.getAddress(PL(p))), Attempt.getOffset(PL(p)),           \
				  Attempt.getLocation(PL(p)),                \
                                  Attempt.getGuard(PL(p)))));                \
   EMIT(MIR_CondBranch.mutate(P(p), PPC_BCOND, CR(0),                         \
                              new OPT_PowerPCConditionOperand(c),             \
                              IfCmp.getTarget(P(p)),                         \
			      IfCmp.getBranchProfile(P(p))));                 \
}

r:	INT_IFCMP(INT_NEG(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_NEGr, Unary.getResult(PL(p)),           \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_NOT(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_XORr, Unary.getResult(PL(p)),           \
                     R(Unary.getVal(PL(p))), Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_2BYTE(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_EXTSBr, Unary.getResult(PL(p)),         \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_2SHORT(r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_EXTSHr, Unary.getResult(PL(p)),         \
                     Unary.getVal(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_ADD(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ADDr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_AND(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ANDr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_OR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ORr, Binary.getResult(PL(p)),           \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_XOR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_XORr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_USHR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_SRWr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_SHL(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_SLWr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_SHR(r,r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_SRAWr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))&&U16(Move.getVal(PLR(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ANDISr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))),                               \
                     SRI(Move.getVal(PLR(p)), 16), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_AND(r,INT_MOVE(INT_CONSTANT)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))&&MASK(Move.getVal(PLR(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO_AND_MASK(burs, P(p), Binary.getResult(PL(p)),           \
                              R(Binary.getVal1(PL(p))),                      \
                              I(Move.getVal(PLR(p))), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_ADD(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ADDICr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_AND(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ANDIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_SRWIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_SLWIr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_SRAWIr, Binary.getResult(PL(p)),        \
                     R(Binary.getVal1(PL(p))), Binary.getVal2(PL(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_AND(r,INT_NOT(r)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ANDCr, Binary.getResult(PL(p)),         \
                     R(Binary.getVal1(PL(p))), Unary.getVal(PLR(p)), IfCmp.getCond(P(p)));

r:	INT_IFCMP(INT_OR(r,INT_NOT(r)),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE
EMIT_INSTRUCTION
CMP_ZERO(burs, P(p), PPC_ORCr, Binary.getResult(PL(p)),          \
                     R(Binary.getVal1(PL(p))), Unary.getVal(PLR(p)), IfCmp.getCond(P(p)));

# IfCmp(BooleanCMP, 0)
r:	INT_IFCMP(BOOLEAN_CMP(r, INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isNOT_EQUAL()&&ZERO(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)).flipCode(), true);

r:	INT_IFCMP(BOOLEAN_CMP(r, INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isEQUAL()&&ZERO(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)), true);

r:	INT_IFCMP(BOOLEAN_CMP(r, r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isNOT_EQUAL()&&ZERO(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)).flipCode(), false);

r:	INT_IFCMP(BOOLEAN_CMP(r, r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isEQUAL()&&ZERO(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)), false);

# IfCmp(BooleanCMP, 1)
r:	INT_IFCMP(BOOLEAN_CMP(r, INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isEQUAL()&&ONE(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)).flipCode(), true);

r:	INT_IFCMP(BOOLEAN_CMP(r, INT_CONSTANT),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isNOT_EQUAL()&&ONE(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)), true);

r:	INT_IFCMP(BOOLEAN_CMP(r, r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isEQUAL()&&ONE(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)).flipCode(), false);

r:	INT_IFCMP(BOOLEAN_CMP(r, r),INT_CONSTANT)
(!IfCmp.getCond(P(p)).isNOT_EQUAL()&&ONE(IfCmp.getVal2(P(p))))?20:INFINITE
EMIT_INSTRUCTION
CMP(burs, P(p), R(BooleanCmp.getVal1(PL(p))), BooleanCmp.getVal2(PL(p)), BooleanCmp.getCond(PL(p)), false);

#
r:	WRITE_FLOOR
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_SYNC));

r:	READ_CEILING
11
EMIT_INSTRUCTION
EMIT(MIR_Empty.mutate(P(p), PPC_ISYNC));

r:	YIELDPOINT_PROLOGUE
11
EMIT_INSTRUCTION
EMIT(P(p));

r:	YIELDPOINT_EPILOGUE
11
EMIT_INSTRUCTION
EMIT(P(p));

r:	YIELDPOINT_BACKEDGE
11
EMIT_INSTRUCTION
EMIT(P(p));

r:      RESOLVE
11
EMIT_INSTRUCTION
EMIT(P(p));    

r:	DCBF(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBF, R(0), R(CacheOp.getRef(P(p)))));

r:	DCBST(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBST, R(0), R(CacheOp.getRef(P(p)))));

r:	ICBI(r)
11
EMIT_INSTRUCTION
EMIT(MIR_CacheOp.mutate(P(p), PPC_ICBI, R(0), R(CacheOp.getRef(P(p)))));

# ORC(x,x) always produces 1
r:	SET_THREAD_SWITCH_BIT
11
EMIT_INSTRUCTION
EMIT(MIR_Condition.create(PPC_CRORC, I(THREAD_SWITCH_BIT), I(0), I(0)));

# ANDC(x,x) always produces 0
r:	CLEAR_THREAD_SWITCH_BIT
11
EMIT_INSTRUCTION
EMIT(MIR_Condition.create(PPC_CRANDC, I(THREAD_SWITCH_BIT), I(0), I(0)));

r:	GET_TIME_BASE
11
EMIT_INSTRUCTION
EMIT(P(p));  // Leave for OPT_ComplexLIR2MIRExpansion

#
r:	GOTO
11
EMIT_INSTRUCTION
EMIT(MIR_Branch.mutate(P(p), PPC_B, Goto.getTarget(P(p))));

r:	COMPUTED_GOTO(r)
11
EMIT_INSTRUCTION
EMIT(MIR_Move.create(PPC_MTSPR, R(getCTR()),                \
                     R(ComputedGoto.getTarget(P(p)))));                       \
EMIT(MIR_Branch.mutate(P(p), PPC_BCTR));

#
r:	LOWTABLESWITCH(r)
11
EMIT_INSTRUCTION
EMIT(P(p)); // Leave for OPT_ComplexLIR2MIRExpansion

###########
# things that on ppc are just load/stores from the stack
###########
r:	GET_CAUGHT_EXCEPTION
11
EMIT_INSTRUCTION
GET_EXCEPTION_OBJECT(burs, P(p));

r:	SET_CAUGHT_EXCEPTION(r)
11
EMIT_INSTRUCTION
SET_EXCEPTION_OBJECT(burs, P(p));

r:	FLOAT_AS_INT_BITS(r)
20
EMIT_INSTRUCTION
FPR2GPR_32(burs, P(p));

r:	DOUBLE_AS_LONG_BITS(r)
40
EMIT_INSTRUCTION
FPR2GPR_64(burs, P(p));

r:	INT_BITS_AS_FLOAT(r)
20
EMIT_INSTRUCTION
GPR2FPR_32(burs, P(p));

r:	LONG_BITS_AS_DOUBLE(r)
40
EMIT_INSTRUCTION
GPR2FPR_64(burs, P(p));
