/*
 * (C) Copyright IBM Corp. 2001
 */
//$Id$
package com.ibm.JikesRVM;

/**
 * A place to put code common to all runtime compilers.
 * This includes instrumentation code to get equivalent data for
 * each of the runtime compilers.
 * <p>
 * We collect the following data for each compiler
 * <ol>
 * <li>
 *   total number of methods complied by the compiler
 * <li>
 *   total compilation time in nanoseconds as computed by calls to VM_Time.now()
 *   This is accumulated as a double to avoid rounding errors. 
 * <li>
 *   total number of bytes of bytecodes compiled by the compiler
 *   (under the assumption that there is no padding in the bytecode
 *   array and thus VM_Method.getBytecodes().length is the number bytes
 *   of bytecode for a method)
 * <li>
 *   total number of machine code insructions generated by the compiler
 *   (under the assumption that there is no (excessive) padding in the
 *   machine code array and thus VM_Method.getInstructions().length
 *   is a close enough approximation of the number of machinecodes generated)
 * </ol>
 *   Note that even if 3. & 4. are inflated due to padding, the numbers will 
 *   still be an accurate measure of the space costs of the compile-only 
 *   approach.
 *
 * @author Dave Grove
 * @author Mike Hind
 */
public class VM_RuntimeCompilerInfrastructure
  implements VM_Constants, VM_Callbacks.ExitMonitor {

  // Use these to encode the compiler for record()
  public static final byte JNI_COMPILER      = 0;
  public static final byte BASELINE_COMPILER = 1;
  public static final byte OPT_COMPILER      = 2;

  // Data accumulators
  private static final String name[]         = {"JNI\t","Base\t","Opt\t"};   // Output names
  private static int total_methods[]         = {0,0,0};                // (1)
  private static double total_time[]         = {0.0, 0.0,0.0};         // (2)
  private static int total_bcodeLen[]        = {0, 0,0};               // (3)
  private static int total_mcodeLen[]        = {0, 0,0};               // (4)

  /**
   * To be called when the VM is about to exit.
   * @param value the exit value
   */
  public void notifyExit(int value) {
    report(true);
  }

  /**
   * This method records the time and sizes (bytecode and machine code) for
   * a compilation
   * @param compiler the compiler used
   * @param method the resulting VM_Method
   * @param compiledMethod the resulting compiled method
   * @param timer the timer hold the time used for compilation
   */
  public static void record(byte compiler, VM_Method method, 
			    VM_CompiledMethod compiledMethod) {
    
    if (method.isNative()) {
      total_methods[compiler]++;
      total_bcodeLen[compiler] += 1; // lie!
      total_mcodeLen[compiler] += compiledMethod.getInstructions().length;
      if (VM.MeasureCompilation) {
	total_time[compiler] += compiledMethod.getCompilationTime();
      }
    } else {
      total_methods[compiler]++;
      total_bcodeLen[compiler] += method.getBytecodes().length;
      total_mcodeLen[compiler] += compiledMethod.getInstructions().length;
      if (VM.MeasureCompilation) {
	total_time[compiler] += compiledMethod.getCompilationTime();
      }
    }
  }

  /**
   * This method produces a summary report of compilation activities
   * @param explain Explains the metrics used in the report
   */
  public static void report (boolean explain) { 
    VM.sysWrite("\n\t\tCompilation Subsystem Report\n");
    VM.sysWrite("Comp\t#Meths\tTime\tbcb/ms\tmcb/bcb\tMCKB\tBCKB\n");
    for (int i=JNI_COMPILER; i<=OPT_COMPILER; i++) {
      if (total_methods[i]>0) {
	VM.sysWrite(name[i]);
	// Number of methods
	VM.sysWrite(total_methods[i], false);
	VM.sysWrite("\t");
	// Compilation time
	VM.sysWrite((int)total_time[i], false);
	VM.sysWrite("\t");
	// Bytecode bytes per millisecond
	printRatio(total_bcodeLen[i], (int)total_time[i], 2);
	VM.sysWrite("\t");
	// Ratio of machine code bytes to bytecode bytes
	printRatio(total_mcodeLen[i] << LG_INSTRUCTION_WIDTH, total_bcodeLen[i], 2);
	VM.sysWrite("\t");
	// Generated machine code Kbytes
	printRatio(total_mcodeLen[i] << LG_INSTRUCTION_WIDTH, 1024, 1);
	VM.sysWrite("\t");
	// Compiled bytecode Kbytes
	printRatio(total_bcodeLen[i], 1024, 1); 
	VM.sysWrite("\n");
      }
    }
    if (explain) {
      // Generate an explanation of the metrics reported
      VM.sysWrite("\t\t\tExplanation of Metrics\n");
      VM.sysWrite("#Meths:\t\tTotal number of methods compiled by the compiler\n");
      VM.sysWrite("Time:\t\tTotal compilation time in milliseconds\n");
      VM.sysWrite("bcb/ms:\t\tNumber of bytecode bytes complied per millisecond\n");
      VM.sysWrite("mcb/bcb:\tRatio of machine code bytes to bytecode bytes\n");
      VM.sysWrite("MCKB:\t\tTotal number of machine code bytes generated in kilobytes\n");
      VM.sysWrite("BCKB:\t\tTotal number of bytecode bytes compiled in kilobytes\n");
    }
    VM_RuntimeCompiler.detailedCompilationReport(explain);
  }
   

  /**
   * Prints the ratio of first two parameters using the number of digits
   * specified by the 3rd parameter.

   * NOTE: Printing a double or float requires a fair amount of work and
   * furthermore may result in class loading and/or allocation.  We could
   * call Math.round, but that might also cause classloading, so instead
   * we do something fairly simple, but slow and ugly that more or less
   * works in most cases.
   *
   * TODO: Move this somewhere else (general profiling utility file).
   *
   * @param numerator the numerator
   * @param denominator the denominator
   * @param places the number of decimal places to be used in the result
   */
  public static void printRatio(int numerator, int denominator, int places) {
    if (denominator == 0) return;
    int divide = 10;
    for (int i = 0; i<places; i++)
      divide = divide*10;
    float value = ((float)numerator)/((float)denominator) + (5.0f/(float)divide); //Add in fudge to get rounding
    int approx = (int)value;
    VM.sysWrite(approx, false);
    if (places > 0) VM.sysWrite(".");
    for (int i = 0; i<places; i++) {
      value = (value - (float)approx)*10.0f;
      approx = (int)(value);
      VM.sysWrite(approx, false);
    }
  }

  /**
   * Prints the percentage of total time taken by the first parameter.
   * @param phaseTime the time take by a phase
   * @param time the total time
   */
  public static void printPercentage(double phaseTime, double time) {
    printRatio((int)(phaseTime*100), (int)time, 2);
  }

  /**
   * This method will compile the passed method using the baseline compiler.
   * @param method the method to compile
   */
  public static VM_CompiledMethod baselineCompile(VM_Method method) {
    VM_Callbacks.notifyMethodCompile(method, VM_CompiledMethod.BASELINE);
    double start = 0;
    if (VM.MeasureCompilation || VM.BuildForAdaptiveSystem) {
      double now = VM_Time.now();
      start = updateStartAndTotalTimes(now);
    }

    VM_CompiledMethod cm = VM_BaselineCompiler.compile(method);

    if (VM.MeasureCompilation || VM.BuildForAdaptiveSystem) {
      double now = VM_Time.now();
      double end = updateStartAndTotalTimes(now);
      double compileTime = (end - start) * 1000; // convert to milliseconds
      cm.setCompilationTime(compileTime);
      record(BASELINE_COMPILER, method, cm);
    }
    
    return cm;
  }

  /**
   * This method will compile the passed method using the baseline compiler.
   * @param method the method to compile
   */
  public static VM_CompiledMethod jniCompile(VM_Method method) {
    VM_Callbacks.notifyMethodCompile(method, VM_CompiledMethod.JNI);
    double start = 0;
    if (VM.MeasureCompilation || VM.BuildForAdaptiveSystem) {
      double now = VM_Time.now();
      start = updateStartAndTotalTimes(now);
    }

    VM_CompiledMethod cm = VM_JNICompiler.compile(method);
    if (VM.verboseJNI) {
      VM.sysWriteln("[Dynamic-linking native method " + 
		    method.getDeclaringClass().getName() + "." + method.getName() + 
		    " ... JNI]");
    }

    if (VM.MeasureCompilation || VM.BuildForAdaptiveSystem) {
      double now = VM_Time.now();
      double end = updateStartAndTotalTimes(now);
      double compileTime = (end - start) * 1000; // convert to milliseconds
      cm.setCompilationTime(compileTime);
      record(JNI_COMPILER, method, cm);
    }
    
    return cm;
  }

  /**
   * Support for timing compilation accurately by accumulating CPU on the Java thread.
   */
  protected static double updateStartAndTotalTimes(double now) {
    VM_Thread t = VM_Thread.getCurrentThread();
    t.setCPUTotalTime(t.getCPUTotalTime() + (now - t.getCPUStartTime()));
    t.setCPUStartTime(now);
    return t.getCPUTotalTime();
  }
}
