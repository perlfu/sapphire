#
# (C) Copyright IBM Corp. 2001
#
DECL 
# Structure of DECL FULL_NAME OPT_LEVEL DEFAULT_VALUE {SHORT_NAME}
DESCRIP  

##########
# First all the non-printing, non-debugging options
# Should not start with PRINT_ or DEBUG_ prefix
##########
LOCAL_CSE 1 true
Perform local common subexpression elimination

LOCAL_CONSTANT_PROP 1 true
Perform local constant propagation

LOCAL_COPY_PROP 1 true
Perform local copy propagation

LOCAL_SCALAR_REPLACEMENT 1 true local_sr
Perform local scalar replacement

LOCAL_CHECK 1 true
Perform local elimination of redundant null checks and array bounds checks

# ABCD is currently incomplete; it doesn't check lower bounds
GLOBAL_BOUNDS_CHECK -1 false global_bounds
Perform global Array Bound Check elimination on Demand 

SIMPLE_OPT 1 true simple
Perform suite of simple flow-insensitive optimizations

MONITOR_REMOVAL 1 true
Try to remove unnecessary monitor operations

INVOKEE_THREAD_LOCAL -1 false
Compile the method assuming the invokee is thread-local

NO_CALLEE_EXCEPTIONS -1 false
Assert that any callee of this compiled method will not throw exceptions?

SIMPLE_ESCAPE_IPA -1 false
Eagerly compute method summaries for simple escape analysis

FIELD_ANALYSIS 0 true
Eagerly compute method summaries for flow-insensitive field analysis

SCALAR_REPLACE_AGGREGATES 1 true
Perform scalar replacement of aggregates

REORDER_CODE 1 true
Reorder basic blocks for improved locality and branch prediction

INLINE_NEW 1 true 
Inline allocation of scalars and arrays

INLINE 0 true
Inline statically resolvable calls

GUARDED_INLINE 1 true
Guarded inlining of non-final virtual calls

GUARDED_INLINE_INTERFACE 1 true
Speculatively inline non-final interface calls

STATIC_SPLITTING 1 true
CFG splitting to create hot traces based on static heuristics

REDUNDANT_BRANCH_ELIMINATION 2 true
Eliminate redundant conditional branches

PREEX_INLINE 1 true
Pre-existence based inlining

SSA 2 false
Should SSA form be constructed on the HIR?

PRUNED_SSA -1 true
Use liveness information to reduce insert phi nodes?

SEMI_PRUNED_SSA -1 false
Use local approximation of liveness information to reduce insert phi nodes?

LOAD_ELIMINATION 2 false
Should we perform redundant load elimination during SSA pass?

COALESCE_AFTER_SSA 2 false
Should we coalesce move instructions after leaving SSA?

EXPRESSION_FOLDING 2 false
Should we try to fold expressions with constants in SSA form?

LIVE_RANGE_SPLITTING -1 false
Split live ranges using LIR SSA pass?

## (SJF): The following optimization is not on by default because
## it is usually expensive and ineffective.
## 9/15/2001: This optimization is causing stability problems on IA32.
## I'm dropping it from the regression test, so this optimization is no
## longer being maintained.
STORE_ELIMINATION -1 false
Should we perform dead store elimination during SSA pass?

VALUE_PROP -1 false value_prop
Perform value propagation

GCP 2 false gcp
Perform global code placement

GCSE 2 false  gcse
Perform global code placement

VERBOSE_GCP -1 false verbose_gcp
Perform noisy global code placement

VALUE_PROP_VERBOSE -1 false value_prop_verbose
Perform noisy value propagation

TURN_WHILES_INTO_UNTILS 2 false unwhile
Turn whiles into untils

HANDLER_LIVENESS 2 false
Store liveness for handlers to improve dependence graph at PEIs

SCHEDULE_PREPASS -1 false
Perform prepass instruction scheduling

ERRORS_FATAL -1 false
Should an unexpected failure during compilation be treated as fatal?

NO_CHECKCAST -1 false
Should all checkcast operations be (unsafely) eliminated?

NO_CHECKSTORE -1 false
Should all checkstore operations be (unsafely) eliminated?

NO_BOUNDS_CHECK -1 false
Should all bounds check operations be (unsafely) eliminated?

NO_NULL_CHECK -1 false
Should all null check operations be (unsafely) eliminated?

NO_SYNCHRO -1 false
Should all synchronization operations be (unsafely) eliminated?

NO_THREADS -1 false
Should all yield points be (unsafely) eliminated?

NO_CACHE_FLUSH -1 VM.BuildForIA32
Should cache flush instructions (PowerPC SYNC/ISYNC) be omitted? NOTE: Cannot be correctly changed via the command line!

DETECT_UNIPROCESSOR -1 true
Does the system automatically detect when there is one PHYSICAL CPU, and optimize accordingly? NOTE: Cannot be correctly changed via the command line!

READS_KILL -1 false
Should we constrain optimizations by enforcing reads-kill?

MONITOR_NOP -1 false
Should we treat all monitorenter/monitorexit bytecodes as nops?

STATIC_STATS -1 false
Should we dump out compile-time statistics for basic blocks?

LOOP_DEPTH_EDGE_COUNTS -1 false
Use loop depth to approximate edge counts

FIXED_JTOC -1 VM.BuildForIA32
Exploit knowledge that the value of JTOC is a constant?

CW_REFERENCED_CLASSES -1 true
Apply Class Writer to referenced classes

CW_GUARDS -1 false
Leave guards in before BURS

CW_STACK -1 true
Process Stack to eliminate Loads/Stores

##########
# Next, declare all the printing options
# MUST start with PRINT_ or VCG_ prefix
#
PRINT_PHASES -1 false phases
Print short message for each compilation phase

PRINT_ALL_IR -1 false 
Dump the IR after each compiler phase

PRINT_INLINE_REPORT -1 false
Print detailed report of compile-time inlining decisions

PRINT_DOMINATORS -1 false dom
Print dominators

PRINT_POST_DOMINATORS -1 false pdom
Print post-dominators

PRINT_SSA -1 false
Print SSA form

PRINT_DG_BURS -1 false
Print dependence graph before burs

PRINT_DG_SCHED_PRE -1 false
Print dependence graph before prepass scheduling

PRINT_DG_SCHED_POST -1 false
Print dependence graph before postpass scheduling

PRINT_COALESCING -1 false pcoal
Print coalescing output

PRINT_DETAILED_INLINE_REPORT -1 false
Print report regarding inlining decisions made with Gnosys turned on

## Options for IR printing at various points in compilation
PRINT_HIGH -1 false high
Print IR after initial generation

PRINT_FINAL_HIR -1 false final_hir
Print IR just before conversion to LIR

PRINT_LOW -1 false low
Print IR after conversion to LIR

PRINT_FINAL_LIR -1 false final_lir
Print IR just before conversion to MIR

PRINT_MIR -1 false mir
Print IR after conversion to MIR

PRINT_FINAL_MIR -1 false final_mir
Print IR just before conversion to machine code

PRINT_CFG -1 false cfg
Print control flow graph too when IR is printed

PRINT_SCHEDULE_PRE -1 false
Print IR after prepass scheduling

PRINT_SCHEDULE_POST -1 false
Print IR after postpass scheduling

PRINT_REGALLOC -1 false regalloc
Print IR before and after register allocation 

PRINT_CALLING_CONVENTIONS -1 false 
Print IR after expanding calling conventions

PRINT_CW_BURS -1 false 
Verbose dump of Class Writer BURS processing

PRINT_CW_BURS_NOISY -1 false 
Verbose dump of Class Writer BURS processing

PRINT_CW_ALLOC -1 false 
Verbose dump of Class Writer Allocation of Locals

PRINT_CW_STACK -1 false 
Verbose dump of Class Writer Stack processing to eliminate Load/Store

PRINT_CW_PRODUCE -1 false 
Dump of Class Writer Byte Code Production

VCG_DG_BURS -1 false 
Dump dependence graph before BURS in vcg form

VCG_DG_SCHED_PRE -1 false 
Dump dependence graph before prepass scheduling in vcg form

VCG_DG_SCHED_POST -1 false 
Dump dependence graph before postpass scheduling in vcg form

##########
# Finally, the debugging flags
# MUST start with DEBUG_ prefix
#
DEBUG_CODEGEN -1 false cgd
Enable debugging support for final assembly

DEBUG_ABCD -1 false
Enable debugging support for ABCD (Array Bound Check elimination on Demand)

