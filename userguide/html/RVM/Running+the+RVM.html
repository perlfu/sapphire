<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>RVM : Running the RVM</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="page">
            <div id="main">
                <div id="main-header" class="pageSectionHeader">
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            RVM : Running the RVM
                        </span>
                    </h1>

                    <div class="page-metadata">
                        <p>This page last changed on Dec 21, 2011 by <font color="#0050B2">dgrove</font>.</p>
                    </div>
                </div>

                <div id="content" class="view">
                    <div id="main-content" class="wiki-content group">
                    <p>Jikes<a href="http://docs.codehaus.org/display/RVM/Trademarks">&trade;</a> RVM executes Java virtual machine byte code instructions from <code>.class</code> files. It does <em>not</em> compile Java<a href="http://docs.codehaus.org/display/RVM/Trademarks">&trade;</a> source code. Therefore, you must compile all Java source files into bytecode using your favorite Java compiler.</p><p>For example, to run class <code>foo</code> with source code in file <code>foo.java</code>:</p><div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent panelContent">
<pre>% javac foo.java
% rvm foo</pre>
</div></div><p>The general syntax is</p><div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent panelContent">
<pre>rvm [rvm options...] class [args...]</pre>
</div></div><p>You may choose from a myriad of options for the <code>rvm</code> command-line. Options fall into two categories: <em>standard</em> and <em>non-standard</em>. Non-standard options are preceded by &quot;<code><strong>-X:</strong></code>&quot;.</p><h3 id="RunningtheRVM-StandardCommand-LineOptions">Standard Command-Line Options</h3><p>We currently support a subset of the JDK 1.5 standard options. Below is a list of all options and their descriptions. Unless otherwise noted each option is supported in Jikes RVM.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>{-cp or -classpath} &lt;directories and zip/jar files separated by &quot;:&quot;&gt;</p></td><td class="confluenceTd"><p>set search path for application classes and resources</p></td></tr><tr><td class="confluenceTd"><p>-D&lt;name&gt;=&lt;value&gt;</p></td><td class="confluenceTd"><p>set a system property</p></td></tr><tr><td class="confluenceTd"><p>-verbose:[ class | gc | jni ]</p></td><td class="confluenceTd"><p>enable verbose output</p></td></tr><tr><td class="confluenceTd"><p>-version</p></td><td class="confluenceTd"><p>print current VM version and terminate the run</p></td></tr><tr><td class="confluenceTd"><p>-showversion</p></td><td class="confluenceTd"><p>print current VM version and continue running</p></td></tr><tr><td class="confluenceTd"><p>-fullversion</p></td><td class="confluenceTd"><p>like &quot;-version&quot;, but with more information</p></td></tr><tr><td class="confluenceTd"><p>-? or -help</p></td><td class="confluenceTd"><p>print help message</p></td></tr><tr><td class="confluenceTd"><p>-X</p></td><td class="confluenceTd"><p>print help on non-standard options</p></td></tr><tr><td class="confluenceTd"><p>-jar</p></td><td class="confluenceTd"><p>execute a jar file</p></td></tr><tr><td class="confluenceTd"><p>-javaagent:&lt;jarpath&gt;[=&lt;options&gt;]</p></td><td class="confluenceTd"><p>load Java programming language agent, see java.lang.instrument</p></td></tr></tbody></table></div><h3 id="RunningtheRVM-Non-StandardCommand-LineOptions">Non-Standard Command-Line Options</h3><p>The non standard command-line options are grouped according to the subsystem that they control. The following sections list the available options in each group.</p><h4 id="RunningtheRVM-CoreNon-StandardCommand-LineOptions">Core Non-Standard Command-Line Options</h4><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>-X:verbose</p></td><td class="confluenceTd"><p>Print out additional lowlevel information for GC and hardware trap handling</p></td></tr><tr><td class="confluenceTd"><p>-X:verboseBoot=&lt;number&gt;</p></td><td class="confluenceTd"><p>Print out additional information while VM is booting, using verbosity level &lt;number&gt;</p></td></tr><tr><td class="confluenceTd"><p>-X:sysLogfile=&lt;filename&gt;</p></td><td class="confluenceTd"><p>Write standard error message to &lt;filename&gt;</p></td></tr><tr><td class="confluenceTd"><p>-X:ic=&lt;filename&gt;</p></td><td class="confluenceTd"><p>Read boot image code from &lt;filename&gt;</p></td></tr><tr><td class="confluenceTd"><p>-X:id=&lt;filename&gt;</p></td><td class="confluenceTd"><p>Read boot image data from &lt;filename&gt;</p></td></tr><tr><td class="confluenceTd"><p>-X:ir=&lt;filename&gt;</p></td><td class="confluenceTd"><p>Read boot image ref map from &lt;filename&gt;</p></td></tr><tr><td class="confluenceTd"><p>-X:vmClasses=&lt;path&gt;</p></td><td class="confluenceTd"><p>Load the com.ibm.jikesrvm.* and java.* classes from &lt;path&gt;</p></td></tr><tr><td class="confluenceTd"><p>-X:processors=&lt;number|&quot;all&quot;&gt;</p></td><td class="confluenceTd"><p>The number of processors that the garbage collector will use</p></td></tr></tbody></table></div><h4 id="RunningtheRVM-MemoryNon-StandardCommand-LineOptions">Memory Non-Standard Command-Line Options</h4><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>-Xms&lt;number&gt;&lt;unit&gt;</p></td><td class="confluenceTd"><p>Initial size of heap where &lt;number&gt; is an integer, an extended-precision floating point or a hexadecimal value and &lt;unit&gt; is one of T (Terabytes), G (Gigabytes), M (Megabytes), pages (of size 4096), K (Kilobytes) or &lt;no unit&gt; for bytes</p></td></tr><tr><td class="confluenceTd"><p>-Xmx&lt;number&gt;&lt;unit&gt;</p></td><td class="confluenceTd"><p>Maximum size of heap. See above for definition of &lt;number&gt; and &lt;unit&gt;</p></td></tr></tbody></table></div><h4 id="RunningtheRVM-GarbageCollectorNon-StandardCommand-LineOptions">Garbage Collector Non-Standard Command-Line Options</h4><p>These options are all prefixed by <code>-X:gc:</code>.</p><p>Boolean options.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>protectOnRelease</p></td><td class="confluenceTd"><p>Should memory be protected on release?</p></td></tr><tr><td class="confluenceTd"><p>echoOptions</p></td><td class="confluenceTd"><p>Echo when options are set?</p></td></tr><tr><td class="confluenceTd"><p>printPhaseStats</p></td><td class="confluenceTd"><p>When printing statistics, should statistics for each gc-mutator phase be printed?</p></td></tr><tr><td class="confluenceTd"><p>xmlStats</p></td><td class="confluenceTd"><p>Print end-of-run statistics in XML format</p></td></tr><tr><td class="confluenceTd"><p>eagerCompleteSweep</p></td><td class="confluenceTd"><p>Should we eagerly finish sweeping at the start of a collection</p></td></tr><tr><td class="confluenceTd"><p>fragmentationStats</p></td><td class="confluenceTd"><p>Should we print fragmentation statistics for the free list allocator?</p></td></tr><tr><td class="confluenceTd"><p>verboseFragmentationStats</p></td><td class="confluenceTd"><p>Should we print verbose fragmentation statistics for the free list allocator?</p></td></tr><tr><td class="confluenceTd"><p>verboseTiming</p></td><td class="confluenceTd"><p>Should we display detailed breakdown of where GC time is spent?</p></td></tr><tr><td class="confluenceTd"><p>noFinalizer</p></td><td class="confluenceTd"><p>Should finalization be disabled?</p></td></tr><tr><td class="confluenceTd"><p>noReferenceTypes</p></td><td class="confluenceTd"><p>Should reference type processing be disabled?</p></td></tr><tr><td class="confluenceTd"><p>fullHeapSystemGC</p></td><td class="confluenceTd"><p>Should a major GC be performed when a system GC is triggered?</p></td></tr><tr><td class="confluenceTd"><p>ignoreSystemGC</p></td><td class="confluenceTd"><p>Should we ignore calls to java.lang.System.gc?</p></td></tr><tr><td class="confluenceTd"><p>variableSizeHeap</p></td><td class="confluenceTd"><p>Should we shrink/grow the heap to adjust to application working set?</p></td></tr><tr><td class="confluenceTd"><p>eagerMmapSpaces</p></td><td class="confluenceTd"><p>If true, all spaces are eagerly demand zero mmapped at boot time</p></td></tr><tr><td class="confluenceTd"><p>sanityCheck</p></td><td class="confluenceTd"><p>Perform sanity checks before and after each collection?</p></td></tr></tbody></table></div><p>Value options.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Type</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>markSweepMarkBits</p></td><td class="confluenceTd"><p>int</p></td><td class="confluenceTd"><p>Number of bits to use for the header cycle of mark sweep spaces</p></td></tr><tr><td class="confluenceTd"><p>verbose</p></td><td class="confluenceTd"><p>int</p></td><td class="confluenceTd"><p>GC verbosity level</p></td></tr><tr><td class="confluenceTd"><p>stressFactor</p></td><td class="confluenceTd"><p>bytes</p></td><td class="confluenceTd"><p>Force a collection after this much allocation</p></td></tr><tr><td class="confluenceTd"><p>metaDataLimit</p></td><td class="confluenceTd"><p>bytes</p></td><td class="confluenceTd"><p>Trigger a GC if the meta data volume grows to this limit</p></td></tr><tr><td class="confluenceTd"><p>boundedNursery</p></td><td class="confluenceTd"><p>bytes</p></td><td class="confluenceTd"><p>Bound the maximum size of the nursery to this value</p></td></tr><tr><td class="confluenceTd"><p>fixedNursery</p></td><td class="confluenceTd"><p>bytes</p></td><td class="confluenceTd"><p>Fix the minimum and maximum size of the nursery to this value</p></td></tr><tr><td class="confluenceTd"><p>debugAddress</p></td><td class="confluenceTd"><p>address</p></td><td class="confluenceTd"><p>Specify an address at runtime for use in debugging</p></td></tr></tbody></table></div><h4 id="RunningtheRVM-BaseCompilerNon-StandardCommand-LineOptions">Base Compiler Non-Standard Command-Line Options</h4><p>Boolean options</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>edge_counters</p></td><td class="confluenceTd"><p>Insert edge counters on all bytecode-level conditional branches</p></td></tr><tr><td class="confluenceTd"><p>invocation_counters</p></td><td class="confluenceTd"><p>Select methods for optimized recompilation by using invocation counters</p></td></tr></tbody></table></div><h4 id="RunningtheRVM-OptCompilerNon-StandardCommand-LineOptions">Opt Compiler Non-Standard Command-Line Options</h4><p>Boolean options.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>local_constant_prop</p></td><td class="confluenceTd"><p>Perform local constant propagation</p></td></tr><tr><td class="confluenceTd"><p>local_copy_prop</p></td><td class="confluenceTd"><p>Perform local copy propagation</p></td></tr><tr><td class="confluenceTd"><p>local_cse</p></td><td class="confluenceTd"><p>Perform local common subexpression elimination</p></td></tr><tr><td class="confluenceTd"><p>global_bounds</p></td><td class="confluenceTd"><p>Perform global Array Bound Check elimination on Demand</p></td></tr><tr><td class="confluenceTd"><p>monitor_removal</p></td><td class="confluenceTd"><p>Try to remove unnecessary monitor operations</p></td></tr><tr><td class="confluenceTd"><p>invokee_thread_local</p></td><td class="confluenceTd"><p>Compile the method assuming the invokee is thread-local</p></td></tr><tr><td class="confluenceTd"><p>no_callee_exceptions</p></td><td class="confluenceTd"><p>Assert that any callee of this compiled method will not throw exceptions?</p></td></tr><tr><td class="confluenceTd"><p>simple_escape_ipa</p></td><td class="confluenceTd"><p>Eagerly compute method summaries for simple escape analysis</p></td></tr><tr><td class="confluenceTd"><p>field_analysis</p></td><td class="confluenceTd"><p>Eagerly compute method summaries for flow-insensitive field analysis</p></td></tr><tr><td class="confluenceTd"><p>scalar_replace_aggregates</p></td><td class="confluenceTd"><p>Perform scalar replacement of aggregates</p></td></tr><tr><td class="confluenceTd"><p>reorder_code</p></td><td class="confluenceTd"><p>Reorder basic blocks for improved locality and branch prediction</p></td></tr><tr><td class="confluenceTd"><p>reorder_code_ph</p></td><td class="confluenceTd"><p>Reorder basic blocks using Pettis and Hansen Algo2</p></td></tr><tr><td class="confluenceTd"><p>inline_new</p></td><td class="confluenceTd"><p>Inline allocation of scalars and arrays</p></td></tr><tr><td class="confluenceTd"><p>inline_write_barrier</p></td><td class="confluenceTd"><p>Inline write barriers for generational collectors</p></td></tr><tr><td class="confluenceTd"><p>inline</p></td><td class="confluenceTd"><p>Inline statically resolvable calls</p></td></tr><tr><td class="confluenceTd"><p>guarded_inline</p></td><td class="confluenceTd"><p>Guarded inlining of non-final virtual calls</p></td></tr><tr><td class="confluenceTd"><p>guarded_inline_interface</p></td><td class="confluenceTd"><p>Speculatively inline non-final interface calls</p></td></tr><tr><td class="confluenceTd"><p>static_splitting</p></td><td class="confluenceTd"><p>CFG splitting to create hot traces based on static heuristics</p></td></tr><tr><td class="confluenceTd"><p>redundant_branch_elimination</p></td><td class="confluenceTd"><p>Eliminate redundant conditional branches</p></td></tr><tr><td class="confluenceTd"><p>preex_inline</p></td><td class="confluenceTd"><p>Pre-existence based inlining</p></td></tr><tr><td class="confluenceTd"><p>ssa</p></td><td class="confluenceTd"><p>Should SSA form be constructed on the HIR?</p></td></tr><tr><td class="confluenceTd"><p>load_elimination</p></td><td class="confluenceTd"><p>Should we perform redundant load elimination during SSA pass?</p></td></tr><tr><td class="confluenceTd"><p>coalesce_after_ssa</p></td><td class="confluenceTd"><p>Should we coalesce move instructions after leaving SSA?</p></td></tr><tr><td class="confluenceTd"><p>expression_folding</p></td><td class="confluenceTd"><p>Should we try to fold expressions with constants in SSA form?</p></td></tr><tr><td class="confluenceTd"><p>live_range_splitting</p></td><td class="confluenceTd"><p>Split live ranges using LIR SSA pass?</p></td></tr><tr><td class="confluenceTd"><p>gcp</p></td><td class="confluenceTd"><p>Perform global code placement</p></td></tr><tr><td class="confluenceTd"><p>gcse</p></td><td class="confluenceTd"><p>Perform global code placement</p></td></tr><tr><td class="confluenceTd"><p>verbose_gcp</p></td><td class="confluenceTd"><p>Perform noisy global code placement</p></td></tr><tr><td class="confluenceTd"><p>licm_ignore_pei</p></td><td class="confluenceTd"><p>Assume PEIs do not throw or state is not observable</p></td></tr><tr><td class="confluenceTd"><p>unwhile</p></td><td class="confluenceTd"><p>Turn whiles into untils</p></td></tr><tr><td class="confluenceTd"><p>loop_versioning</p></td><td class="confluenceTd"><p>Loop versioning</p></td></tr><tr><td class="confluenceTd"><p>handler_liveness</p></td><td class="confluenceTd"><p>Store liveness for handlers to improve dependence graph at PEIs</p></td></tr><tr><td class="confluenceTd"><p>schedule_prepass</p></td><td class="confluenceTd"><p>Perform prepass instruction scheduling</p></td></tr><tr><td class="confluenceTd"><p>no_checkcast</p></td><td class="confluenceTd"><p>Should all checkcast operations be (unsafely) eliminated?</p></td></tr><tr><td class="confluenceTd"><p>no_checkstore</p></td><td class="confluenceTd"><p>Should all checkstore operations be (unsafely) eliminated?</p></td></tr><tr><td class="confluenceTd"><p>no_bounds_check</p></td><td class="confluenceTd"><p>Should all bounds check operations be (unsafely) eliminated?</p></td></tr><tr><td class="confluenceTd"><p>no_null_check</p></td><td class="confluenceTd"><p>Should all null check operations be (unsafely) eliminated?</p></td></tr><tr><td class="confluenceTd"><p>no_synchro</p></td><td class="confluenceTd"><p>Should all synchronization operations be (unsafely) eliminated?</p></td></tr><tr><td class="confluenceTd"><p>no_threads</p></td><td class="confluenceTd"><p>Should all yield points be (unsafely) eliminated?</p></td></tr><tr><td class="confluenceTd"><p>no_cache_flush</p></td><td class="confluenceTd"><p>Should cache flush instructions (PowerPC SYNC/ISYNC) be omitted? NOTE: Cannot be correctly changed via the command line!</p></td></tr><tr><td class="confluenceTd"><p>reads_kill</p></td><td class="confluenceTd"><p>Should we constrain optimizations by enforcing reads-kill?</p></td></tr><tr><td class="confluenceTd"><p>monitor_nop</p></td><td class="confluenceTd"><p>Should we treat all monitorenter/monitorexit bytecodes as nops?</p></td></tr><tr><td class="confluenceTd"><p>static_stats</p></td><td class="confluenceTd"><p>Should we dump out compile-time statistics for basic blocks?</p></td></tr><tr><td class="confluenceTd"><p>code_patch_nop</p></td><td class="confluenceTd"><p>Should all patch point be (unsafely) eliminated (at initial HIR)?</p></td></tr><tr><td class="confluenceTd"><p>instrumentation_sampling</p></td><td class="confluenceTd"><p>Perform code transformation to sample instrumentation code.</p></td></tr><tr><td class="confluenceTd"><p>no_duplication</p></td><td class="confluenceTd"><p>When performing inst. sampling, should it be done without duplicating code?</p></td></tr><tr><td class="confluenceTd"><p>processor_specific_counter</p></td><td class="confluenceTd"><p>Should there be one CBS counter per processor for SMP performance?</p></td></tr><tr><td class="confluenceTd"><p>remove_yp_from_checking</p></td><td class="confluenceTd"><p>Should yieldpoints be removed from the checking code (requires finite sample interval).</p></td></tr></tbody></table></div><p>Value options.</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>ic_max_target_size</p></td><td class="confluenceTd"><p>Static inlining heuristic: Upper bound on callee size</p></td></tr><tr><td class="confluenceTd"><p>ic_max_inline_depth</p></td><td class="confluenceTd"><p>Static inlining heuristic: Upper bound on depth of inlining</p></td></tr><tr><td class="confluenceTd"><p>ic_max_always_inline_target_size</p></td><td class="confluenceTd"><p>Static inlining heuristic: Always inline callees of this size or smaller</p></td></tr><tr><td class="confluenceTd"><p>ic_massive_method_size</p></td><td class="confluenceTd"><p>Static inlining heuristic: If root method is already this big, then only inline trivial methods</p></td></tr><tr><td class="confluenceTd"><p>ai_max_target_size</p></td><td class="confluenceTd"><p>Adaptive inlining heuristic: Upper bound on callee size</p></td></tr><tr><td class="confluenceTd"><p>ai_min_callsite_fraction</p></td><td class="confluenceTd"><p>Adaptive inlining heuristc: Minimum fraction of callsite distribution for guarded inlining of a callee</p></td></tr><tr><td class="confluenceTd"><p>edge_count_input_file</p></td><td class="confluenceTd"><p>Input file of edge counter profile data</p></td></tr><tr><td class="confluenceTd"><p>inlining_guard</p></td><td class="confluenceTd"><p>Selection of guard mechanism for inlined virtual calls that cannot be statically bound</p></td></tr><tr><td class="confluenceTd"><p>fp_mode</p></td><td class="confluenceTd"><p>Selection of strictness level for floating point computations</p></td></tr><tr><td class="confluenceTd"><p>exclude</p></td><td class="confluenceTd"><p>Exclude methods from being opt compiled</p></td></tr><tr><td class="confluenceTd"><p>unroll_log</p></td><td class="confluenceTd"><p>Unroll loops. Duplicates the loop body 2^n times.</p></td></tr><tr><td class="confluenceTd"><p>cond_move_cutoff</p></td><td class="confluenceTd"><p>How many extra instructions will we insert in order to remove a conditional branch?</p></td></tr><tr><td class="confluenceTd"><p>load_elimination_rounds</p></td><td class="confluenceTd"><p>How many rounds of redundant load elimination will we attempt?</p></td></tr><tr><td class="confluenceTd"><p>alloc_advice_sites</p></td><td class="confluenceTd"><p>Read allocation advice attributes for all classes from this file</p></td></tr><tr><td class="confluenceTd"><p>frequency_strategy</p></td><td class="confluenceTd"><p>How to compute block and edge frequencies?</p></td></tr><tr><td class="confluenceTd"><p>spill_cost_estimate</p></td><td class="confluenceTd"><p>Selection of spilling heuristic</p></td></tr><tr><td class="confluenceTd"><p>infrequent_threshold</p></td><td class="confluenceTd"><p>Cumulative threshold which defines the set of infrequent basic blocks</p></td></tr><tr><td class="confluenceTd"><p>cbs_hotness</p></td><td class="confluenceTd"><p>Threshold at which a conditional branch is considered to be skewed</p></td></tr><tr><td class="confluenceTd"><p>ir_print_level</p></td><td class="confluenceTd"><p>Only print IR compiled above this level</p></td></tr></tbody></table></div><h4 id="RunningtheRVM-AdaptiveSystemNon-StandardCommand-LineOptions">Adaptive System Non-Standard Command-Line Options</h4><p>Boolean options</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>enable_recompilation </p></td><td class="confluenceTd"><p>Should the adaptive system recompile hot methods?</p></td></tr><tr><td class="confluenceTd"><p>enable_advice_generation</p></td><td class="confluenceTd"><p>Do we need to generate advice file?</p></td></tr><tr><td class="confluenceTd"><p>enable_precompile</p></td><td class="confluenceTd"><p>Should the adaptive system precompile all methods given in the advice file before the user thread is started?</p></td></tr><tr><td class="confluenceTd"><p>enable_replay_compile</p></td><td class="confluenceTd"><p>Should the adaptive system use the pseudo-adaptive system that solely relies on the advice file?</p></td></tr><tr><td class="confluenceTd"><p>gather_profile_data</p></td><td class="confluenceTd"><p>Should profile data be gathered and reported at the end of the run?</p></td></tr><tr><td class="confluenceTd"><p>adaptive_inlining</p></td><td class="confluenceTd"><p>Should we use adaptive feedback-directed inlining?</p></td></tr><tr><td class="confluenceTd"><p>early_exit</p></td><td class="confluenceTd"><p>Should AOS exit when the controller clock reaches early_exit_value?</p></td></tr><tr><td class="confluenceTd"><p>osr_promotion</p></td><td class="confluenceTd"><p>Should AOS promote baseline-compiled methods to opt?</p></td></tr><tr><td class="confluenceTd"><p>background_recompilation</p></td><td class="confluenceTd"><p>Should recompilation be done on a background thread or on next invocation?</p></td></tr><tr><td class="confluenceTd"><p>insert_yieldpoint_counters</p></td><td class="confluenceTd"><p>Insert instrumentation in opt recompiled code to count yieldpoints executed?</p></td></tr><tr><td class="confluenceTd"><p>insert_method_counters_opt</p></td><td class="confluenceTd"><p>Insert intrusive method counters in opt recompiled code?</p></td></tr><tr><td class="confluenceTd"><p>insert_instruction_counters</p></td><td class="confluenceTd"><p>Insert counters on all instructions in opt recompiled code?</p></td></tr><tr><td class="confluenceTd"><p>insert_debugging_counters</p></td><td class="confluenceTd"><p>Enable easy insertion of (debugging) counters in opt recompiled code.</p></td></tr><tr><td class="confluenceTd"><p>report_interrupt_stats</p></td><td class="confluenceTd"><p>Report stats related to timer interrupts and AOS listeners on exit.</p></td></tr><tr><td class="confluenceTd"><p>disable_recompile_all_methods</p></td><td class="confluenceTd"><p>Disable the ability for an app to request all methods to be recompiled.</p></td></tr></tbody></table></div><p>Value options</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>method_sample_size</p></td><td class="confluenceTd"><p>How many timer ticks of method samples to take before reporting method hotness to controller.</p></td></tr><tr><td class="confluenceTd"><p>initial_compiler</p></td><td class="confluenceTd"><p>Selection of initial compiler.</p></td></tr><tr><td class="confluenceTd"><p>recompilation_strategy</p></td><td class="confluenceTd"><p>Selection of mechanism for identifying methods for optimizing recompilation.</p></td></tr><tr><td class="confluenceTd"><p>method_listener_trigger</p></td><td class="confluenceTd"><p>What triggers us to take a method sample?</p></td></tr><tr><td class="confluenceTd"><p>call_graph_listener_trigger</p></td><td class="confluenceTd"><p>What triggers us to take a method sample?</p></td></tr><tr><td class="confluenceTd"><p>logfile_name </p></td><td class="confluenceTd"><p>Name of log file.</p></td></tr><tr><td class="confluenceTd"><p>compilation_advice_file_output</p></td><td class="confluenceTd"><p>Name of advice file.</p></td></tr><tr><td class="confluenceTd"><p>dynamic_call_file_output</p></td><td class="confluenceTd"><p>Name of dynamic call graph file.</p></td></tr><tr><td class="confluenceTd"><p>compiler_dna_file</p></td><td class="confluenceTd"><p>Name of compiler DNA file (no name ==&gt; use default DNA).  Discussed in a comment at the head of VM_CompilerDNA.java.</p></td></tr><tr><td class="confluenceTd"><p>compiler_advice_file_input</p></td><td class="confluenceTd"><p>File containing information about the methods to Opt compile.</p></td></tr><tr><td class="confluenceTd"><p>dynamic_call_file_input</p></td><td class="confluenceTd"><p>File containing information about the hot call sites.</p></td></tr><tr><td class="confluenceTd"><p>logging_level</p></td><td class="confluenceTd"><p>Control amount of event logging (larger ==&gt; more).</p></td></tr><tr><td class="confluenceTd"><p>final_report_level</p></td><td class="confluenceTd"><p>Control amount of info reported on exit (larger ==&gt; more).</p></td></tr><tr><td class="confluenceTd"><p>decay_frequency</p></td><td class="confluenceTd"><p>After how many clock ticks should we decay.</p></td></tr><tr><td class="confluenceTd"><p>dcg_decay_rate</p></td><td class="confluenceTd"><p>What factor should we decay call graph edges hotness by.</p></td></tr><tr><td class="confluenceTd"><p>dcg_sample_size</p></td><td class="confluenceTd"><p>After how many timer interrupts do we update the weights in the dynamic call graph?</p></td></tr><tr><td class="confluenceTd"><p>ai_seed_multiplier</p></td><td class="confluenceTd"><p>Initial edge weight of call graph is set to ai_seed_multiplier * (1/ai_control_point).</p></td></tr><tr><td class="confluenceTd"><p>offline_inline_plan_name</p></td><td class="confluenceTd"><p>Name of offline inline plan to be read and used for inlining.</p></td></tr><tr><td class="confluenceTd"><p>early_exit_time</p></td><td class="confluenceTd"><p>Value of controller clock at which AOS should exit if early_exit is true.</p></td></tr><tr><td class="confluenceTd"><p>invocation_count_threshold</p></td><td class="confluenceTd"><p>Invocation count at which a baseline compiled method should be recompiled.</p></td></tr><tr><td class="confluenceTd"><p>invocation_count_opt_level</p></td><td class="confluenceTd"><p>Opt level for recompilation in invocation count based system.</p></td></tr><tr><td class="confluenceTd"><p>counter_based_sample_interval</p></td><td class="confluenceTd"><p>What is the sample interval for counter-based sampling.</p></td></tr><tr><td class="confluenceTd"><p>ai_hot_callsite_threshold</p></td><td class="confluenceTd"><p>What percentage of the total weight of the dcg demarcates warm/hot edges.</p></td></tr><tr><td class="confluenceTd"><p>max_opt_level</p></td><td class="confluenceTd"><p>The maximum optimization level to enable.</p></td></tr></tbody></table></div><h4 id="RunningtheRVM-VirtualMachineNon-StandardCommand-LineOptions">Virtual Machine Non-Standard Command-Line Options</h4><p>Boolean Options</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>measureCompilation</p></td><td class="confluenceTd"><p>Time all compilations and report on exit.</p></td></tr><tr><td class="confluenceTd"><p>measureCompilationPhases</p></td><td class="confluenceTd"><p>Time all compilation sub-phases and report on exit.</p></td></tr><tr><td class="confluenceTd"><p>stackTraceFull</p></td><td class="confluenceTd"><p>Stack traces to consist of VM and application frames.</p></td></tr><tr><td class="confluenceTd"><p>stackTraceAtExit</p></td><td class="confluenceTd"><p>Dump a stack trace (via VM.syswrite) upon exit.</p></td></tr><tr><td class="confluenceTd"><p>verboseTraceClassLoading</p></td><td class="confluenceTd"><p>More detailed tracing then -verbose:class.</p></td></tr><tr><td class="confluenceTd"><p>errorsFatal</p></td><td class="confluenceTd"><p>Exit when non-fatal errors are detected; used for regression testing.</p></td></tr></tbody></table></div><p> Value options</p><div class="table-wrap"><table class="confluenceTable"><tbody><tr><th class="confluenceTh"><p>Option</p></th><th class="confluenceTh"><p>Description</p></th></tr><tr><td class="confluenceTd"><p>maxSystemTroubleRecursionDepth</p></td><td class="confluenceTd"><p>If we get deeper than this in one of the System Trouble functions, try to die.</p></td></tr><tr><td class="confluenceTd"><p>interruptQuantum</p></td><td class="confluenceTd"><p>Timer interrupt scheduling quantum in ms.</p></td></tr><tr><td class="confluenceTd"><p>schedulingMultiplier</p></td><td class="confluenceTd"><p>Scheduling quantum = interruptQuantum * schedulingMultiplier.</p></td></tr><tr><td class="confluenceTd"><p>traceThreadScheduling</p></td><td class="confluenceTd"><p>Trace actions taken by thread scheduling.</p></td></tr><tr><td class="confluenceTd"><p>verboseStackTracePeriod</p></td><td class="confluenceTd"><p>Trace every nth time a stack trace is created.</p></td></tr><tr><td class="confluenceTd"><p>edgeCounterFile</p></td><td class="confluenceTd"><p>Input file of edge counter profile data.</p></td></tr><tr><td class="confluenceTd"><p>CBSCallSamplesPerTick</p></td><td class="confluenceTd"><p>How many CBS call samples (Prologue/Epilogue) should we take per time tick.</p></td></tr><tr><td class="confluenceTd"><p>CBSCallSampleStride</p></td><td class="confluenceTd"><p>Stride between each CBS call sample (Prologue/Epilogue) within a sampling window.</p></td></tr><tr><td class="confluenceTd"><p>CBSMethodSamplesPerTick</p></td><td class="confluenceTd"><p>How many CBS method samples (any yieldpoint) should we take per time tick.</p></td></tr><tr><td class="confluenceTd"><p>CBSMethodSampleStride</p></td><td class="confluenceTd"><p>Stride between each CBS method sample (any yieldpoint) within a sampling window.</p></td></tr><tr><td class="confluenceTd"><p>countThreadTransitions</p></td><td class="confluenceTd"><p>Count, and report, the number of thread state transitions. This works better on IA32 than on PPC at the moment.</p></td></tr><tr><td class="confluenceTd"><p>forceOneCPU</p></td><td class="confluenceTd"><p>Force all threads to run on one CPU. The argument specifies which CPU (starting from 0).</p></td></tr></tbody></table></div><p> </p><h2 id="RunningtheRVM-RunningJikesRVMwithvalgrind">Running Jikes RVM with valgrind</h2><p> Jikes RVM can run under valgrind, as of SVN revision 6791 (29-Aug-2007).  Applying a patch of this revision to release 3.2.1 should also produce a working system.  Versions of valgrind CVS prior to release 3.0 are also known to have worked.</p><p>To run a Jikes RVM build with valgrind, use the <code>-wrap</code> flag to invoke valgrind, eg</p><div class="preformatted panel" style="border-width: 1px;"><div class="preformattedContent panelContent">
<pre>rvm -wrap &quot;path/to/valgrind --smc-check=all &lt;valgrind-options&gt;&quot; &lt;jikesrvm-options&gt; ...</pre>
</div></div><p>this will insert the invocation of valgrind at the appropriate place for it to operate on Jikes RVM proper rather than a wrapper script. </p><p>Under some circumstances, valgrind will load shared object libraries or allocate memory in areas of the heap that conflict with Jikes RVM.  Using the flag -X:gc:eagerMmapSpaces=true will prevent and/or detect this.  If this flag reveals errors while mapping the spaces, you will need to rearrange the heap to avoid the addresses that valgrind is occupying.</p>
                    </div>

                    
                 
                </div>             </div> 
            <div id="footer" style="background: url(http://docs.codehaus.org/images/border/border_bottom.gif) repeat-x;">
                <p><small>Document generated by Confluence on Feb 17, 2012 10:24</small></p>
            </div>
        </div>     </body>
</html>
