<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>RVM : Threading and Yieldpoints</title>
	    <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">	    
    </head>

    <body>
	    <table class="pagecontent" border="0" cellpadding="0" cellspacing="0" width="100%" bgcolor="#ffffff">
		    <tr>
			    <td valign="top" class="pagebody">
				    <div class="pageheader">
					    <span class="pagetitle">
                            RVM : Threading and Yieldpoints
                                                    </span>
				    </div>
				    <div class="pagesubheading">
					    This page last changed on Jul 07, 2008 by <font color="#0050B2">dgrove</font>.
				    </div>

				    <p>For each physical processor on the system, the system creates a pthread. Each pthread is associated with a virtual processor object that&nbsp; executes one or more Java threads in a <em>quasi-preemptive</em> manner, as follows. Each compiler generates <em>yield points</em>, which are program points where the running thread checks a dedicated bit in the virtual processor object to determine if it should yield to another thread. The compilers insert yield points in method prologues, method epilogues, and on loop backedges. Currently, the system sets the thread-switch bit approximately every 10ms.</p>

<p>The adaptive optimization system piggybacks on this yieldpoint mechanism to gather profile data. The thread scheduler provides an<br/>
extension point by which the runtime measurments component can install listeners that execute each time a yieldpoint is taken. Such listeners primarily serve to sample program execution to identify frequently-executed methods and call edges. Because these samples occur at well-known locations (prologues, epilogues, and loop backedges), the listener can easily attribute each sample to the appropriate<br/>
Java source method.</p>

<p>The Jikes RVM implementation introduces a weakness with this mechanism, in that samples can only occur in regions of code that have yieldpoints.&nbsp; Some low-level Jikes RVM subsystems, such as the thread scheduler and the garbage collector, elide yieldpoints because<br/>
those regions of code rely on delicate state invariants that preclude thread switching. These uninterruptible regions can distort sampling accuracy by artificially inflating the probability of sampling&nbsp; the first yieldpoint executed after the program leaves an uninterruptible region of code.</p>

				    
                    			    </td>
		    </tr>
	    </table>
	    <table border="0" cellpadding="0" cellspacing="0" width="100%">
			<tr>
				<td height="12" background="http://docs.codehaus.org/images/border/border_bottom.gif"><img src="images/border/spacer.gif" width="1" height="1" border="0"/></td>
			</tr>
		    <tr>
			    <td align="center"><font color="grey">Document generated by Confluence on Aug 06, 2008 12:40</font></td>
		    </tr>
	    </table>
    </body>
</html>