<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
    <head>
        <title>RVM : Threading and Yieldpoints</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body>
        <div id="page">
            <div id="main">
                <div id="main-header" class="pageSectionHeader">
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            RVM : Threading and Yieldpoints
                        </span>
                    </h1>

                    <div class="page-metadata">
                        <p>This page last changed on Apr 14, 2012 by <font color="#0050B2">ebrangs</font>.</p>
                    </div>
                </div>

                <div id="content" class="view">
                    <div id="main-content" class="wiki-content group">
                    <p><em>Note: The first paragraph is outdated. Jikes RVM uses native threading since <a href="http://docs.codehaus.org/display/RVM/2009/06/10/Jikes+RVM+3.1.0+Released">3.1.0</a></em><em>: For every Java thread, an instance of <code>RVMThread </code>is created which maps directly to a pthread (see <code>start()</code>in<code> <code>RVMThread</code></code>). The current implementation of yieldpoints is similar to the one described here.<br /></em></p><p>For each physical processor on the system, the system creates a pthread. Each pthread is associated with a virtual processor object that  executes one or more Java threads in a <em>quasi-preemptive</em> manner, as follows. Each compiler generates <em>yield points</em>, which are program points where the running thread checks a dedicated bit in the virtual processor object to determine if it should yield to another thread. The compilers insert yield points in method prologues, method epilogues, and on loop backedges. Currently, the system sets the thread-switch bit approximately every 10ms.</p><p>The adaptive optimization system piggybacks on this yieldpoint mechanism to gather profile data. The thread scheduler provides an<br /> extension point by which the runtime measurments component can install listeners that execute each time a yieldpoint is taken. Such listeners primarily serve to sample program execution to identify frequently-executed methods and call edges. Because these samples occur at well-known locations (prologues, epilogues, and loop backedges), the listener can easily attribute each sample to the appropriate<br /> Java source method.</p><p>The Jikes RVM implementation introduces a weakness with this mechanism, in that samples can only occur in regions of code that have yieldpoints.  Some low-level Jikes RVM subsystems, such as the thread scheduler and the garbage collector, elide yieldpoints because<br /> those regions of code rely on delicate state invariants that preclude thread switching. These uninterruptible regions can distort sampling accuracy by artificially inflating the probability of sampling  the first yieldpoint executed after the program leaves an uninterruptible region of code.</p>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" style="background: url(http://docs.codehaus.org/images/border/border_bottom.gif) repeat-x;">
                <p><small>Document generated by Confluence on Feb 12, 2013 09:32</small></p>
            </div>
        </div>     </body>
</html>
